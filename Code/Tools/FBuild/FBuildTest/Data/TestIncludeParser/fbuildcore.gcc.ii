# 1 "/home/ffulin/p4/tmp/Unity/Tools/FBuild/FBuildCore/Unity1.cpp"
# 1 "/home/ffulin/p4/Code//"
# 1 "<built-in>"
# 1 "<command-line>"
# 1 "/usr/include/stdc-predef.h" 1 3 4
# 1 "<command-line>" 2
# 1 "/home/ffulin/p4/tmp/Unity/Tools/FBuild/FBuildCore/Unity1.cpp"



# 1 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Helpers/ResponseFile.cpp" 1





# 1 "./Tools/FBuild/FBuildCore/PrecompiledHeader.h" 1




# 1 "./Core/Containers/Array.h" 1


       





# 1 "./Core/Containers/Sort.h" 1


       





# 1 "./Core/Env/Types.h" 1


       




# 1 "/usr/include/x86_64-linux-gnu/sys/types.h" 1 3 4
# 25 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
# 1 "/usr/include/features.h" 1 3 4
# 374 "/usr/include/features.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 1 3 4
# 385 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 386 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 2 3 4
# 375 "/usr/include/features.h" 2 3 4
# 398 "/usr/include/features.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/gnu/stubs.h" 1 3 4
# 10 "/usr/include/x86_64-linux-gnu/gnu/stubs.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/gnu/stubs-64.h" 1 3 4
# 11 "/usr/include/x86_64-linux-gnu/gnu/stubs.h" 2 3 4
# 399 "/usr/include/features.h" 2 3 4
# 26 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4

extern "C" {

# 1 "/usr/include/x86_64-linux-gnu/bits/types.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 28 "/usr/include/x86_64-linux-gnu/bits/types.h" 2 3 4


typedef unsigned char __u_char;
typedef unsigned short int __u_short;
typedef unsigned int __u_int;
typedef unsigned long int __u_long;


typedef signed char __int8_t;
typedef unsigned char __uint8_t;
typedef signed short int __int16_t;
typedef unsigned short int __uint16_t;
typedef signed int __int32_t;
typedef unsigned int __uint32_t;

typedef signed long int __int64_t;
typedef unsigned long int __uint64_t;







typedef long int __quad_t;
typedef unsigned long int __u_quad_t;
# 121 "/usr/include/x86_64-linux-gnu/bits/types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/typesizes.h" 1 3 4
# 122 "/usr/include/x86_64-linux-gnu/bits/types.h" 2 3 4


typedef unsigned long int __dev_t;
typedef unsigned int __uid_t;
typedef unsigned int __gid_t;
typedef unsigned long int __ino_t;
typedef unsigned long int __ino64_t;
typedef unsigned int __mode_t;
typedef unsigned long int __nlink_t;
typedef long int __off_t;
typedef long int __off64_t;
typedef int __pid_t;
typedef struct { int __val[2]; } __fsid_t;
typedef long int __clock_t;
typedef unsigned long int __rlim_t;
typedef unsigned long int __rlim64_t;
typedef unsigned int __id_t;
typedef long int __time_t;
typedef unsigned int __useconds_t;
typedef long int __suseconds_t;

typedef int __daddr_t;
typedef int __key_t;


typedef int __clockid_t;


typedef void * __timer_t;


typedef long int __blksize_t;




typedef long int __blkcnt_t;
typedef long int __blkcnt64_t;


typedef unsigned long int __fsblkcnt_t;
typedef unsigned long int __fsblkcnt64_t;


typedef unsigned long int __fsfilcnt_t;
typedef unsigned long int __fsfilcnt64_t;


typedef long int __fsword_t;

typedef long int __ssize_t;


typedef long int __syscall_slong_t;

typedef unsigned long int __syscall_ulong_t;



typedef __off64_t __loff_t;
typedef __quad_t *__qaddr_t;
typedef char *__caddr_t;


typedef long int __intptr_t;


typedef unsigned int __socklen_t;
# 30 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4



typedef __u_char u_char;
typedef __u_short u_short;
typedef __u_int u_int;
typedef __u_long u_long;
typedef __quad_t quad_t;
typedef __u_quad_t u_quad_t;
typedef __fsid_t fsid_t;




typedef __loff_t loff_t;



typedef __ino_t ino_t;






typedef __ino64_t ino64_t;




typedef __dev_t dev_t;




typedef __gid_t gid_t;




typedef __mode_t mode_t;




typedef __nlink_t nlink_t;




typedef __uid_t uid_t;





typedef __off_t off_t;






typedef __off64_t off64_t;




typedef __pid_t pid_t;





typedef __id_t id_t;




typedef __ssize_t ssize_t;





typedef __daddr_t daddr_t;
typedef __caddr_t caddr_t;





typedef __key_t key_t;
# 132 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
# 1 "/usr/include/time.h" 1 3 4
# 57 "/usr/include/time.h" 3 4


typedef __clock_t clock_t;



# 73 "/usr/include/time.h" 3 4


typedef __time_t time_t;



# 91 "/usr/include/time.h" 3 4
typedef __clockid_t clockid_t;
# 103 "/usr/include/time.h" 3 4
typedef __timer_t timer_t;
# 133 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4



typedef __useconds_t useconds_t;



typedef __suseconds_t suseconds_t;





# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.9/include/stddef.h" 1 3 4
# 212 "/usr/lib/gcc/x86_64-linux-gnu/4.9/include/stddef.h" 3 4
typedef long unsigned int size_t;
# 147 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4



typedef unsigned long int ulong;
typedef unsigned short int ushort;
typedef unsigned int uint;
# 194 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
typedef int int8_t __attribute__ ((__mode__ (__QI__)));
typedef int int16_t __attribute__ ((__mode__ (__HI__)));
typedef int int32_t __attribute__ ((__mode__ (__SI__)));
typedef int int64_t __attribute__ ((__mode__ (__DI__)));


typedef unsigned int u_int8_t __attribute__ ((__mode__ (__QI__)));
typedef unsigned int u_int16_t __attribute__ ((__mode__ (__HI__)));
typedef unsigned int u_int32_t __attribute__ ((__mode__ (__SI__)));
typedef unsigned int u_int64_t __attribute__ ((__mode__ (__DI__)));

typedef int register_t __attribute__ ((__mode__ (__word__)));
# 216 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
# 1 "/usr/include/endian.h" 1 3 4
# 36 "/usr/include/endian.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/endian.h" 1 3 4
# 37 "/usr/include/endian.h" 2 3 4
# 60 "/usr/include/endian.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 1 3 4
# 28 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 29 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 2 3 4






# 1 "/usr/include/x86_64-linux-gnu/bits/byteswap-16.h" 1 3 4
# 36 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 2 3 4
# 44 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 3 4
static __inline unsigned int
__bswap_32 (unsigned int __bsx)
{
  return __builtin_bswap32 (__bsx);
}
# 108 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 3 4
static __inline __uint64_t
__bswap_64 (__uint64_t __bsx)
{
  return __builtin_bswap64 (__bsx);
}
# 61 "/usr/include/endian.h" 2 3 4
# 217 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/sys/select.h" 1 3 4
# 30 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/select.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/select.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/select.h" 2 3 4
# 31 "/usr/include/x86_64-linux-gnu/sys/select.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/sigset.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/sigset.h" 3 4
typedef int __sig_atomic_t;




typedef struct
  {
    unsigned long int __val[(1024 / (8 * sizeof (unsigned long int)))];
  } __sigset_t;
# 34 "/usr/include/x86_64-linux-gnu/sys/select.h" 2 3 4



typedef __sigset_t sigset_t;





# 1 "/usr/include/time.h" 1 3 4
# 120 "/usr/include/time.h" 3 4
struct timespec
  {
    __time_t tv_sec;
    __syscall_slong_t tv_nsec;
  };
# 44 "/usr/include/x86_64-linux-gnu/sys/select.h" 2 3 4

# 1 "/usr/include/x86_64-linux-gnu/bits/time.h" 1 3 4
# 30 "/usr/include/x86_64-linux-gnu/bits/time.h" 3 4
struct timeval
  {
    __time_t tv_sec;
    __suseconds_t tv_usec;
  };
# 46 "/usr/include/x86_64-linux-gnu/sys/select.h" 2 3 4
# 54 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
typedef long int __fd_mask;
# 64 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
typedef struct
  {



    __fd_mask fds_bits[1024 / (8 * (int) sizeof (__fd_mask))];





  } fd_set;






typedef __fd_mask fd_mask;
# 96 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
extern "C" {
# 106 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
extern int select (int __nfds, fd_set *__restrict __readfds,
     fd_set *__restrict __writefds,
     fd_set *__restrict __exceptfds,
     struct timeval *__restrict __timeout);
# 118 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
extern int pselect (int __nfds, fd_set *__restrict __readfds,
      fd_set *__restrict __writefds,
      fd_set *__restrict __exceptfds,
      const struct timespec *__restrict __timeout,
      const __sigset_t *__restrict __sigmask);
# 131 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
}
# 220 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/sys/sysmacros.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/sys/sysmacros.h" 3 4
extern "C" {

__extension__
extern unsigned int gnu_dev_major (unsigned long long int __dev)
     throw () __attribute__ ((__const__));
__extension__
extern unsigned int gnu_dev_minor (unsigned long long int __dev)
     throw () __attribute__ ((__const__));
__extension__
extern unsigned long long int gnu_dev_makedev (unsigned int __major,
            unsigned int __minor)
     throw () __attribute__ ((__const__));
# 58 "/usr/include/x86_64-linux-gnu/sys/sysmacros.h" 3 4
}
# 223 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4





typedef __blksize_t blksize_t;






typedef __blkcnt_t blkcnt_t;



typedef __fsblkcnt_t fsblkcnt_t;



typedef __fsfilcnt_t fsfilcnt_t;
# 262 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
typedef __blkcnt64_t blkcnt64_t;
typedef __fsblkcnt64_t fsblkcnt64_t;
typedef __fsfilcnt64_t fsfilcnt64_t;





# 1 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 1 3 4
# 21 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 2 3 4
# 60 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 3 4
typedef unsigned long int pthread_t;


union pthread_attr_t
{
  char __size[56];
  long int __align;
};

typedef union pthread_attr_t pthread_attr_t;





typedef struct __pthread_internal_list
{
  struct __pthread_internal_list *__prev;
  struct __pthread_internal_list *__next;
} __pthread_list_t;
# 90 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 3 4
typedef union
{
  struct __pthread_mutex_s
  {
    int __lock;
    unsigned int __count;
    int __owner;

    unsigned int __nusers;



    int __kind;

    short __spins;
    short __elision;
    __pthread_list_t __list;
# 124 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 3 4
  } __data;
  char __size[40];
  long int __align;
} pthread_mutex_t;

typedef union
{
  char __size[4];
  int __align;
} pthread_mutexattr_t;




typedef union
{
  struct
  {
    int __lock;
    unsigned int __futex;
    __extension__ unsigned long long int __total_seq;
    __extension__ unsigned long long int __wakeup_seq;
    __extension__ unsigned long long int __woken_seq;
    void *__mutex;
    unsigned int __nwaiters;
    unsigned int __broadcast_seq;
  } __data;
  char __size[48];
  __extension__ long long int __align;
} pthread_cond_t;

typedef union
{
  char __size[4];
  int __align;
} pthread_condattr_t;



typedef unsigned int pthread_key_t;



typedef int pthread_once_t;





typedef union
{

  struct
  {
    int __lock;
    unsigned int __nr_readers;
    unsigned int __readers_wakeup;
    unsigned int __writer_wakeup;
    unsigned int __nr_readers_queued;
    unsigned int __nr_writers_queued;
    int __writer;
    int __shared;
    unsigned long int __pad1;
    unsigned long int __pad2;


    unsigned int __flags;

  } __data;
# 211 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 3 4
  char __size[56];
  long int __align;
} pthread_rwlock_t;

typedef union
{
  char __size[8];
  long int __align;
} pthread_rwlockattr_t;





typedef volatile int pthread_spinlock_t;




typedef union
{
  char __size[32];
  long int __align;
} pthread_barrier_t;

typedef union
{
  char __size[4];
  int __align;
} pthread_barrierattr_t;
# 271 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4


}
# 9 "./Core/Env/Types.h" 2


typedef unsigned char uint8_t;
typedef signed char int8_t;
typedef unsigned short uint16_t;
typedef signed short int16_t;
typedef unsigned int uint32_t;
typedef signed int int32_t;







    typedef unsigned long int uint64_t;
    typedef signed long int int64_t;
# 48 "./Core/Env/Types.h"
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.9/include/stddef.h" 1 3 4
# 147 "/usr/lib/gcc/x86_64-linux-gnu/4.9/include/stddef.h" 3 4
typedef long int ptrdiff_t;
# 422 "/usr/lib/gcc/x86_64-linux-gnu/4.9/include/stddef.h" 3 4
typedef struct {
  long long __max_align_ll __attribute__((__aligned__(__alignof__(long long))));
  long double __max_align_ld __attribute__((__aligned__(__alignof__(long double))));
} max_align_t;






  typedef decltype(nullptr) nullptr_t;
# 49 "./Core/Env/Types.h" 2
# 63 "./Core/Env/Types.h"
   typedef uint64_t uintptr_t;
# 88 "./Core/Env/Types.h"
 typedef long long LONGLONG;
# 10 "./Core/Containers/Sort.h" 2



class AscendingCompare
{
public:
 template < class T >
 inline bool operator () ( const T & a, const T & b ) const
 {
  return ( a < b );
 }
};



class AscendingCompareDeref
{
public:
 template < class T >
 inline bool operator () ( const T & a, const T & b ) const
 {
  return ( ( *a ) < ( *b ) );
 }
};



template < class T, class COMPARE >
void ShellSort( T * begin, T * end, const COMPARE & compare )
{
 size_t numItems = end - begin;
 size_t increment = 3;
 while ( increment > 0 )
 {
  for ( size_t i=0; i < numItems; i++ )
  {
   size_t j = i;
   T temp( begin[ i ] );
   while ( ( j >= increment ) && ( compare( temp, begin[ j - increment ] ) ) )
   {
    begin[ j ] = begin[ j - increment ];
    j = j - increment;
   }
   begin[ j ] = temp;
  }
  if ( increment / 2 != 0 )
  {
   increment = increment / 2 ;
  }
  else if ( increment == 1 )
  {
   increment = 0;
  }
  else
  {
   increment = 1;
  }
 }
}
# 10 "./Core/Containers/Array.h" 2
# 1 "./Core/Env/Assert.h" 1


       
# 25 "./Core/Env/Assert.h"
bool IsDebuggerAttached();
# 70 "./Core/Env/Assert.h"
 template<bool> struct compile_time_assert_failure;
 template<> struct compile_time_assert_failure<true>{};

 class AssertHandler
 {
 public:
  static void SetThrowOnAssert( bool throwOnAssert )
  {
   s_ThrowOnAssert = throwOnAssert;
  }
  static bool Failure( const char * message,
        const char * file,
        const int line );
  static bool FailureM( const char * message,
        const char * file,
        const int line,
        const char * msgFormat,
        ... );

  static bool s_ThrowOnAssert;
 };
# 11 "./Core/Containers/Array.h" 2

# 1 "./Core/Math/Conversions.h" 1


       
# 13 "./Core/Math/Conversions.h"
namespace Math
{
 template <class T>
 static inline T RoundUp( T value, T alignment )
 {
  return ( value + alignment - 1) & ~( alignment - 1 );
 }
 template <class T>
 static inline T Max( T a, T b )
 {
  return ( a > b ) ? a : b;
 }
 template <class T>
 static inline T Min( T a, T b )
 {
  return ( a < b ) ? a : b;
 }
 template <class T>
 static inline T Clamp( T a, T b, T c )
 {
  return Min( Max( a, b ), c );
 }
 template <typename T>
 static inline bool IsPowerOf2( T value )
 {
  return ( ( ( value - 1 ) & value ) == 0 );
 }

};
# 13 "./Core/Containers/Array.h" 2
# 1 "./Core/Mem/Mem.h" 1


       






# 1 "./Core/Mem/MemTracker.h" 1


       
# 25 "./Core/Mem/MemTracker.h"
# 1 "./Core/Process/Mutex.h" 1


       
# 12 "./Core/Process/Mutex.h"
# 1 "/usr/include/pthread.h" 1 3 4
# 23 "/usr/include/pthread.h" 3 4
# 1 "/usr/include/sched.h" 1 3 4
# 28 "/usr/include/sched.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.9/include/stddef.h" 1 3 4
# 29 "/usr/include/sched.h" 2 3 4



# 1 "/usr/include/time.h" 1 3 4
# 33 "/usr/include/sched.h" 2 3 4
# 41 "/usr/include/sched.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/sched.h" 1 3 4
# 72 "/usr/include/x86_64-linux-gnu/bits/sched.h" 3 4
struct sched_param
  {
    int __sched_priority;
  };

extern "C" {



extern int clone (int (*__fn) (void *__arg), void *__child_stack,
    int __flags, void *__arg, ...) throw ();


extern int unshare (int __flags) throw ();


extern int sched_getcpu (void) throw ();


extern int setns (int __fd, int __nstype) throw ();



}







struct __sched_param
  {
    int __sched_priority;
  };
# 118 "/usr/include/x86_64-linux-gnu/bits/sched.h" 3 4
typedef unsigned long int __cpu_mask;






typedef struct
{
  __cpu_mask __bits[1024 / (8 * sizeof (__cpu_mask))];
} cpu_set_t;
# 201 "/usr/include/x86_64-linux-gnu/bits/sched.h" 3 4
extern "C" {

extern int __sched_cpucount (size_t __setsize, const cpu_set_t *__setp)
  throw ();
extern cpu_set_t *__sched_cpualloc (size_t __count) throw () ;
extern void __sched_cpufree (cpu_set_t *__set) throw ();

}
# 42 "/usr/include/sched.h" 2 3 4




extern "C" {


extern int sched_setparam (__pid_t __pid, const struct sched_param *__param)
     throw ();


extern int sched_getparam (__pid_t __pid, struct sched_param *__param) throw ();


extern int sched_setscheduler (__pid_t __pid, int __policy,
          const struct sched_param *__param) throw ();


extern int sched_getscheduler (__pid_t __pid) throw ();


extern int sched_yield (void) throw ();


extern int sched_get_priority_max (int __algorithm) throw ();


extern int sched_get_priority_min (int __algorithm) throw ();


extern int sched_rr_get_interval (__pid_t __pid, struct timespec *__t) throw ();
# 116 "/usr/include/sched.h" 3 4
extern int sched_setaffinity (__pid_t __pid, size_t __cpusetsize,
         const cpu_set_t *__cpuset) throw ();


extern int sched_getaffinity (__pid_t __pid, size_t __cpusetsize,
         cpu_set_t *__cpuset) throw ();


}
# 24 "/usr/include/pthread.h" 2 3 4
# 1 "/usr/include/time.h" 1 3 4
# 29 "/usr/include/time.h" 3 4
extern "C" {







# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.9/include/stddef.h" 1 3 4
# 38 "/usr/include/time.h" 2 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/time.h" 1 3 4
# 86 "/usr/include/x86_64-linux-gnu/bits/time.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/timex.h" 1 3 4
# 25 "/usr/include/x86_64-linux-gnu/bits/timex.h" 3 4
struct timex
{
  unsigned int modes;
  __syscall_slong_t offset;
  __syscall_slong_t freq;
  __syscall_slong_t maxerror;
  __syscall_slong_t esterror;
  int status;
  __syscall_slong_t constant;
  __syscall_slong_t precision;
  __syscall_slong_t tolerance;
  struct timeval time;
  __syscall_slong_t tick;
  __syscall_slong_t ppsfreq;
  __syscall_slong_t jitter;
  int shift;
  __syscall_slong_t stabil;
  __syscall_slong_t jitcnt;
  __syscall_slong_t calcnt;
  __syscall_slong_t errcnt;
  __syscall_slong_t stbcnt;

  int tai;


  int :32; int :32; int :32; int :32;
  int :32; int :32; int :32; int :32;
  int :32; int :32; int :32;
};
# 87 "/usr/include/x86_64-linux-gnu/bits/time.h" 2 3 4

extern "C" {


extern int clock_adjtime (__clockid_t __clock_id, struct timex *__utx) throw ();

}
# 42 "/usr/include/time.h" 2 3 4
# 131 "/usr/include/time.h" 3 4


struct tm
{
  int tm_sec;
  int tm_min;
  int tm_hour;
  int tm_mday;
  int tm_mon;
  int tm_year;
  int tm_wday;
  int tm_yday;
  int tm_isdst;


  long int tm_gmtoff;
  const char *tm_zone;




};








struct itimerspec
  {
    struct timespec it_interval;
    struct timespec it_value;
  };


struct sigevent;
# 186 "/usr/include/time.h" 3 4



extern clock_t clock (void) throw ();


extern time_t time (time_t *__timer) throw ();


extern double difftime (time_t __time1, time_t __time0)
     throw () __attribute__ ((__const__));


extern time_t mktime (struct tm *__tp) throw ();





extern size_t strftime (char *__restrict __s, size_t __maxsize,
   const char *__restrict __format,
   const struct tm *__restrict __tp) throw ();





extern char *strptime (const char *__restrict __s,
         const char *__restrict __fmt, struct tm *__tp)
     throw ();





# 1 "/usr/include/xlocale.h" 1 3 4
# 27 "/usr/include/xlocale.h" 3 4
typedef struct __locale_struct
{

  struct __locale_data *__locales[13];


  const unsigned short int *__ctype_b;
  const int *__ctype_tolower;
  const int *__ctype_toupper;


  const char *__names[13];
} *__locale_t;


typedef __locale_t locale_t;
# 222 "/usr/include/time.h" 2 3 4

extern size_t strftime_l (char *__restrict __s, size_t __maxsize,
     const char *__restrict __format,
     const struct tm *__restrict __tp,
     __locale_t __loc) throw ();



extern char *strptime_l (const char *__restrict __s,
    const char *__restrict __fmt, struct tm *__tp,
    __locale_t __loc) throw ();






extern struct tm *gmtime (const time_t *__timer) throw ();



extern struct tm *localtime (const time_t *__timer) throw ();





extern struct tm *gmtime_r (const time_t *__restrict __timer,
       struct tm *__restrict __tp) throw ();



extern struct tm *localtime_r (const time_t *__restrict __timer,
          struct tm *__restrict __tp) throw ();





extern char *asctime (const struct tm *__tp) throw ();


extern char *ctime (const time_t *__timer) throw ();







extern char *asctime_r (const struct tm *__restrict __tp,
   char *__restrict __buf) throw ();


extern char *ctime_r (const time_t *__restrict __timer,
        char *__restrict __buf) throw ();




extern char *__tzname[2];
extern int __daylight;
extern long int __timezone;




extern char *tzname[2];



extern void tzset (void) throw ();



extern int daylight;
extern long int timezone;





extern int stime (const time_t *__when) throw ();
# 319 "/usr/include/time.h" 3 4
extern time_t timegm (struct tm *__tp) throw ();


extern time_t timelocal (struct tm *__tp) throw ();


extern int dysize (int __year) throw () __attribute__ ((__const__));
# 334 "/usr/include/time.h" 3 4
extern int nanosleep (const struct timespec *__requested_time,
        struct timespec *__remaining);



extern int clock_getres (clockid_t __clock_id, struct timespec *__res) throw ();


extern int clock_gettime (clockid_t __clock_id, struct timespec *__tp) throw ();


extern int clock_settime (clockid_t __clock_id, const struct timespec *__tp)
     throw ();






extern int clock_nanosleep (clockid_t __clock_id, int __flags,
       const struct timespec *__req,
       struct timespec *__rem);


extern int clock_getcpuclockid (pid_t __pid, clockid_t *__clock_id) throw ();




extern int timer_create (clockid_t __clock_id,
    struct sigevent *__restrict __evp,
    timer_t *__restrict __timerid) throw ();


extern int timer_delete (timer_t __timerid) throw ();


extern int timer_settime (timer_t __timerid, int __flags,
     const struct itimerspec *__restrict __value,
     struct itimerspec *__restrict __ovalue) throw ();


extern int timer_gettime (timer_t __timerid, struct itimerspec *__value)
     throw ();


extern int timer_getoverrun (timer_t __timerid) throw ();





extern int timespec_get (struct timespec *__ts, int __base)
     throw () __attribute__ ((__nonnull__ (1)));
# 403 "/usr/include/time.h" 3 4
extern int getdate_err;
# 412 "/usr/include/time.h" 3 4
extern struct tm *getdate (const char *__string);
# 426 "/usr/include/time.h" 3 4
extern int getdate_r (const char *__restrict __string,
        struct tm *__restrict __resbufp);


}
# 25 "/usr/include/pthread.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/setjmp.h" 1 3 4
# 26 "/usr/include/x86_64-linux-gnu/bits/setjmp.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/setjmp.h" 2 3 4




typedef long int __jmp_buf[8];
# 28 "/usr/include/pthread.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 29 "/usr/include/pthread.h" 2 3 4



enum
{
  PTHREAD_CREATE_JOINABLE,

  PTHREAD_CREATE_DETACHED

};



enum
{
  PTHREAD_MUTEX_TIMED_NP,
  PTHREAD_MUTEX_RECURSIVE_NP,
  PTHREAD_MUTEX_ERRORCHECK_NP,
  PTHREAD_MUTEX_ADAPTIVE_NP

  ,
  PTHREAD_MUTEX_NORMAL = PTHREAD_MUTEX_TIMED_NP,
  PTHREAD_MUTEX_RECURSIVE = PTHREAD_MUTEX_RECURSIVE_NP,
  PTHREAD_MUTEX_ERRORCHECK = PTHREAD_MUTEX_ERRORCHECK_NP,
  PTHREAD_MUTEX_DEFAULT = PTHREAD_MUTEX_NORMAL



  , PTHREAD_MUTEX_FAST_NP = PTHREAD_MUTEX_TIMED_NP

};




enum
{
  PTHREAD_MUTEX_STALLED,
  PTHREAD_MUTEX_STALLED_NP = PTHREAD_MUTEX_STALLED,
  PTHREAD_MUTEX_ROBUST,
  PTHREAD_MUTEX_ROBUST_NP = PTHREAD_MUTEX_ROBUST
};





enum
{
  PTHREAD_PRIO_NONE,
  PTHREAD_PRIO_INHERIT,
  PTHREAD_PRIO_PROTECT
};
# 125 "/usr/include/pthread.h" 3 4
enum
{
  PTHREAD_RWLOCK_PREFER_READER_NP,
  PTHREAD_RWLOCK_PREFER_WRITER_NP,
  PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP,
  PTHREAD_RWLOCK_DEFAULT_NP = PTHREAD_RWLOCK_PREFER_READER_NP
};
# 166 "/usr/include/pthread.h" 3 4
enum
{
  PTHREAD_INHERIT_SCHED,

  PTHREAD_EXPLICIT_SCHED

};



enum
{
  PTHREAD_SCOPE_SYSTEM,

  PTHREAD_SCOPE_PROCESS

};



enum
{
  PTHREAD_PROCESS_PRIVATE,

  PTHREAD_PROCESS_SHARED

};
# 201 "/usr/include/pthread.h" 3 4
struct _pthread_cleanup_buffer
{
  void (*__routine) (void *);
  void *__arg;
  int __canceltype;
  struct _pthread_cleanup_buffer *__prev;
};


enum
{
  PTHREAD_CANCEL_ENABLE,

  PTHREAD_CANCEL_DISABLE

};
enum
{
  PTHREAD_CANCEL_DEFERRED,

  PTHREAD_CANCEL_ASYNCHRONOUS

};
# 239 "/usr/include/pthread.h" 3 4
extern "C" {




extern int pthread_create (pthread_t *__restrict __newthread,
      const pthread_attr_t *__restrict __attr,
      void *(*__start_routine) (void *),
      void *__restrict __arg) throw () __attribute__ ((__nonnull__ (1, 3)));





extern void pthread_exit (void *__retval) __attribute__ ((__noreturn__));







extern int pthread_join (pthread_t __th, void **__thread_return);




extern int pthread_tryjoin_np (pthread_t __th, void **__thread_return) throw ();







extern int pthread_timedjoin_np (pthread_t __th, void **__thread_return,
     const struct timespec *__abstime);






extern int pthread_detach (pthread_t __th) throw ();



extern pthread_t pthread_self (void) throw () __attribute__ ((__const__));


extern int pthread_equal (pthread_t __thread1, pthread_t __thread2)
  throw () __attribute__ ((__const__));







extern int pthread_attr_init (pthread_attr_t *__attr) throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_attr_destroy (pthread_attr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_attr_getdetachstate (const pthread_attr_t *__attr,
     int *__detachstate)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setdetachstate (pthread_attr_t *__attr,
     int __detachstate)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_attr_getguardsize (const pthread_attr_t *__attr,
          size_t *__guardsize)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setguardsize (pthread_attr_t *__attr,
          size_t __guardsize)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_attr_getschedparam (const pthread_attr_t *__restrict __attr,
           struct sched_param *__restrict __param)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setschedparam (pthread_attr_t *__restrict __attr,
           const struct sched_param *__restrict
           __param) throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_getschedpolicy (const pthread_attr_t *__restrict
     __attr, int *__restrict __policy)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setschedpolicy (pthread_attr_t *__attr, int __policy)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_attr_getinheritsched (const pthread_attr_t *__restrict
      __attr, int *__restrict __inherit)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setinheritsched (pthread_attr_t *__attr,
      int __inherit)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_attr_getscope (const pthread_attr_t *__restrict __attr,
      int *__restrict __scope)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setscope (pthread_attr_t *__attr, int __scope)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_attr_getstackaddr (const pthread_attr_t *__restrict
          __attr, void **__restrict __stackaddr)
     throw () __attribute__ ((__nonnull__ (1, 2))) __attribute__ ((__deprecated__));





extern int pthread_attr_setstackaddr (pthread_attr_t *__attr,
          void *__stackaddr)
     throw () __attribute__ ((__nonnull__ (1))) __attribute__ ((__deprecated__));


extern int pthread_attr_getstacksize (const pthread_attr_t *__restrict
          __attr, size_t *__restrict __stacksize)
     throw () __attribute__ ((__nonnull__ (1, 2)));




extern int pthread_attr_setstacksize (pthread_attr_t *__attr,
          size_t __stacksize)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_attr_getstack (const pthread_attr_t *__restrict __attr,
      void **__restrict __stackaddr,
      size_t *__restrict __stacksize)
     throw () __attribute__ ((__nonnull__ (1, 2, 3)));




extern int pthread_attr_setstack (pthread_attr_t *__attr, void *__stackaddr,
      size_t __stacksize) throw () __attribute__ ((__nonnull__ (1)));





extern int pthread_attr_setaffinity_np (pthread_attr_t *__attr,
     size_t __cpusetsize,
     const cpu_set_t *__cpuset)
     throw () __attribute__ ((__nonnull__ (1, 3)));



extern int pthread_attr_getaffinity_np (const pthread_attr_t *__attr,
     size_t __cpusetsize,
     cpu_set_t *__cpuset)
     throw () __attribute__ ((__nonnull__ (1, 3)));


extern int pthread_getattr_default_np (pthread_attr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_setattr_default_np (const pthread_attr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));




extern int pthread_getattr_np (pthread_t __th, pthread_attr_t *__attr)
     throw () __attribute__ ((__nonnull__ (2)));







extern int pthread_setschedparam (pthread_t __target_thread, int __policy,
      const struct sched_param *__param)
     throw () __attribute__ ((__nonnull__ (3)));


extern int pthread_getschedparam (pthread_t __target_thread,
      int *__restrict __policy,
      struct sched_param *__restrict __param)
     throw () __attribute__ ((__nonnull__ (2, 3)));


extern int pthread_setschedprio (pthread_t __target_thread, int __prio)
     throw ();




extern int pthread_getname_np (pthread_t __target_thread, char *__buf,
          size_t __buflen)
     throw () __attribute__ ((__nonnull__ (2)));


extern int pthread_setname_np (pthread_t __target_thread, const char *__name)
     throw () __attribute__ ((__nonnull__ (2)));





extern int pthread_getconcurrency (void) throw ();


extern int pthread_setconcurrency (int __level) throw ();







extern int pthread_yield (void) throw ();




extern int pthread_setaffinity_np (pthread_t __th, size_t __cpusetsize,
       const cpu_set_t *__cpuset)
     throw () __attribute__ ((__nonnull__ (3)));


extern int pthread_getaffinity_np (pthread_t __th, size_t __cpusetsize,
       cpu_set_t *__cpuset)
     throw () __attribute__ ((__nonnull__ (3)));
# 505 "/usr/include/pthread.h" 3 4
extern int pthread_once (pthread_once_t *__once_control,
    void (*__init_routine) (void)) __attribute__ ((__nonnull__ (1, 2)));
# 517 "/usr/include/pthread.h" 3 4
extern int pthread_setcancelstate (int __state, int *__oldstate);



extern int pthread_setcanceltype (int __type, int *__oldtype);


extern int pthread_cancel (pthread_t __th);




extern void pthread_testcancel (void);




typedef struct
{
  struct
  {
    __jmp_buf __cancel_jmp_buf;
    int __mask_was_saved;
  } __cancel_jmp_buf[1];
  void *__pad[4];
} __pthread_unwind_buf_t __attribute__ ((__aligned__));
# 551 "/usr/include/pthread.h" 3 4
struct __pthread_cleanup_frame
{
  void (*__cancel_routine) (void *);
  void *__cancel_arg;
  int __do_it;
  int __cancel_type;
};




class __pthread_cleanup_class
{
  void (*__cancel_routine) (void *);
  void *__cancel_arg;
  int __do_it;
  int __cancel_type;

 public:
  __pthread_cleanup_class (void (*__fct) (void *), void *__arg)
    : __cancel_routine (__fct), __cancel_arg (__arg), __do_it (1) { }
  ~__pthread_cleanup_class () { if (__do_it) __cancel_routine (__cancel_arg); }
  void __setdoit (int __newval) { __do_it = __newval; }
  void __defer () { pthread_setcanceltype (PTHREAD_CANCEL_DEFERRED,
        &__cancel_type); }
  void __restore () const { pthread_setcanceltype (__cancel_type, 0); }
};
# 753 "/usr/include/pthread.h" 3 4
struct __jmp_buf_tag;
extern int __sigsetjmp (struct __jmp_buf_tag *__env, int __savemask) throw ();





extern int pthread_mutex_init (pthread_mutex_t *__mutex,
          const pthread_mutexattr_t *__mutexattr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_mutex_destroy (pthread_mutex_t *__mutex)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_mutex_trylock (pthread_mutex_t *__mutex)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_mutex_lock (pthread_mutex_t *__mutex)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_mutex_timedlock (pthread_mutex_t *__restrict __mutex,
        const struct timespec *__restrict
        __abstime) throw () __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_mutex_unlock (pthread_mutex_t *__mutex)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_mutex_getprioceiling (const pthread_mutex_t *
      __restrict __mutex,
      int *__restrict __prioceiling)
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_mutex_setprioceiling (pthread_mutex_t *__restrict __mutex,
      int __prioceiling,
      int *__restrict __old_ceiling)
     throw () __attribute__ ((__nonnull__ (1, 3)));




extern int pthread_mutex_consistent (pthread_mutex_t *__mutex)
     throw () __attribute__ ((__nonnull__ (1)));

extern int pthread_mutex_consistent_np (pthread_mutex_t *__mutex)
     throw () __attribute__ ((__nonnull__ (1)));
# 817 "/usr/include/pthread.h" 3 4
extern int pthread_mutexattr_init (pthread_mutexattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_mutexattr_destroy (pthread_mutexattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_mutexattr_getpshared (const pthread_mutexattr_t *
      __restrict __attr,
      int *__restrict __pshared)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_mutexattr_setpshared (pthread_mutexattr_t *__attr,
      int __pshared)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_mutexattr_gettype (const pthread_mutexattr_t *__restrict
          __attr, int *__restrict __kind)
     throw () __attribute__ ((__nonnull__ (1, 2)));




extern int pthread_mutexattr_settype (pthread_mutexattr_t *__attr, int __kind)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_mutexattr_getprotocol (const pthread_mutexattr_t *
       __restrict __attr,
       int *__restrict __protocol)
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_mutexattr_setprotocol (pthread_mutexattr_t *__attr,
       int __protocol)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_mutexattr_getprioceiling (const pthread_mutexattr_t *
          __restrict __attr,
          int *__restrict __prioceiling)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_mutexattr_setprioceiling (pthread_mutexattr_t *__attr,
          int __prioceiling)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_mutexattr_getrobust (const pthread_mutexattr_t *__attr,
     int *__robustness)
     throw () __attribute__ ((__nonnull__ (1, 2)));

extern int pthread_mutexattr_getrobust_np (const pthread_mutexattr_t *__attr,
        int *__robustness)
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_mutexattr_setrobust (pthread_mutexattr_t *__attr,
     int __robustness)
     throw () __attribute__ ((__nonnull__ (1)));

extern int pthread_mutexattr_setrobust_np (pthread_mutexattr_t *__attr,
        int __robustness)
     throw () __attribute__ ((__nonnull__ (1)));
# 899 "/usr/include/pthread.h" 3 4
extern int pthread_rwlock_init (pthread_rwlock_t *__restrict __rwlock,
    const pthread_rwlockattr_t *__restrict
    __attr) throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlock_destroy (pthread_rwlock_t *__rwlock)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlock_rdlock (pthread_rwlock_t *__rwlock)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlock_tryrdlock (pthread_rwlock_t *__rwlock)
  throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_rwlock_timedrdlock (pthread_rwlock_t *__restrict __rwlock,
           const struct timespec *__restrict
           __abstime) throw () __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_rwlock_wrlock (pthread_rwlock_t *__rwlock)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlock_trywrlock (pthread_rwlock_t *__rwlock)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_rwlock_timedwrlock (pthread_rwlock_t *__restrict __rwlock,
           const struct timespec *__restrict
           __abstime) throw () __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_rwlock_unlock (pthread_rwlock_t *__rwlock)
     throw () __attribute__ ((__nonnull__ (1)));





extern int pthread_rwlockattr_init (pthread_rwlockattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlockattr_destroy (pthread_rwlockattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlockattr_getpshared (const pthread_rwlockattr_t *
       __restrict __attr,
       int *__restrict __pshared)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_rwlockattr_setpshared (pthread_rwlockattr_t *__attr,
       int __pshared)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlockattr_getkind_np (const pthread_rwlockattr_t *
       __restrict __attr,
       int *__restrict __pref)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_rwlockattr_setkind_np (pthread_rwlockattr_t *__attr,
       int __pref) throw () __attribute__ ((__nonnull__ (1)));







extern int pthread_cond_init (pthread_cond_t *__restrict __cond,
         const pthread_condattr_t *__restrict __cond_attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_cond_destroy (pthread_cond_t *__cond)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_cond_signal (pthread_cond_t *__cond)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_cond_broadcast (pthread_cond_t *__cond)
     throw () __attribute__ ((__nonnull__ (1)));






extern int pthread_cond_wait (pthread_cond_t *__restrict __cond,
         pthread_mutex_t *__restrict __mutex)
     __attribute__ ((__nonnull__ (1, 2)));
# 1011 "/usr/include/pthread.h" 3 4
extern int pthread_cond_timedwait (pthread_cond_t *__restrict __cond,
       pthread_mutex_t *__restrict __mutex,
       const struct timespec *__restrict __abstime)
     __attribute__ ((__nonnull__ (1, 2, 3)));




extern int pthread_condattr_init (pthread_condattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_condattr_destroy (pthread_condattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_condattr_getpshared (const pthread_condattr_t *
     __restrict __attr,
     int *__restrict __pshared)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_condattr_setpshared (pthread_condattr_t *__attr,
     int __pshared) throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_condattr_getclock (const pthread_condattr_t *
          __restrict __attr,
          __clockid_t *__restrict __clock_id)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_condattr_setclock (pthread_condattr_t *__attr,
          __clockid_t __clock_id)
     throw () __attribute__ ((__nonnull__ (1)));
# 1055 "/usr/include/pthread.h" 3 4
extern int pthread_spin_init (pthread_spinlock_t *__lock, int __pshared)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_spin_destroy (pthread_spinlock_t *__lock)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_spin_lock (pthread_spinlock_t *__lock)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_spin_trylock (pthread_spinlock_t *__lock)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_spin_unlock (pthread_spinlock_t *__lock)
     throw () __attribute__ ((__nonnull__ (1)));






extern int pthread_barrier_init (pthread_barrier_t *__restrict __barrier,
     const pthread_barrierattr_t *__restrict
     __attr, unsigned int __count)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_barrier_destroy (pthread_barrier_t *__barrier)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_barrier_wait (pthread_barrier_t *__barrier)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_barrierattr_init (pthread_barrierattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_barrierattr_destroy (pthread_barrierattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_barrierattr_getpshared (const pthread_barrierattr_t *
        __restrict __attr,
        int *__restrict __pshared)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_barrierattr_setpshared (pthread_barrierattr_t *__attr,
        int __pshared)
     throw () __attribute__ ((__nonnull__ (1)));
# 1122 "/usr/include/pthread.h" 3 4
extern int pthread_key_create (pthread_key_t *__key,
          void (*__destr_function) (void *))
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_key_delete (pthread_key_t __key) throw ();


extern void *pthread_getspecific (pthread_key_t __key) throw ();


extern int pthread_setspecific (pthread_key_t __key,
    const void *__pointer) throw () ;




extern int pthread_getcpuclockid (pthread_t __thread_id,
      __clockid_t *__clock_id)
     throw () __attribute__ ((__nonnull__ (2)));
# 1156 "/usr/include/pthread.h" 3 4
extern int pthread_atfork (void (*__prepare) (void),
      void (*__parent) (void),
      void (*__child) (void)) throw ();
# 1170 "/usr/include/pthread.h" 3 4
}
# 13 "./Core/Process/Mutex.h" 2




class Mutex
{
public:
 Mutex();
 ~Mutex();

 void Lock();
 void Unlock();

private:
# 35 "./Core/Process/Mutex.h"
        pthread_mutex_t m_Mutex;

};



class MutexHolder
{
public:
 MutexHolder( Mutex & mutex ) : m_Mutex( mutex )
 {
  mutex.Lock();
 }
 ~MutexHolder()
 {
  m_Mutex.Unlock();
 }
private:
 void operator = ( MutexHolder & ) {}

 Mutex & m_Mutex;
};
# 26 "./Core/Mem/MemTracker.h" 2



 class MemPoolBlock;
# 39 "./Core/Mem/MemTracker.h"
 class MemTracker
 {
 public:
  static void Alloc( void * ptr, size_t size, const char * file, int line );
  static void Free( void * ptr );

  static void Reset();
  static void DumpAllocations();

  static inline uint32_t GetCurrentAllocationCount() { return s_AllocationCount; }

  struct Allocation
  {
   void * m_Ptr;
   size_t m_Size;
   Allocation * m_Next;
   const char * m_File;
   uint32_t m_Line;
   uint32_t m_Id;
  };
 private:
  static void Init();

  static Mutex & GetMutex() { return reinterpret_cast< Mutex & >( s_Mutex ); }

  static uint32_t s_Id;
  static bool s_Enabled;
  static bool s_Initialized;
  static uint32_t s_AllocationCount;
  static Allocation * s_LastAllocation;
  static uint64_t s_Mutex[ sizeof( Mutex ) / sizeof( uint64_t ) ];
  static Allocation ** s_AllocationHashTable;
  static MemPoolBlock * s_Allocations;
 };
# 11 "./Core/Mem/Mem.h" 2




inline void * operator new( size_t, void * ptr ) { return ptr; }
inline void * operator new[]( size_t, void * ptr ) { return ptr; }
inline void operator delete( void *, void * ) {}
inline void operator delete[]( void *, void * ) {}
# 42 "./Core/Mem/Mem.h"
void * Alloc( size_t size );
void * Alloc( size_t size, size_t alignment );
void * AllocFileLine( size_t size, const char * file, int line );
void * AllocFileLine( size_t size, size_t alignment, const char * file, int line );
void Free( void * ptr );
# 56 "./Core/Mem/Mem.h"
  inline void * operator new( size_t size, const char * file, int line ) { return AllocFileLine( size, file, line ); }
  inline void * operator new[]( size_t size, const char * file, int line ) { return AllocFileLine( size, file, line ); }
  inline void operator delete( void * ptr, const char *, int ) { return Free( ptr ); }
  inline void operator delete[]( void * ptr, const char *, int ) { return Free( ptr ); }

 inline void * operator new( size_t size ) { return Alloc( size ); }
 inline void * operator new[]( size_t size ) { return Alloc( size ); }
 inline void operator delete( void * ptr ) { Free( ptr ); }
 inline void operator delete[]( void * ptr ) { Free( ptr ); }
# 14 "./Core/Containers/Array.h" 2



template < class T >
class Array
{
public:
 explicit Array();
 explicit Array( const Array< T > & other );
 explicit Array( const T * begin, const T * end );
 explicit Array( size_t initialCapacity, bool resizeable = false );
 ~Array();

 void Destruct();


 typedef T * Iter;
 typedef const T * ConstIter;
 Iter Begin() const { return m_Begin; }
 Iter End() const { return m_End; }
 inline T & operator [] ( size_t index ) { do { if ( !( index < GetSize() ) ) { if ( AssertHandler::Failure( "index < GetSize()", "./Core/Containers/Array.h", 34 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ; return m_Begin[ index ]; }
 inline const T & operator [] ( size_t index ) const { do { if ( !( index < GetSize() ) ) { if ( AssertHandler::Failure( "index < GetSize()", "./Core/Containers/Array.h", 35 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ; return m_Begin[ index ]; }
 inline T & Top() { do { if ( !( m_Begin < m_End ) ) { if ( AssertHandler::Failure( "m_Begin < m_End", "./Core/Containers/Array.h", 36 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ; return m_End[ -1 ]; }
 inline const T & Top() const { do { if ( !( m_Begin < m_End ) ) { if ( AssertHandler::Failure( "m_Begin < m_End", "./Core/Containers/Array.h", 37 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ; return m_End[ -1 ]; }


 void SetCapacity( size_t capacity );
 void SetSize( size_t size );
 void Clear();
 void Swap( Array< T > & other );


 void Sort() { ShellSort( m_Begin, m_End, AscendingCompare() ); }
 void SortDeref() { ShellSort( m_Begin, m_End, AscendingCompareDeref() ); }
 template < class COMPARER >
 void Sort( const COMPARER & comp ) { ShellSort( m_Begin, m_End, comp ); }


 template < class U >
 T * Find( const U & obj ) const;
 template < class U >
 T * FindDeref( const U & obj ) const;


 void Append( const T & item );
 template < class U >
 void Append( const Array< U > & other );
 template < class U >
 void Append( const U * begin, const U * end );
 void Pop();
 void PopFront();
 void Erase( T * const iter );
 inline void EraseIndex( size_t index ) { Erase( m_Begin + index ); }

 Array & operator = ( const Array< T > & other );


 inline bool IsAtCapacity() const { return ( m_End == m_MaxEnd ) && ( m_Resizeable == false ); }
 inline size_t GetCapacity() const { return ( m_MaxEnd - m_Begin ); }
 inline size_t GetSize() const { return ( m_End - m_Begin ); }
 inline bool IsEmpty() const { return ( m_Begin == m_End ); }

private:
 void Grow();
 inline T * Allocate( size_t numElements ) const;
 inline void Deallocate( T * ptr ) const;

 T * m_Begin;
 T * m_End;
 T * m_MaxEnd;
 bool m_Resizeable;
};



template < class T >
Array< T >::Array()
 : m_Begin( (0) )
 , m_End( (0) )
 , m_MaxEnd( (0) )
 , m_Resizeable( true )
{
}



template < class T >
Array< T >::Array( const Array< T > & other )
{
 new (this) Array( other.GetSize(), true );
 *this = other;
}



template < class T >
Array< T >::Array( const T * begin, const T * end )
{
 const size_t size = ( end - begin );
 new (this) Array( size, true );
 Append( begin, end );
}



template < class T >
Array< T >::Array( size_t initialCapacity, bool resizeable )
{
 if ( initialCapacity )
 {

   m_Resizeable = true;

  m_Begin = Allocate( initialCapacity );
  m_End = m_Begin;
  m_MaxEnd = m_Begin + initialCapacity;
 }
 else
 {
  m_Begin = (0);
  m_End = (0);
  m_MaxEnd = (0);
 }
 m_Resizeable = resizeable;
}



template < class T >
Array< T >::~Array()
{
 Destruct();
}



template < class T >
void Array< T >::Destruct()
{
 T * iter = m_Begin;
 while ( iter < m_End )
 {
  iter->~T();
  iter++;
 }
 Deallocate( m_Begin );
 m_Begin = (0);
 m_End = (0);
 m_MaxEnd = (0);
}



template < class T >
void Array< T >::SetCapacity( size_t capacity )
{
 if ( capacity == GetCapacity() )
 {
  return;
 }

 T * newMem = Allocate( capacity );



 size_t itemsToKeep = Math::Min( capacity, GetSize() );
 T * src = m_Begin;
 T * dst = newMem;
 T * keepEnd = m_Begin + itemsToKeep;
 while ( src < m_End )
 {
  if ( src < keepEnd )
  {
   new ( dst ) T( *src );
  }
  src->~T();
  src++;
  dst++;
 }


 Deallocate( m_Begin );


 m_Begin = newMem;
 m_End = newMem + itemsToKeep;
 m_MaxEnd = newMem + capacity;
}



template < class T >
void Array< T >::SetSize( size_t size )
{
 size_t oldSize = GetSize();


 if ( oldSize == size )
 {
  return;
 }


 if ( size < oldSize )
 {

  T * item = m_Begin + size;
  T * end = m_End;
  while ( item < end )
  {
   item->~T();
   item++;
  }
  m_End = m_Begin + size;
  return;
 }




 if ( size > GetCapacity() )
 {
  SetCapacity( size );
 }


 T * item = m_End;
 T * newEnd = m_Begin + size;
 while( item < newEnd )
 {
  new ( item ) T;
  item++;
 }
 m_End = newEnd;
}



template < class T >
void Array< T >::Clear()
{

 T * src = m_Begin;
 while ( src < m_End )
 {
  src->~T();
  src++;
 }


 m_End = m_Begin;
}



template < class T >
void Array< T >::Swap( Array< T > & other )
{
 T * tmpBegin = m_Begin;
 T * tmpEnd = m_End;
 T * tmpMaxEnd = m_MaxEnd;
 bool tmpResizeable = m_Resizeable;
 m_Begin = other.m_Begin;
 m_End = other.m_End;
 m_MaxEnd = other.m_MaxEnd;
 m_Resizeable = other.m_Resizeable;
 other.m_Begin = tmpBegin;
 other.m_End = tmpEnd;
 other.m_MaxEnd = tmpMaxEnd;
 other.m_Resizeable = tmpResizeable;
}



template < class T >
template < class U >
T * Array< T >::Find( const U & obj ) const
{
 T * pos = m_Begin;
 T * end = m_End;
 while ( pos < end )
 {
  if ( *pos == obj )
  {
   return pos;
  }
  pos++;
 }
 return (0);
}



template < class T >
template < class U >
T * Array< T >::FindDeref( const U & obj ) const
{
 T * pos = m_Begin;
 T * end = m_End;
 while ( pos < end )
 {
  if ( *(*pos) == obj )
  {
   return pos;
  }
  pos++;
 }
 return (0);
}



template < class T >
void Array< T >::Append( const T & item )
{
 if ( m_End == m_MaxEnd )
 {
  Grow();
 }
 new ( m_End ) T( item );
 m_End++;
}



template < class T >
template < class U >
void Array< T >::Append( const Array< U > & other )
{
 U* end = other.End();
 for ( U* it = other.Begin(); it != end; ++it )
 {
  Append( *it );
 }
}



template < class T >
template < class U >
void Array< T >::Append( const U * begin, const U * end )
{
 for ( const U* it = begin; it != end; ++it )
 {
  Append( *it );
 }
}



template < class T >
void Array< T >::Pop()
{
 do { if ( !( m_Begin < m_End ) ) { if ( AssertHandler::Failure( "m_Begin < m_End", "./Core/Containers/Array.h", 367 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;

 T * it = --m_End;
 it->~T();
 (void)it;
}



template < class T >
void Array< T >::PopFront()
{
 do { if ( !( m_Begin < m_End ) ) { if ( AssertHandler::Failure( "m_Begin < m_End", "./Core/Containers/Array.h", 379 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;


 T * dst = m_Begin;
 T * src = m_Begin + 1;
 while ( src < m_End )
 {
  *dst = *src;
  dst++;
  src++;
 }


 dst->~T();

 m_End--;
}



template < class T >
void Array< T >::Erase( T * const iter )
{
 do { if ( !( iter < m_End ) ) { if ( AssertHandler::Failure( "iter < m_End", "./Core/Containers/Array.h", 402 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;

 T * dst = iter;
 T * last = ( m_End - 1 );
 while ( dst < last )
 {
  *dst = *(dst + 1);
  dst++;
 }
 dst->~T();
 m_End = last;
}



template < class T >
Array< T > & Array< T >::operator = ( const Array< T > & other )
{
 Clear();


 const size_t otherSize = other.GetSize();
 if ( GetCapacity() < otherSize )
 {
  Deallocate( m_Begin );
  m_Begin = Allocate( otherSize );
  m_MaxEnd = m_Begin + otherSize;
 }

 m_End = m_Begin + otherSize;
 T * dst = m_Begin;
 T * src = other.m_Begin;
 const T * end = m_End;
 while ( dst < end )
 {
  new ( dst ) T( *src );
  dst++;
  src++;
 }

 return *this;
}



template < class T >
void Array< T >::Grow()
{
 do { if ( !( m_Resizeable ) ) { if ( AssertHandler::Failure( "m_Resizeable", "./Core/Containers/Array.h", 450 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;


 size_t currentCapacity = GetCapacity();
 size_t size = GetSize();
 size_t newCapacity = ( currentCapacity + ( currentCapacity >> 1 ) + 1 );
 T * newMem = Allocate( newCapacity );

 T * src = m_Begin;
 T * dst = newMem;
 while ( src < m_End )
 {
  new ( dst ) T( *src );
  src->~T();
  dst++;
  src++;
 }
 Deallocate( m_Begin );
 m_Begin = newMem;
 m_End = ( newMem ) + size;
 m_MaxEnd = ( newMem ) + newCapacity;
}



template < class T >
T * Array< T >::Allocate( size_t numElements ) const
{
 do { if ( !( m_Resizeable == true ) ) { if ( AssertHandler::Failure( "m_Resizeable == true", "./Core/Containers/Array.h", 478 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;
    const size_t align = __alignof( T ) > sizeof( void * ) ? __alignof( T ) : sizeof( void * );
 return static_cast< T * >( ::AllocFileLine( sizeof( T ) * numElements, align, "./Core/Containers/Array.h", 480 ) );
}



template < class T >
void Array< T >::Deallocate( T * ptr ) const
{
 ::Free( ptr );
}
# 6 "./Tools/FBuild/FBuildCore/PrecompiledHeader.h" 2

# 1 "./Core/FileIO/FileIO.h" 1


       






# 1 "./Core/Strings/AString.h" 1


       
# 19 "./Core/Strings/AString.h"
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.9/include/stdarg.h" 1 3 4
# 40 "/usr/lib/gcc/x86_64-linux-gnu/4.9/include/stdarg.h" 3 4
typedef __builtin_va_list __gnuc_va_list;
# 98 "/usr/lib/gcc/x86_64-linux-gnu/4.9/include/stdarg.h" 3 4
typedef __gnuc_va_list va_list;
# 20 "./Core/Strings/AString.h" 2





class AString
{
public:
 explicit AString();
 explicit AString( uint32_t reserve );
 explicit AString( const AString & string );
 explicit AString( const char * string );
 explicit AString( const char * start, const char * end );
 ~AString();

 inline uint32_t GetLength() const { return m_Length; }
 inline uint32_t GetReserved() const { return ( m_ReservedAndFlags & RESERVED_MASK ); }
 inline bool IsEmpty() const { return ( m_Length == 0 ); }


 inline char * Get() { return m_Contents; }
 inline const char * Get() const { return m_Contents; }
 inline char * GetEnd() { return ( m_Contents + m_Length ); }
 inline const char * GetEnd() const { return ( m_Contents + m_Length ); }
 inline char & operator [] ( size_t index ) { do { if ( !( index < m_Length ) ) { if ( AssertHandler::Failure( "index < m_Length", "./Core/Strings/AString.h", 44 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ; return m_Contents[ index ]; }
 inline const char & operator [] ( size_t index ) const { do { if ( !( index < m_Length ) ) { if ( AssertHandler::Failure( "index < m_Length", "./Core/Strings/AString.h", 45 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ; return m_Contents[ index ]; }


 static const AString & GetEmpty() { return s_EmptyAString; }


 inline AString & operator = ( const char * string ) { Assign( string ); return *this; }
 inline AString & operator = ( const AString & string ) { Assign( string ); return *this; }
 void Assign( const char * string );
 void Assign( const char * start, const char * end );
 void Assign( const AString & string );
 void Clear();
 void SetReserved( size_t capacity );


 void SetLength( uint32_t len );


 AString & operator += ( char c );
 AString & operator += ( const char * string );
 AString & operator += ( const AString & string );
 void Append( const char * string, size_t len );


 bool operator == ( const char * other ) const;
 bool operator == ( const AString & other ) const;
 inline bool operator != ( const char * other ) const { return !(*this == other ); }
 inline bool operator != ( const AString & other ) const { return !(*this == other ); }
 int32_t CompareI( const AString & other ) const;
 inline bool operator < ( const AString & other ) const { return ( CompareI( other ) < 0 ); }

 inline bool MemoryMustBeFreed() const { return ( ( m_ReservedAndFlags & MEM_MUST_BE_FREED_FLAG ) == MEM_MUST_BE_FREED_FLAG ); }

 void Format( const char * fmtString, ... );
 void VFormat( const char * fmtString, va_list arg );

 void Tokenize( Array< AString > & tokens, char splitChar = ' ' ) const;


 uint32_t Replace( char from, char to, uint32_t maxReplaces = 0 );
 uint32_t Replace( const char * from, const char * to, uint32_t maxReplaces = 0 );
 void ToLower();


 const char * Find( char c, const char * startPos = (0) ) const;
 char * Find( char c, char * startPos = (0) ) { return const_cast< char *>( ((const AString *)this)->Find( c, startPos ) ); }
 const char * Find( const char * subString ) const;
 char * Find( const char * subString ) { return const_cast< char *>( ((const AString *)this)->Find( subString ) ); }
 const char * FindI( const char * subString ) const;
 const char * FindLast( char c ) const;
 char * FindLast( char c ) { return const_cast< char *>( ((const AString *)this)->FindLast( c ) ); }
 bool EndsWith( char c ) const;
 bool EndsWith( const char * string ) const;
 bool EndsWithI( const char * other ) const;
 bool EndsWithI( const AString & other ) const;
 bool BeginsWith( char c ) const;
 bool BeginsWith( const char * string ) const;
 bool BeginsWith( const AString & string ) const;
 bool BeginsWithI( const char * string ) const;
 bool BeginsWithI( const AString & string ) const;


 static bool Match( const char * pattern, const char * string );
 inline bool Matches( const char * pattern ) const { return Match( pattern, m_Contents ); }
 static bool MatchI( const char * pattern, const char * string );
 inline bool MatchesI( const char * pattern ) const { return MatchI( pattern, m_Contents ); }


 static void Copy( const char * src, char * dst, size_t len );
 static size_t StrLen( const char * string );
 static int32_t StrNCmp( const char * a, const char * b, size_t num );
 static int32_t StrNCmpI( const char * a, const char * b, size_t num );

protected:
 enum { MEM_MUST_BE_FREED_FLAG = 0x00000001 };
 enum { RESERVED_MASK = 0xFFFFFFFE };

 inline void SetReserved( uint32_t reserved, bool mustFreeMemory )
 {
  do { if ( !( ( reserved & MEM_MUST_BE_FREED_FLAG ) == 0 ) ) { if ( AssertHandler::Failure( "( reserved & MEM_MUST_BE_FREED_FLAG ) == 0", "./Core/Strings/AString.h", 124 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;
  m_ReservedAndFlags = ( reserved ^ ( mustFreeMemory ? MEM_MUST_BE_FREED_FLAG : 0 ) );
 }
 inline __attribute__((noinline)) void Grow( uint32_t newLen );
 inline __attribute__((noinline)) void GrowNoCopy( uint32_t newLen );

 char * m_Contents;
 uint32_t m_Length;
 uint32_t m_ReservedAndFlags;

 static const char * const s_EmptyString;
 static const AString s_EmptyAString;
};
# 11 "./Core/FileIO/FileIO.h" 2







class FileIO
{
public:
 static bool FileExists( const char * fileName );
 static bool FileDelete( const char * fileName );
 static bool FileCopy( const char * srcFileName, const char * dstFileName, bool allowOverwrite = true );
 static bool FileMove( const AString & srcFileName, const AString & dstFileName );


 static bool GetFiles( const AString & path,
        const AString & wildCard,
        bool recurse,
        Array< AString > * results );
 struct FileInfo
 {
  AString m_Name;
  uint32_t m_Attributes;
  uint64_t m_LastWriteTime;
  uint64_t m_Size;

  bool IsReadOnly() const;
 };
 static bool GetFilesEx( const AString & path,
       const AString & wildCard,
       bool recurse,
       Array< FileInfo > * results );
 static bool GetFileInfo( const AString & fileName, FileInfo & info );

 static bool GetCurrentDir( AString & output );
 static bool SetCurrentDir( const AString & dir );
 static bool GetTempDir( AString & output );
 static bool DirectoryCreate( const AString & path );
 static bool DirectoryExists( const AString & path );
 static bool EnsurePathExists( const AString & path );

 static bool CreateTempPath( const char * tempPrefix, AString & path );

 static uint64_t GetFileLastWriteTime( const AString & fileName );
 static bool SetFileLastWriteTime( const AString & fileName, uint64_t fileTime );

 static bool SetReadOnly( const char * fileName, bool readOnly );
    static bool GetReadOnly( const char * fileName );
 static inline bool GetReadOnly( const AString & fileName ) { return GetReadOnly( fileName.Get() ); }




        inline __attribute__((always_inline)) static void WorkAroundForWindowsFilePermissionProblem( const AString & ) {}


private:
 static void GetFilesRecurse( AString & path,
         const AString & wildCard,
         Array< AString > * results );
 static void GetFilesNoRecurse( const char * path,
           const char * wildCard,
           Array< AString > * results );
 static void GetFilesRecurseEx( AString & path,
         const AString & wildCard,
         Array< FileInfo > * results );
 static void GetFilesNoRecurseEx( const char * path,
           const char * wildCard,
           Array< FileInfo > * results );
};
# 8 "./Tools/FBuild/FBuildCore/PrecompiledHeader.h" 2
# 1 "./Core/FileIO/FileStream.h" 1


       




# 1 "./Core/FileIO/IOStream.h" 1


       
# 14 "./Core/FileIO/IOStream.h"
class AString;



class IOStream
{
public:
 explicit inline IOStream() {}
 inline virtual ~IOStream() {}


 virtual uint64_t ReadBuffer( void * buffer, uint64_t bytesToRead ) = 0;
 virtual uint64_t WriteBuffer( const void * buffer, uint64_t bytesToWrite ) = 0;
 virtual void Flush() = 0;


 virtual uint64_t Tell() const = 0;
 virtual bool Seek( uint64_t pos ) const = 0;
 virtual uint64_t GetFileSize() const = 0;


 inline uint64_t Read( void * b, size_t s ) { return ReadBuffer( b, s ); }
 inline bool Read( bool & b ) { return ( ReadBuffer( &b, sizeof( b ) ) == sizeof( b ) ); }
 inline bool Read( int8_t & i ) { return ( ReadBuffer( &i, sizeof( i ) ) == sizeof( i ) ); }
 inline bool Read( int16_t & i ) { return ( ReadBuffer( &i, sizeof( i ) ) == sizeof( i ) ); }
 inline bool Read( int32_t & i ) { return ( ReadBuffer( &i, sizeof( i ) ) == sizeof( i ) ); }
 inline bool Read( int64_t & i ) { return ( ReadBuffer( &i, sizeof( i ) ) == sizeof( i ) ); }
 inline bool Read( uint8_t & u ) { return ( ReadBuffer( &u, sizeof( u ) ) == sizeof( u ) ); }
 inline bool Read( uint16_t & u ) { return ( ReadBuffer( &u, sizeof( u ) ) == sizeof( u ) ); }
 inline bool Read( uint32_t & u ) { return ( ReadBuffer( &u, sizeof( u ) ) == sizeof( u ) ); }
 inline bool Read( uint64_t & u ) { return ( ReadBuffer( &u, sizeof( u ) ) == sizeof( u ) ); }
 bool Read( AString & string );
 template< class T > inline bool Read( Array< T > & a );


 inline uint64_t Write( const void * b, size_t s ) { return WriteBuffer( b, s ); }
 inline bool Write( const bool & b ) { return ( WriteBuffer( &b, sizeof( b ) ) == sizeof( b ) ); }
 inline bool Write( const int8_t & i ) { return ( WriteBuffer( &i, sizeof( i ) ) == sizeof( i ) ); }
 inline bool Write( const int16_t & i ) { return ( WriteBuffer( &i, sizeof( i ) ) == sizeof( i ) ); }
 inline bool Write( const int32_t & i ) { return ( WriteBuffer( &i, sizeof( i ) ) == sizeof( i ) ); }
 inline bool Write( const int64_t & i ) { return ( WriteBuffer( &i, sizeof( i ) ) == sizeof( i ) ); }
 inline bool Write( const uint8_t & u ) { return ( WriteBuffer( &u, sizeof( u ) ) == sizeof( u ) ); }
 inline bool Write( const uint16_t & u ) { return ( WriteBuffer( &u, sizeof( u ) ) == sizeof( u ) ); }
 inline bool Write( const uint32_t & u ) { return ( WriteBuffer( &u, sizeof( u ) ) == sizeof( u ) ); }
 inline bool Write( const uint64_t & u ) { return ( WriteBuffer( &u, sizeof( u ) ) == sizeof( u ) ); }
 bool Write( const AString & string );
 template< class T > inline bool Write( const Array< T > & a );


 void AlignRead( size_t alignment );
 void AlignWrite( size_t alignment );
};



template< class T >
bool IOStream::Read( Array< T > & a )
{
 uint32_t num = 0;
 if ( Read( num ) == false ) { return false; }
 a.SetSize( num );
 for ( uint32_t i=0; i<num; ++i )
 {
  if ( Read( a[ i ] ) == false ) { return false; }
 }
 return true;
}



template< class T >
bool IOStream::Write( const Array< T > & a )
{
 uint32_t num = (uint32_t)a.GetSize();
 if ( Write( num ) == false ) { return false; }
 for ( uint32_t i=0; i<num; ++i )
 {
  if ( Write( a[ i ] ) == false ) { return false; }
 }
 return true;
}
# 9 "./Core/FileIO/FileStream.h" 2



class FileStream : public IOStream
{
public:
 explicit FileStream();
 ~FileStream();

 enum FileMode
 {
  READ_ONLY = 0x1,
  WRITE_ONLY = 0x2,
  TEMP = 0x4,
  DELETE_ON_CLOSE = 0x8,
  SHARE_READ = 0x10,
  SHARE_WRITE = 0x20,
  SHARE_DELETE = 0x40,
  NO_RETRY_ON_SHARING_VIOLATION = 0x80,
 };

 bool Open( const char * fileName, uint32_t mode = FileStream::READ_ONLY );
 void Close();

 bool IsOpen() const;


 virtual uint64_t ReadBuffer( void * buffer, uint64_t bytesToRead );
 virtual uint64_t WriteBuffer( const void * buffer, uint64_t bytesToWrite );
 virtual void Flush();


 virtual uint64_t Tell() const;
 virtual bool Seek( uint64_t pos ) const;
 virtual uint64_t GetFileSize() const;


 bool SetLastWriteTime( uint64_t lastWriteTime );


 inline void * GetHandle() const { return m_Handle; }

private:
 void * m_Handle;
};
# 9 "./Tools/FBuild/FBuildCore/PrecompiledHeader.h" 2
# 1 "./Core/Strings/AStackString.h" 1


       
# 13 "./Core/Strings/AStackString.h"
template <int RESERVED = 256 >
class AStackString : public AString
{
public:
 explicit AStackString();
 explicit AStackString( const AString & string );
 explicit AStackString( const AStackString & string );
 explicit AStackString( const char * string );
 explicit AStackString( const char * start, const char * end );
 inline ~AStackString() {}

 AStackString< RESERVED > & operator = ( const char * string ) { Assign( string ); return *this; }
 AStackString< RESERVED > & operator = ( const AString & string ) { Assign( string ); return *this; }

private:
 char m_Storage[ RESERVED + 1 ];
};



template < int RESERVED >
AStackString< RESERVED >::AStackString()
{
 do { compile_time_assert_failure< ( ( RESERVED % 2 ) == 0 ) > (); } while ( false ); ;
 m_Contents = m_Storage;
 SetReserved( RESERVED, false );
 m_Storage[ 0 ] = '\0';
}



template < int RESERVED >
AStackString< RESERVED >::AStackString( const AString & string )
{
 do { compile_time_assert_failure< ( ( RESERVED % 2 ) == 0 ) > (); } while ( false ); ;
 m_Contents = m_Storage;
 SetReserved( RESERVED, false );
 Assign( string );
}



template < int RESERVED >
AStackString< RESERVED >::AStackString( const AStackString & string )
{
 do { compile_time_assert_failure< ( ( RESERVED % 2 ) == 0 ) > (); } while ( false ); ;
 m_Contents = m_Storage;
 SetReserved( RESERVED, false );
 Assign( string );
}



template < int RESERVED >
AStackString< RESERVED >::AStackString( const char * string )
{
 do { compile_time_assert_failure< ( ( RESERVED % 2 ) == 0 ) > (); } while ( false ); ;
 m_Contents = m_Storage;
 SetReserved( RESERVED, false );
 Assign( string );
}



template < int RESERVED >
AStackString< RESERVED >::AStackString( const char * start, const char * end )
{
 do { compile_time_assert_failure< ( ( RESERVED % 2 ) == 0 ) > (); } while ( false ); ;
 m_Contents = m_Storage;
 SetReserved( RESERVED, false );
 Assign( start, end );
}
# 10 "./Tools/FBuild/FBuildCore/PrecompiledHeader.h" 2


# 1 "/usr/include/memory.h" 1 3 4
# 29 "/usr/include/memory.h" 3 4
# 1 "/usr/include/string.h" 1 3 4
# 27 "/usr/include/string.h" 3 4
extern "C" {




# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.9/include/stddef.h" 1 3 4
# 33 "/usr/include/string.h" 2 3 4
# 44 "/usr/include/string.h" 3 4


extern void *memcpy (void *__restrict __dest, const void *__restrict __src,
       size_t __n) throw () __attribute__ ((__nonnull__ (1, 2)));


extern void *memmove (void *__dest, const void *__src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));






extern void *memccpy (void *__restrict __dest, const void *__restrict __src,
        int __c, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));





extern void *memset (void *__s, int __c, size_t __n) throw () __attribute__ ((__nonnull__ (1)));


extern int memcmp (const void *__s1, const void *__s2, size_t __n)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));



extern "C++"
{
extern void *memchr (void *__s, int __c, size_t __n)
      throw () __asm ("memchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern const void *memchr (const void *__s, int __c, size_t __n)
      throw () __asm ("memchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 94 "/usr/include/string.h" 3 4
}










extern "C++" void *rawmemchr (void *__s, int __c)
     throw () __asm ("rawmemchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern "C++" const void *rawmemchr (const void *__s, int __c)
     throw () __asm ("rawmemchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));







extern "C++" void *memrchr (void *__s, int __c, size_t __n)
      throw () __asm ("memrchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern "C++" const void *memrchr (const void *__s, int __c, size_t __n)
      throw () __asm ("memrchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));









extern char *strcpy (char *__restrict __dest, const char *__restrict __src)
     throw () __attribute__ ((__nonnull__ (1, 2)));

extern char *strncpy (char *__restrict __dest,
        const char *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern char *strcat (char *__restrict __dest, const char *__restrict __src)
     throw () __attribute__ ((__nonnull__ (1, 2)));

extern char *strncat (char *__restrict __dest, const char *__restrict __src,
        size_t __n) throw () __attribute__ ((__nonnull__ (1, 2)));


extern int strcmp (const char *__s1, const char *__s2)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern int strncmp (const char *__s1, const char *__s2, size_t __n)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strcoll (const char *__s1, const char *__s2)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern size_t strxfrm (char *__restrict __dest,
         const char *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (2)));

# 166 "/usr/include/string.h" 3 4
extern int strcoll_l (const char *__s1, const char *__s2, __locale_t __l)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 3)));

extern size_t strxfrm_l (char *__dest, const char *__src, size_t __n,
    __locale_t __l) throw () __attribute__ ((__nonnull__ (2, 4)));





extern char *strdup (const char *__s)
     throw () __attribute__ ((__malloc__)) __attribute__ ((__nonnull__ (1)));






extern char *strndup (const char *__string, size_t __n)
     throw () __attribute__ ((__malloc__)) __attribute__ ((__nonnull__ (1)));
# 211 "/usr/include/string.h" 3 4



extern "C++"
{
extern char *strchr (char *__s, int __c)
     throw () __asm ("strchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern const char *strchr (const char *__s, int __c)
     throw () __asm ("strchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 234 "/usr/include/string.h" 3 4
}






extern "C++"
{
extern char *strrchr (char *__s, int __c)
     throw () __asm ("strrchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern const char *strrchr (const char *__s, int __c)
     throw () __asm ("strrchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 261 "/usr/include/string.h" 3 4
}










extern "C++" char *strchrnul (char *__s, int __c)
     throw () __asm ("strchrnul") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern "C++" const char *strchrnul (const char *__s, int __c)
     throw () __asm ("strchrnul") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));









extern size_t strcspn (const char *__s, const char *__reject)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern size_t strspn (const char *__s, const char *__accept)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern "C++"
{
extern char *strpbrk (char *__s, const char *__accept)
     throw () __asm ("strpbrk") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
extern const char *strpbrk (const char *__s, const char *__accept)
     throw () __asm ("strpbrk") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 313 "/usr/include/string.h" 3 4
}






extern "C++"
{
extern char *strstr (char *__haystack, const char *__needle)
     throw () __asm ("strstr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
extern const char *strstr (const char *__haystack, const char *__needle)
     throw () __asm ("strstr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 340 "/usr/include/string.h" 3 4
}







extern char *strtok (char *__restrict __s, const char *__restrict __delim)
     throw () __attribute__ ((__nonnull__ (2)));




extern char *__strtok_r (char *__restrict __s,
    const char *__restrict __delim,
    char **__restrict __save_ptr)
     throw () __attribute__ ((__nonnull__ (2, 3)));

extern char *strtok_r (char *__restrict __s, const char *__restrict __delim,
         char **__restrict __save_ptr)
     throw () __attribute__ ((__nonnull__ (2, 3)));





extern "C++" char *strcasestr (char *__haystack, const char *__needle)
     throw () __asm ("strcasestr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
extern "C++" const char *strcasestr (const char *__haystack,
         const char *__needle)
     throw () __asm ("strcasestr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 382 "/usr/include/string.h" 3 4
extern void *memmem (const void *__haystack, size_t __haystacklen,
       const void *__needle, size_t __needlelen)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 3)));



extern void *__mempcpy (void *__restrict __dest,
   const void *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern void *mempcpy (void *__restrict __dest,
        const void *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));





extern size_t strlen (const char *__s)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));





extern size_t strnlen (const char *__string, size_t __maxlen)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));





extern char *strerror (int __errnum) throw ();

# 438 "/usr/include/string.h" 3 4
extern char *strerror_r (int __errnum, char *__buf, size_t __buflen)
     throw () __attribute__ ((__nonnull__ (2))) ;





extern char *strerror_l (int __errnum, __locale_t __l) throw ();





extern void __bzero (void *__s, size_t __n) throw () __attribute__ ((__nonnull__ (1)));



extern void bcopy (const void *__src, void *__dest, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern void bzero (void *__s, size_t __n) throw () __attribute__ ((__nonnull__ (1)));


extern int bcmp (const void *__s1, const void *__s2, size_t __n)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));



extern "C++"
{
extern char *index (char *__s, int __c)
     throw () __asm ("index") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern const char *index (const char *__s, int __c)
     throw () __asm ("index") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 487 "/usr/include/string.h" 3 4
}







extern "C++"
{
extern char *rindex (char *__s, int __c)
     throw () __asm ("rindex") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern const char *rindex (const char *__s, int __c)
     throw () __asm ("rindex") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 515 "/usr/include/string.h" 3 4
}







extern int ffs (int __i) throw () __attribute__ ((__const__));




extern int ffsl (long int __l) throw () __attribute__ ((__const__));
__extension__ extern int ffsll (long long int __ll)
     throw () __attribute__ ((__const__));



extern int strcasecmp (const char *__s1, const char *__s2)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strncasecmp (const char *__s1, const char *__s2, size_t __n)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));





extern int strcasecmp_l (const char *__s1, const char *__s2,
    __locale_t __loc)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 3)));

extern int strncasecmp_l (const char *__s1, const char *__s2,
     size_t __n, __locale_t __loc)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 4)));





extern char *strsep (char **__restrict __stringp,
       const char *__restrict __delim)
     throw () __attribute__ ((__nonnull__ (1, 2)));




extern char *strsignal (int __sig) throw ();


extern char *__stpcpy (char *__restrict __dest, const char *__restrict __src)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern char *stpcpy (char *__restrict __dest, const char *__restrict __src)
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern char *__stpncpy (char *__restrict __dest,
   const char *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern char *stpncpy (char *__restrict __dest,
        const char *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));




extern int strverscmp (const char *__s1, const char *__s2)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern char *strfry (char *__string) throw () __attribute__ ((__nonnull__ (1)));


extern void *memfrob (void *__s, size_t __n) throw () __attribute__ ((__nonnull__ (1)));







extern "C++" char *basename (char *__filename)
     throw () __asm ("basename") __attribute__ ((__nonnull__ (1)));
extern "C++" const char *basename (const char *__filename)
     throw () __asm ("basename") __attribute__ ((__nonnull__ (1)));
# 644 "/usr/include/string.h" 3 4
}
# 30 "/usr/include/memory.h" 2 3 4
# 13 "./Tools/FBuild/FBuildCore/PrecompiledHeader.h" 2
# 7 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Helpers/ResponseFile.cpp" 2

# 1 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Helpers/ResponseFile.h" 1


       





class AString;
# 18 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Helpers/ResponseFile.h"
class ResponseFile
{
public:
 explicit ResponseFile();
 ~ResponseFile();

 bool Create( const AString & contents );
 const AString & GetResponseFilePath() const { return m_ResponseFilePath; }

 void SetEscapeSlashes() { m_EscapeSlashes = true; }
private:
 bool CreateInternal( const AString & contents );

 FileStream m_File;
 AStackString<> m_ResponseFilePath;
 bool m_EscapeSlashes;
};
# 9 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Helpers/ResponseFile.cpp" 2


# 1 "./Tools/FBuild/FBuildCore/WorkerPool/WorkerThread.h" 1


       
# 15 "./Tools/FBuild/FBuildCore/WorkerPool/WorkerThread.h"
class FileStream;



class WorkerThread
{
public:
 WorkerThread( uint32_t threadIndex );
 void Init();
 virtual ~WorkerThread();

 static void InitTmpDir( bool remote = false );

 inline void Stop() { m_ShouldExit = true; }
 inline bool HasExited() const { return m_Exited; }
 void WaitForStop();

 static uint32_t GetThreadIndex();


 static void CreateTempFilePath( const char * fileName,
         AString & tmpFileName );
 static bool CreateTempFile( const AString & tmpFileName,
        FileStream & file );
 static void CreateThreadLocalTmpDir();
protected:

 friend class FBuild;
 static bool Update();


 static uint32_t ThreadWrapperFunc( void * param );
 virtual void Main();


 volatile bool m_ShouldExit;
 volatile bool m_Exited;
 uint32_t m_ThreadIndex;

 static AStackString<> s_TmpRoot;
};
# 12 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Helpers/ResponseFile.cpp" 2
# 1 "./Tools/FBuild/FBuildCore/FLog.h" 1


       
# 54 "./Tools/FBuild/FBuildCore/FLog.h"
class FLog
{
public:
 inline static bool ShowInfo() { return s_ShowInfo; }
 inline static bool ShowErrors() { return s_ShowErrors; }

 static void Info( const char * formatString, ... );
 static void Build( const char * formatString, ... );
 static void Warning( const char * formatString, ... );
 static void Error( const char * formatString, ... );


 static void ErrorDirect( const char * message );

 static void StartBuild();
 static void StopBuild();

 static void OutputProgress( float time, float percentage, uint32_t numJobs, uint32_t numJobsActive, uint32_t numJobsDist, uint32_t numJobsDistActive );

private:
 friend class FBuild;
 static inline void SetShowInfo( bool showInfo ) { s_ShowInfo = showInfo; }
 static inline void SetShowErrors( bool showErrors ) { s_ShowErrors = showErrors; }
 static inline void SetShowProgress( bool showProgress ) { s_ShowProgress = showProgress; }

 static void Output( const char * type, const char * message );

 static bool TracingOutputCallback( const char * message );

 static bool s_ShowInfo;
 static bool s_ShowErrors;
 static bool s_ShowProgress;

 static AStackString< 64 > m_ProgressText;
};
# 13 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Helpers/ResponseFile.cpp" 2



# 1 "./Core/FileIO/PathUtils.h" 1


       





class AString;
# 32 "./Core/FileIO/PathUtils.h"
class PathUtils
{
public:


 static bool IsFolderPath( const AString & path );
 static bool IsFullPath( const AString & path );
 static bool ArePathsEqual( const AString & cleanPathA, const AString & cleanPathB );
 static bool IsWildcardMatch( const char * pattern, const char * path );



 static void EnsureTrailingSlash( AString & path );
 static void FixupFolderPath( AString & path );
 static void FixupFilePath( AString & path );
};
# 17 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Helpers/ResponseFile.cpp" 2



ResponseFile::ResponseFile()
 : m_EscapeSlashes( false )
{
}



ResponseFile::~ResponseFile()
{
 if ( m_ResponseFilePath.IsEmpty() == false )
 {
  FileIO::FileDelete( m_ResponseFilePath.Get() );
 }
}



bool ResponseFile::Create( const AString & contents )
{
 if ( m_EscapeSlashes )
 {
  AStackString< 1024 > fixed;
  if ( contents.GetLength() > 512 )
  {
   fixed.SetReserved( contents.GetLength() * 2 );
  }
  const char * it = contents.Get();
  const char * end = contents.GetEnd();
  char * dst = fixed.Get();
  while ( it != end )
  {
   char c = *it;
   if ( ( c == ( '\\' ) ) || ( c == ( '/' ) ) )
   {
    *dst = ( '\\' ); dst++;
    *dst = ( '\\' ); dst++;
   }
   else
   {
    *dst = c; dst++;
   }
   it++;
  }
  fixed.SetLength( (uint32_t)( dst - fixed.Get() ) );

  return CreateInternal( fixed );
 }

 return CreateInternal( contents );
}



bool ResponseFile::CreateInternal( const AString & contents )
{

 WorkerThread::CreateTempFilePath( "args.rsp", m_ResponseFilePath );


 const uint32_t flags = FileStream::WRITE_ONLY
       | FileStream::TEMP;
 if ( !m_File.Open( m_ResponseFilePath.Get(), flags ) )
 {
  do { FLog::Error( "Failed to create response file '%s'", m_ResponseFilePath.Get() ); } while ( false ); ;
  return false;
 }

 bool ok = ( m_File.Write( contents.Get(), contents.GetLength() ) == contents.GetLength() );
 if ( !ok )
 {
  do { FLog::Error( "Failed to write response file '%s'", m_ResponseFilePath.Get() ); } while ( false ); ;
 }

 m_File.Close();

 return ok;
}
# 5 "/home/ffulin/p4/tmp/Unity/Tools/FBuild/FBuildCore/Unity1.cpp" 2


# 1 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Helpers/CIncludeParser.cpp" 1





# 1 "./Tools/FBuild/FBuildCore/PrecompiledHeader.h" 1
# 7 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Helpers/CIncludeParser.cpp" 2

# 1 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Helpers/CIncludeParser.h" 1



       
# 15 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Helpers/CIncludeParser.h"
class CIncludeParser
{
public:
 explicit CIncludeParser();
 ~CIncludeParser();

 bool ParseMSCL_Output( const char * compilerOutput, size_t compilerOutputSize );
 bool ParseMSCL_Preprocessed( const char * compilerOutput, size_t compilerOutputSize );
 bool ParseGCC_Preprocessed( const char * compilerOutput, size_t compilerOutputSize );

 const Array< AString > & GetIncludes() const { return m_Includes; }


 void SwapIncludes( Array< AString > & includes );

  inline size_t GetNonUniqueCount() const { return m_NonUniqueCount; }


private:
 void AddInclude( const char * begin, const char * end );


 uint32_t m_LastCRC1;
 Array< uint32_t > m_CRCs1;
 uint32_t m_LastCRC2;
 Array< uint32_t > m_CRCs2;


 Array< AString > m_Includes;

  size_t m_NonUniqueCount;

};
# 9 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Helpers/CIncludeParser.cpp" 2


# 1 "./Tools/FBuild/FBuildCore/Graph/NodeGraph.h" 1


       





# 1 "./Tools/FBuild/FBuildCore/Helpers/VSProjectGenerator.h" 1


       
# 14 "./Tools/FBuild/FBuildCore/Helpers/VSProjectGenerator.h"
class IOStream;



class VSProjectConfig
{
public:
 AString m_Platform;
 AString m_Config;

 AString m_BuildCommand;
 AString m_RebuildCommand;
 AString m_CleanCommand;
 AString m_Output;
 AString m_PreprocessorDefinitions;
 AString m_IncludeSearchPath;
 AString m_ForcedIncludes;
 AString m_AssemblySearchPath;
 AString m_ForcedUsingAssemblies;
 AString m_AdditionalOptions;
 AString m_OutputDirectory;
 AString m_IntermediateDirectory;
 AString m_LayoutDir;
 AString m_LayoutExtensionFilter;
 AString m_Xbox360DebuggerCommand;
 AString m_DebuggerFlavor;
 AString m_AumidOverride;
 AString m_PlatformToolset;
 AString m_DeploymentType;
 AString m_DeploymentFiles;

 AString m_LocalDebuggerCommandArguments;
 AString m_LocalDebuggerWorkingDirectory;
 AString m_LocalDebuggerCommand;
 AString m_LocalDebuggerEnvironment;

 static bool Load( IOStream & stream, Array< VSProjectConfig > & configs );
 static void Save( IOStream & stream, const Array< VSProjectConfig > & configs );
};



class VSProjectFileType
{
public:
 AString m_FileType;
 AString m_Pattern;

 static bool Load( IOStream & stream, Array< VSProjectFileType > & fileTypes );
 static void Save( IOStream & stream, const Array< VSProjectFileType > & fileTypes );
};



class VSProjectGenerator
{
public:
 VSProjectGenerator();
 ~VSProjectGenerator();

 void SetProjectName( const AString & name ) { m_ProjectName = name; }
 void SetBasePaths( const Array< AString > & paths );
 void SetAllowedFileExtensions( Array< AString > & extensions ) { m_AllowedFileExtensions = extensions; }

 void AddFile( const AString & file, bool filterByExtension = true );
 void AddFiles( const Array< AString > & files, bool filterByExtension = true );

 void SetRootNamespace( const AString & s ) { m_RootNamespace = s; }
 void SetProjectGuid( const AString & s ) { m_ProjectGuid = s; }
 void SetDefaultLanguage( const AString & s ) { m_DefaultLanguage = s; }
 void SetApplicationEnvironment( const AString & s ) { m_ApplicationEnvironment = s; }
 void SetReferences( const Array< AString > & a ) { m_References = a; }
 void SetProjectReferences( const Array< AString > & a ) { m_ProjectReferences = a; }

 const AString & GenerateVCXProj( const AString & projectFile,
          const Array< VSProjectConfig > & configs,
          const Array< VSProjectFileType > & fileTypes );
 const AString & GenerateVCXProjFilters( const AString & projectFile );

private:

 void Write( const char * fmtString, ... );


 void WritePGItem( const char * xmlTag, const AString & value );

 void GetFolderPath( const AString & fileName, AString & folder ) const;


 AString m_ProjectName;
 Array< AString > m_BasePaths;
 Array< AString > m_AllowedFileExtensions;


 AString m_RootNamespace;
 AString m_ProjectGuid;
 AString m_DefaultLanguage;
 AString m_ApplicationEnvironment;
 Array< AString > m_References;
 Array< AString > m_ProjectReferences;


 Array< AString > m_Files;


 AString m_Tmp;


 AString m_OutputVCXProj;
 AString m_OutputVCXProjFilters;
};
# 10 "./Tools/FBuild/FBuildCore/Graph/NodeGraph.h" 2



# 1 "./Core/Time/Timer.h" 1


       
# 13 "./Core/Time/Timer.h"
class Timer
{
public:
 Timer() { Start(); }
 inline ~Timer() {}

 inline void Start() { m_StartTime = GetNow(); }
 inline void Start( float time ) { m_StartTime = GetNow() - (int64_t)( (double)GetFrequency() * (double)time ); }

 float GetElapsed() const
 {
  int64_t now = GetNow();
  return ( (float)( now - m_StartTime ) * GetFrequencyInvFloat() );
 }

 float GetElapsedMS() const
 {
  int64_t now = GetNow();
  return ( (float)( now - m_StartTime ) * GetFrequencyInvFloatMS() );
 }

 static int64_t GetNow();
 static inline int64_t GetFrequency() { return s_Frequency; }
 static inline float GetFrequencyInvFloat() { return s_FrequencyInvFloat; }
 static inline float GetFrequencyInvFloatMS() { return s_FrequencyInvFloatMS; }

private:
 int64_t m_StartTime;


 friend class GlobalTimerFrequencyInitializer;
 static int64_t s_Frequency;
 static float s_FrequencyInvFloat;
 static float s_FrequencyInvFloatMS;
};
# 14 "./Tools/FBuild/FBuildCore/Graph/NodeGraph.h" 2



class AliasNode;
class AString;
class CompilerNode;
class CopyDirNode;
class CopyNode;
class CSNode;
class Dependencies;
class DirectoryListNode;
class DLLNode;
class ExeNode;
class ExecNode;
class FileNode;
class IOStream;
class LibraryNode;
class LinkerNode;
class Node;
class ObjectListNode;
class ObjectNode;
class TestNode;
class UnityNode;
class VCXProjectNode;



class NodeGraphHeader
{
public:
 inline explicit NodeGraphHeader()
 {
  m_Identifier[ 0 ] = 'N';
  m_Identifier[ 1 ] = 'G';
  m_Identifier[ 2 ] = 'D';
  m_Version = NODE_GRAPH_CURRENT_VERSION;
 }
 inline ~NodeGraphHeader() {}

 enum { NODE_GRAPH_CURRENT_VERSION = 52 };

 bool IsValid() const
 {
  return ( ( m_Identifier[ 0 ] == 'N' ) &&
     ( m_Identifier[ 1 ] == 'G' ) &&
     ( m_Identifier[ 2 ] == 'D' ) );
 }
 bool IsCompatibleVersion() const { return m_Version == NODE_GRAPH_CURRENT_VERSION; }
private:
 char m_Identifier[ 3 ];
 uint8_t m_Version;
};



class NodeGraph
{
public:
 explicit NodeGraph();
 ~NodeGraph();

 bool Initialize( const char * bffFile, const char * nodeGraphDBFile );

 bool Load( const char * nodeGraphDBFile, bool & needReparsing );
 bool Load( IOStream & stream, bool & needReparsing );
 void Save( IOStream & stream ) const;


 Node * FindNode( const AString & nodeName ) const;
 Node * GetNodeByIndex( uint32_t index ) const;


 CopyNode * CreateCopyNode( const AString & dstFileName,
          Node * sourceFile,
          const Dependencies & preBuildDependencies );
 CopyDirNode * CreateCopyDirNode( const AString & nodeName,
          Dependencies & staticDeps,
          const AString & destPath,
          const Dependencies & preBuildDependencies );
 ExecNode * CreateExecNode( const AString & dstFileName,
          FileNode * sourceFile,
          FileNode * executable,
          const AString & arguments,
          const AString & workingDir,
          int32_t expectedReturnCode,
          const Dependencies & preBuildDependencies );
 FileNode * CreateFileNode( const AString & fileName, bool cleanPath = true );
 DirectoryListNode * CreateDirectoryListNode( const AString & name,
             const AString & path,
             const AString & wildCard,
             bool recursive,
             const Array< AString > & excludePaths );
 LibraryNode * CreateLibraryNode( const AString & libraryName,
            const Dependencies & inputNodes,
            CompilerNode * compilerNode,
            const AString & compilerArgs,
            const AString & compilerArgsDeoptimized,
            const AString & compilerOutputPath,
            const AString & linker,
            const AString & linkerArgs,
            uint32_t flags,
            ObjectNode * precompiledHeader,
            const Dependencies & compilerForceUsing,
            const Dependencies & preBuildDependencies,
            const Dependencies & additionalInputs,
            bool deoptimizeWritableFiles,
            bool deoptimizeWritableFilesWithToken );
 ObjectNode * CreateObjectNode( const AString & objectName,
           Node * inputNode,
           Node * compilerNode,
           const AString & compilerArgs,
           const AString & compilerArgsDeoptimized,
           Node * precompiledHeader,
           uint32_t flags,
           const Dependencies & compilerForceUsing,
           bool deoptimizeWritableFiles,
           bool deoptimizeWritableFilesWithToken );
 AliasNode * CreateAliasNode( const AString & aliasName,
          const Dependencies & targets );
 DLLNode * CreateDLLNode( const AString & linkerOutputName,
           const Dependencies & inputLibraries,
           const Dependencies & otherLibraries,
           const AString & linker,
           const AString & linkerArgs,
           uint32_t flags,
           const Dependencies & assemblyResources,
           const AString & importLibName,
           Node * linkerStampExe,
           const AString & linkerStampExeArgs );
 ExeNode * CreateExeNode( const AString & linkerOutputName,
           const Dependencies & inputLibraries,
           const Dependencies & otherLibraries,
           const AString & linker,
           const AString & linkerArgs,
           uint32_t flags,
           const Dependencies & assemblyResources,
           Node * linkerStampExe,
           const AString & linkerStampExeArgs );
 UnityNode * CreateUnityNode( const AString & unityName,
         const Dependencies & dirNodes,
         const Array< AString > & files,
         const AString & outputPath,
         const AString & outputPattern,
         uint32_t numUnityFilesToCreate,
         const AString & precompiledHeader,
         const Array< AString > & pathsToExclude,
         const Array< AString > & filesToExclude,
         bool isolateWritableFiles,
         uint32_t maxIsolatedFiles,
         const Array< AString > & excludePatterns );
 CSNode * CreateCSNode( const AString & compilerOutput,
         const Dependencies & inputNodes,
         const AString & compiler,
         const AString & compilerOptions,
         const Dependencies & extraRefs );
 TestNode * CreateTestNode( const AString & testOutput,
          FileNode * testExecutable,
          const AString & arguments,
          const AString & workingDir );
 CompilerNode * CreateCompilerNode( const AString & executable,
            const Dependencies & extraFiles,
            bool allowDistribution );
 VCXProjectNode * CreateVCXProjectNode( const AString & projectOutput,
             const Array< AString > & projectBasePaths,
             const Dependencies & paths,
             const Array< AString > & pathsToExclude,
             const Array< AString > & allowedFileExtensions,
             const Array< AString > & files,
             const Array< AString > & filesToExclude,
             const AString & rootNamespace,
             const AString & projectGuid,
             const AString & defaultLanguage,
             const AString & applicationEnvironment,
             const Array< VSProjectConfig > & configs,
             const Array< VSProjectFileType > & fileTypes,
             const Array< AString > & references,
             const Array< AString > & projectReferences );
 ObjectListNode * CreateObjectListNode( const AString & listName,
        const Dependencies & inputNodes,
        CompilerNode * compiler,
        const AString & compilerArgs,
        const AString & compilerArgsDeoptimized,
        const AString & compilerOutputPath,
        ObjectNode * precompiledHeader,
        const Dependencies & compilerForceUsing,
        const Dependencies & preBuildDependencies,
        bool deoptimizeWritableFiles,
        bool deoptimizeWritableFilesWithToken );

 void DoBuildPass( Node * nodeToBuild );

 static void CleanPath( const AString & name, AString & fullPath );


 void AddUsedFile( const AString & fileName, uint64_t timeStamp );
 bool IsOneUseFile( const AString & fileName ) const;
 void SetCurrentFileAsOneUse();

 static void UpdateBuildStatus( const Node * node,
           uint32_t & nodesBuiltTime,
           uint32_t & totalNodeTime );
private:
 friend class FBuild;

 void AddNode( Node * node );

 static void BuildRecurse( Node * nodeToBuild );
 static bool CheckDependencies( Node * nodeToBuild, const Dependencies & dependencies );
 static void UpdateBuildStatusRecurse( const Node * node,
            uint32_t & nodesBuiltTime,
            uint32_t & totalNodeTime );
 static void UpdateBuildStatusRecurse( const Dependencies & dependencies,
            uint32_t & nodesBuiltTime,
            uint32_t & totalNodeTime );

 Node * FindNodeInternal( const AString & fullPath ) const;

 struct UsedFile;
 bool ReadHeaderAndUsedFiles( IOStream & nodeGraphStream, Array< UsedFile > & files, bool & compatibleDB ) const;
 uint32_t GetLibEnvVarHash() const;


 static void SaveRecurse( IOStream & stream, Node * node, Array< bool > & savedNodeFlags );
 static void SaveRecurse( IOStream & stream, const Dependencies & dependencies, Array< bool > & savedNodeFlags );
 bool LoadNode( IOStream & stream );

 enum { NODEMAP_TABLE_SIZE = 65536 };
 Node * m_NodeMap[ NODEMAP_TABLE_SIZE ];
 Array< Node * > m_AllNodes;
 uint32_t m_NextNodeIndex;

 Timer m_Timer;


 struct UsedFile
 {
  explicit UsedFile( const AString & fileName, uint64_t timeStamp ) : m_FileName( fileName ), m_TimeStamp( timeStamp ), m_Once( false ) {}
  AString m_FileName;
  uint64_t m_TimeStamp;
  bool m_Once;
 };
 Array< UsedFile > m_UsedFiles;

 static uint32_t s_BuildPassTag;
};
# 12 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Helpers/CIncludeParser.cpp" 2



# 1 "./Core/Math/Murmur3.h" 1


       






# 1 "./Core/Math/MurmurHash3/MurmurHash3.h" 1
# 13 "./Core/Math/MurmurHash3/MurmurHash3.h"
void MurmurHash3_x86_32 ( const void * key, int len, uint32_t seed, void * out );

void MurmurHash3_x86_128 ( const void * key, int len, uint32_t seed, void * out );

void MurmurHash3_x64_128 ( const void * key, int len, uint32_t seed, void * out );
# 11 "./Core/Math/Murmur3.h" 2




class Murmur3
{
public:
 inline static uint32_t Calc32( const void * buffer, size_t len );
 inline static uint64_t Calc64( const void * buffer, size_t len );
 inline static uint64_t Calc128( const void * buffer, size_t len, uint64_t & other );

 inline static uint32_t Calc32( const AString & string ) { return Calc32( string.Get(), string.GetLength() ); }
 inline static uint64_t Calc64( const AString & string ) { return Calc64( string.Get(), string.GetLength() ); }
 inline static uint64_t Calc128( const AString & string, uint64_t & other ) { return Calc128( string.Get(), string.GetLength(), other ); }
private:
 enum { MURMUR3_SEED = 0x65cc95f0 };
};



           uint32_t Murmur3::Calc32( const void * buffer, size_t len )
{
 uint32_t hash;
 MurmurHash3_x86_32( buffer, (int)len, 0, &hash );
 return hash;
}



           uint64_t Murmur3::Calc64( const void * buffer, size_t len )
{
 uint64_t a1, a2;
 a1 = Murmur3::Calc128( buffer, len, a2 );
 return ( a1 ^ a2 );
}



           uint64_t Murmur3::Calc128( const void * buffer, size_t len, uint64_t & other )
{
 uint64_t hash[ 2 ];


 MurmurHash3_x64_128( buffer, (int)len, MURMUR3_SEED, &hash );
 other = hash[ 0 ];
 return hash[ 1 ];
}
# 16 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Helpers/CIncludeParser.cpp" 2

# 1 "./Core/Tracing/Tracing.h" 1


       
# 25 "./Core/Tracing/Tracing.h"
class Tracing
{
public:
 static inline void DoNothing() {}


  static void DebugSpam( const char * message );
  static void DebugSpamFormat( const char * fmtString, ... );
  static void Warning( const char * file, uint32_t line, const char * message );
  static void WarningFormat( const char * file, uint32_t line, const char * fmtString, ... );

 static void Output( const char * message );
 static void OutputFormat( const char * fmtString, ... );
 static void FatalError( const char * message );
 static void FatalErrorFormat( const char * fmtString, ... );

 typedef bool Callback( const char * mesage );
 static void SetCallbackDebugSpam( Callback callback );
 static void SetCallbackOutput( Callback callback );

private:
 static Callback * m_CallbackDebugSpam;
 static Callback * m_CallbackOutput;
};
# 18 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Helpers/CIncludeParser.cpp" 2




CIncludeParser::CIncludeParser()
 : m_LastCRC1( 0 )
 , m_CRCs1( 4096, true )
 , m_LastCRC2( 0 )
 , m_CRCs2( 4096, true )
 , m_Includes( 4096, true )

 , m_NonUniqueCount( 0 )

{
}



CIncludeParser::~CIncludeParser()
{
}



bool CIncludeParser::ParseMSCL_Output( const char * compilerOutput,
            size_t compilerOutputSize )
{

 do { if ( !( compilerOutput[ compilerOutputSize ] == 0 ) ) { if ( AssertHandler::Failure( "compilerOutput[ compilerOutputSize ] == 0", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Helpers/CIncludeParser.cpp", 46 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;
 (void)compilerOutputSize;

 const char * pos = compilerOutput;

 for (;;)
 {

  const char * token = strstr( pos, "\nNote: including file: " );
  if ( !token )
  {
   break;
  }
  pos = token + 23;


  while ( *pos == ' ' )
  {
   ++pos;
  }

  const char * lineStart = pos;


  pos = strchr( pos, '\r' );
  if ( !pos )
  {
   return false;
  }

  const char * lineEnd = pos;

  AddInclude( lineStart, lineEnd );
 }

 return true;
}



bool CIncludeParser::ParseMSCL_Preprocessed( const char * compilerOutput,
            size_t compilerOutputSize )
{

 do { if ( !( compilerOutput[ compilerOutputSize ] == 0 ) ) { if ( AssertHandler::Failure( "compilerOutput[ compilerOutputSize ] == 0", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Helpers/CIncludeParser.cpp", 90 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;
 (void)compilerOutputSize;

 const char * pos = compilerOutput;



 if ( strncmp( pos, "#line ", 6 ) == 0 )
 {
  pos += 6;
  goto foundInclude;
 }

 for (;;)
 {
  pos = strstr( pos, "\n#line " );
  if ( !pos )
  {
   break;
  }
  pos += 7;

 foundInclude:


  pos = strchr( pos, '"' );
  if ( !pos )
  {
   return false;
  }
  pos++;

  const char * lineStart = pos;


  pos = strchr( pos, '"' );
  if ( !pos )
  {
   return false;
  }

  const char * lineEnd = pos;

  AddInclude( lineStart, lineEnd );
 }

 return true;
}



bool CIncludeParser::ParseGCC_Preprocessed( const char * compilerOutput,
           size_t compilerOutputSize )
{

 do { if ( !( compilerOutput[ compilerOutputSize ] == 0 ) ) { if ( AssertHandler::Failure( "compilerOutput[ compilerOutputSize ] == 0", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Helpers/CIncludeParser.cpp", 145 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;
 (void)compilerOutputSize;

 const char * pos = compilerOutput;



 if ( strncmp( pos, "# ", 2 ) == 0 )
 {
  pos += 2;
  goto foundInclude;
 }

 for (;;)
 {
  pos = strstr( pos, "\n# " );
  if ( !pos )
  {
   break;
  }
  pos += 3;

 foundInclude:


  for ( ;; )
  {
   char c = * pos;
   if ( ( c >= '0' ) && ( c <= '9' ) )
   {
    pos++;
    continue;
   }
   break;
  }


  if ( *pos != ' ' )
  {
   continue;
  }
  pos++;


  if ( *pos != '"' )
  {
   continue;
  }
  pos++;


  if ( *pos == '<' )
  {
   continue;
  }

  const char * lineStart = pos;


  pos = strchr( pos, '"' );
  if ( !pos )
  {
   return false;
  }

  const char * lineEnd = pos;


  const char lastChar( lineEnd[ -1 ] );
  if ( ( lastChar == ( '/' ) ) || ( lastChar == ( '\\' ) ) )
  {
   continue;
  }

  AddInclude( lineStart, lineEnd );
 }

 return true;
}



void CIncludeParser::SwapIncludes( Array< AString > & includes )
{
 m_Includes.Swap( includes );
}



void CIncludeParser::AddInclude( const char * begin, const char * end )
{

  m_NonUniqueCount++;



 uint32_t crc1 = Murmur3::Calc32( begin, end - begin );
 if ( crc1 == m_LastCRC1 )
 {
  return;
 }
 m_LastCRC1 = crc1;
 if ( m_CRCs1.Find( crc1 ) )
 {
  return;
 }
 m_CRCs1.Append( crc1 );


 AStackString< 256 > include( begin, end );
 AStackString< 256 > cleanInclude;
 NodeGraph::CleanPath( include, cleanInclude );







  uint32_t crc2 = Murmur3::Calc32( cleanInclude );

 if ( crc2 == m_LastCRC2 )
 {
  return;
 }
 m_LastCRC2 = crc2;
 if ( m_CRCs2.Find( crc2 ) == (0) )
 {
  m_CRCs2.Append( crc2 );
  m_Includes.Append( cleanInclude );
 }
}
# 8 "/home/ffulin/p4/tmp/Unity/Tools/FBuild/FBuildCore/Unity1.cpp" 2


# 1 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Helpers/ToolManifest.cpp" 1





# 1 "./Tools/FBuild/FBuildCore/PrecompiledHeader.h" 1
# 7 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Helpers/ToolManifest.cpp" 2

# 1 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Helpers/ToolManifest.h" 1


       





class Dependencies;
class IOStream;
class Node;
# 22 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Helpers/ToolManifest.h"
class ToolManifest
{
public:
 explicit ToolManifest();
 explicit ToolManifest( uint64_t toolId );
 ~ToolManifest();

 bool Generate( const Node * mainExecutable, const Dependencies & dependencies );

 inline uint64_t GetToolId() const { return m_ToolId; }
 inline uint64_t GetTimeStamp() const { return m_TimeStamp; }

 void Serialize( IOStream & ms ) const;
 void Deserialize( IOStream & ms );

 inline bool IsSynchronized() const { return m_Synchronized; }
 bool GetSynchronizationStatus( uint32_t & syncDone, uint32_t & syncTotal ) const;


 inline bool operator == ( uint64_t toolId ) const
 {
  return ( m_ToolId == toolId );
 }

 inline void SetUserData( void * data ) { m_UserData = data; }
 inline void * GetUserData() const { return m_UserData; }

 struct File
 {
  explicit File( const AString & name, uint64_t stamp, uint32_t hash, const Node * node, uint32_t size );
  ~File();

  enum SyncState
  {
   NOT_SYNCHRONIZED,
   SYNCHRONIZING,
   SYNCHRONIZED,
  };


  AString m_Name;
  uint64_t m_TimeStamp;
  uint32_t m_Hash;
  mutable uint32_t m_ContentSize;


  const Node * m_Node;
  mutable void * m_Content;


  SyncState m_SyncState;
  FileStream * m_FileLock;
 };
 const Array< File > & GetFiles() const { return m_Files; }

 void MarkFileAsSynchronizing( size_t fileId ) { do { if ( !( m_Files[ fileId ].m_SyncState == File::NOT_SYNCHRONIZED ) ) { if ( AssertHandler::Failure( "m_Files[ fileId ].m_SyncState == File::NOT_SYNCHRONIZED", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Helpers/ToolManifest.h", 77 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ; m_Files[ fileId ].m_SyncState = File::SYNCHRONIZING; }
 void CancelSynchronizingFiles();

 const void * GetFileData( uint32_t fileId, size_t & dataSize ) const;
 bool ReceiveFileData( uint32_t fileId, const void * data, size_t & dataSize );

 void GetRemotePath( AString & path ) const;
 void GetRemoteFilePath( uint32_t fileId, AString & exe, bool fullPath = true ) const;
 const char * GetRemoteEnvironmentString() const { return m_RemoteEnvironmentString; }
private:
 bool AddFile( const Node * node );
 bool LoadFile( const AString & fileName, void * & content, uint32_t & contentSize ) const;

 uint64_t m_ToolId;
 uint64_t m_TimeStamp;
 mutable Mutex m_Mutex;
 Array< File > m_Files;
 bool m_Synchronized;
 const char * m_RemoteEnvironmentString;
 void * m_UserData;
};
# 9 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Helpers/ToolManifest.cpp" 2


# 1 "./Core/Containers/AutoPtr.h" 1


       
# 13 "./Core/Containers/AutoPtr.h"
class DefaultDeletor
{
public:
 static inline void Delete( void * ptr ) { ::Free( ptr ); }
};



template < class T, class DELETOR = DefaultDeletor >
class AutoPtr
{
public:
 explicit inline AutoPtr() : m_Pointer( (0) ) {}
 explicit inline AutoPtr( T * ptr ) : m_Pointer( ptr ) {}
 inline ~AutoPtr() { DELETOR::Delete( m_Pointer ); }


 inline T * Get() { return m_Pointer; }
 inline const T * Get() const { return m_Pointer; }


 inline void operator = ( T * newPtr ) { DELETOR::Delete( m_Pointer ); m_Pointer = newPtr; }


 inline void Destroy() { DELETOR::Delete( m_Pointer ); m_Pointer = (0); }


 inline T * Release() { T * ptr = m_Pointer; m_Pointer = (0); return ptr; }
private:
 T * m_Pointer;
};
# 12 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Helpers/ToolManifest.cpp" 2
# 1 "./Core/Env/Env.h" 1


       
# 14 "./Core/Env/Env.h"
class AString;



class Env
{
public:
 enum Platform
 {
  WINDOWS,
  IOS,
  OSX,
  LINUX
 };

 static inline Platform GetPlatform();
 static inline const char * GetPlatformName( Platform platform );
 static inline const char * GetPlatformName() { return GetPlatformName( GetPlatform() ); }

 static uint32_t GetNumProcessors();

 static bool GetEnvVariable( const char * envVarName, AString & envVarValue );
 static const char * GetCmdLine();
 static void GetExePath( AString & path );

 static uint32_t GetLastErr();
};



           inline Env::Platform Env::GetPlatform()
{







  return Env::LINUX;

}



           inline const char * Env::GetPlatformName( Platform platform )
{
 switch ( platform )
 {
  case Env::WINDOWS: return "Windows";
  case Env::IOS: return "IOS";
  case Env::OSX: return "OSX";
  case Env::LINUX: return "Linux";
 }
 do { if ( !( false ) ) { if ( AssertHandler::Failure( "false", "./Core/Env/Env.h", 68 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;
 return "Unknown";
}
# 13 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Helpers/ToolManifest.cpp" 2
# 1 "./Core/FileIO/ConstMemoryStream.h" 1


       
# 13 "./Core/FileIO/ConstMemoryStream.h"
class ConstMemoryStream : public IOStream
{
public:
 explicit ConstMemoryStream( const void * data, size_t size );
 ~ConstMemoryStream();


 inline const void * GetData() const { return m_Buffer; }
 inline size_t GetSize() const { return m_Size; }
 void Replace( const void * data, size_t size );


 virtual uint64_t ReadBuffer( void * buffer, uint64_t bytesToRead );
 virtual uint64_t WriteBuffer( const void * buffer, uint64_t bytesToWrite );
 virtual void Flush();


 virtual uint64_t Tell() const;
 virtual bool Seek( uint64_t pos ) const;
 virtual uint64_t GetFileSize() const;

private:
 const void * m_Buffer;
 size_t m_Size;
 mutable size_t m_CurrentPos;
};
# 14 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Helpers/ToolManifest.cpp" 2


# 1 "./Core/FileIO/MemoryStream.h" 1


       
# 13 "./Core/FileIO/MemoryStream.h"
class MemoryStream : public IOStream
{
public:
 explicit MemoryStream();
 explicit MemoryStream( size_t initialBufferSize, size_t minGrowth = 4096 );
 ~MemoryStream();


 inline const void * GetData() const { return (void *)m_Begin; }
 inline size_t GetSize() const { return ( m_End - m_Begin ); }


 virtual uint64_t ReadBuffer( void * buffer, uint64_t bytesToRead );
 virtual uint64_t WriteBuffer( const void * buffer, uint64_t bytesToWrite );
 virtual void Flush();


 virtual uint64_t Tell() const;
 virtual bool Seek( uint64_t pos ) const;
 virtual uint64_t GetFileSize() const;

private:
 inline __attribute__((noinline)) void GrowToAccomodate( uint64_t bytesToAccomodate );

 char * m_Begin;
 char * m_End;
 char * m_MaxEnd;
 size_t m_MinGrowth;
};
# 17 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Helpers/ToolManifest.cpp" 2



# 1 "./Tools/FBuild/FBuildCore/Graph/FileNode.h" 1


       





# 1 "./Tools/FBuild/FBuildCore/Graph/Node.h" 1


       






# 1 "./Tools/FBuild/FBuildCore/Graph/Dependencies.h" 1


       
# 13 "./Tools/FBuild/FBuildCore/Graph/Dependencies.h"
class IOStream;
class Node;



class Dependency
{
public:
 explicit Dependency( Node * node )
  : m_Node( node )
  , m_IsWeak( false )
 {}
 explicit Dependency( Node * node, bool isWeak )
  : m_Node( node )
  , m_IsWeak( isWeak )
 {}

 inline Node * GetNode() const { return m_Node; }
 inline bool IsWeak() const { return m_IsWeak; }

private:
 Node * m_Node;
 bool m_IsWeak;
};



class Dependencies : public Array< Dependency >
{
public:
 explicit inline Dependencies()
  : Array< Dependency >()
 {}
 explicit inline Dependencies( size_t initialCapacity, bool resizeable = false )
  : Array< Dependency >( initialCapacity, resizeable )
 {}
 explicit inline Dependencies( Dependency * begin, Dependency * end )
  : Array< Dependency >( begin, end )
 {}



 void Save( IOStream & stream ) const;
 bool Load( IOStream & stream );
};
# 11 "./Tools/FBuild/FBuildCore/Graph/Node.h" 2







class IOStream;
class CompilerNode;
class FileNode;
class Job;
# 43 "./Tools/FBuild/FBuildCore/Graph/Node.h"
class Node
{
public:
 enum Type
 {
  PROXY_NODE = 0,
  COPY_NODE = 1,
  DIRECTORY_LIST_NODE = 2,
  EXEC_NODE = 3,
  FILE_NODE = 4,
  LIBRARY_NODE = 5,
  OBJECT_NODE = 6,
  ALIAS_NODE = 7,
  EXE_NODE = 8,
  UNITY_NODE = 9,
  CS_NODE = 10,
  TEST_NODE = 11,
  COMPILER_NODE = 12,
  DLL_NODE = 13,
  VCXPROJECT_NODE = 14,
  OBJECT_LIST_NODE = 15,
  COPY_DIR_NODE = 16,

  NUM_NODE_TYPES
 };

 enum ControlFlag
 {
  FLAG_NONE = 0x00,
  FLAG_TRIVIAL_BUILD = 0x01,
  FLAG_NO_DELETE_ON_FAIL = 0x02,
 };

 enum StatsFlag
 {
  STATS_PROCESSED = 0x01,
  STATS_BUILT = 0x02,
  STATS_CACHE_HIT = 0x04,
  STATS_CACHE_MISS = 0x08,
  STATS_CACHE_STORE = 0x10,
  STATS_BUILT_REMOTE = 0x20,
  STATS_REPORT_PROCESSED = 0x4000,
  STATS_STATS_PROCESSED = 0x8000
 };

 enum BuildResult
 {
  NODE_RESULT_FAILED = 0,
  NODE_RESULT_NEED_SECOND_BUILD_PASS,
  NODE_RESULT_OK,
  NODE_RESULT_OK_CACHE
 };

 enum State
 {
  NOT_PROCESSED,
  PRE_DEPS_READY,
  STATIC_DEPS_READY,
  DYNAMIC_DEPS_DONE,
  BUILDING,
  FAILED,
  UP_TO_DATE,
 };

 enum Priority
 {
  PRIORITY_HIGH,
  PRIORITY_NORMAL,
  NUM_PRIORITY_LEVELS
 };

 explicit Node( const AString & name, Type type, uint32_t controlFlags );
 virtual ~Node();

 inline const AString & GetName() const { return m_Name; }
 inline uint32_t GetNameCRC() const { return m_NameCRC; }
 inline Type GetType() const { return m_Type; }
 inline const char * GetTypeName() const { return s_NodeTypeNames[ m_Type ]; }
 inline static const char * GetTypeName( Type t ) { return s_NodeTypeNames[ t ]; }
 template < class T >
 inline T * CastTo() const;


 virtual bool IsAFile() const = 0;

 inline State GetState() const { return m_State; }

 inline bool GetStatFlag( StatsFlag flag ) const { return ( ( m_StatsFlags & flag ) != 0 ); }
 inline void SetStatFlag( StatsFlag flag ) const { m_StatsFlags |= flag; }

 inline uint32_t GetLastBuildTime() const { return m_LastBuildTimeMs; }
 inline uint32_t GetProcessingTime() const { return m_ProcessingTime; }

 inline uint32_t GetProgressAccumulator() const { return m_ProgressAccumulator; }
 inline void SetProgressAccumulator( uint32_t p ) const { m_ProgressAccumulator = p; }

 virtual Priority GetPriority() const { return PRIORITY_NORMAL; }

 static Node * Load( IOStream & stream );
 static void Save( IOStream & stream, const Node * node );

 static Node * LoadRemote( IOStream & stream );
 static void SaveRemote( IOStream & stream, const Node * node );

 static bool EnsurePathExistsForFile( const AString & name );

 inline uint64_t GetStamp() const { return m_Stamp; }

 inline uint32_t GetIndex() const { return m_Index; }

 static void DumpOutput( Job * job,
       const char * data,
       uint32_t dataSize,
       const Array< AString > * exclusions = (0) );

 inline void SetBuildPassTag( uint32_t pass ) const { m_BuildPassTag = pass; }
 inline uint32_t GetBuildPassTag() const { return m_BuildPassTag; }

protected:
 friend class FBuild;
 friend struct FBuildStats;
 friend class JobQueue;
 friend class JobQueueRemote;
 friend class NodeGraph;
 friend class Report;
 friend class WorkerThread;

 inline const Dependencies & GetPreBuildDependencies() const { return m_PreBuildDependencies; }
 inline const Dependencies & GetStaticDependencies() const { return m_StaticDependencies; }
 inline const Dependencies & GetDynamicDependencies() const { return m_DynamicDependencies; }

 void ReplaceDummyName( const AString & newName );

 virtual void Save( IOStream & stream ) const = 0;
 virtual void SaveRemote( IOStream & stream ) const;

 inline uint32_t GetControlFlags() const { return m_ControlFlags; }

 inline void SetState( State state ) { m_State = state; }

 inline void SetIndex( uint32_t index ) { m_Index = index; }


 virtual bool DoDynamicDependencies( bool forceClean );
 virtual bool DetermineNeedToBuild( bool forceClean ) const;
 virtual BuildResult DoBuild( Job * job );
 virtual BuildResult DoBuild2( Job * job, bool racingRemoteJob );
 virtual bool Finalize();

 inline void SetLastBuildTime( uint32_t ms ) { m_LastBuildTimeMs = ms; }
 inline void AddProcessingTime( uint32_t ms ){ m_ProcessingTime += ms; }

 void SaveNode( IOStream & stream, const Node * node ) const;
 static bool LoadNode( IOStream & stream, Node * & node );
 static bool LoadNode( IOStream & stream, CompilerNode * & compilerNode );
 static bool LoadNode( IOStream & stream, FileNode * & node );

 static void FixupPathForVSIntegration( AString & line );
 static void FixupPathForVSIntegration_GCC( AString & line, const char * tag );
 static void FixupPathForVSIntegration_SNC( AString & line, const char * tag );

 State m_State;
 mutable uint32_t m_BuildPassTag;
 uint32_t m_ControlFlags;
 mutable uint32_t m_StatsFlags;
 uint64_t m_Stamp;
 Type m_Type;
 Node * m_Next;
 uint32_t m_NameCRC;
 uint32_t m_LastBuildTimeMs;
 uint32_t m_ProcessingTime;
 mutable uint32_t m_ProgressAccumulator;
 AString m_Name;
 uint32_t m_Index;

 Dependencies m_PreBuildDependencies;
 Dependencies m_StaticDependencies;
 Dependencies m_DynamicDependencies;

 static const char * const s_NodeTypeNames[];
};


template < class T >
inline T * Node::CastTo() const
{
 do { if ( !( T::GetType() == GetType() ) ) { if ( AssertHandler::Failure( "T::GetType() == GetType()", "./Tools/FBuild/FBuildCore/Graph/Node.h", 229 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;
 return (T *)this;
}


template <>
inline FileNode * Node::CastTo< FileNode >() const
{
 do { if ( !( IsAFile() ) ) { if ( AssertHandler::Failure( "IsAFile()", "./Tools/FBuild/FBuildCore/Graph/Node.h", 237 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;
 return (FileNode *)this;
}
# 10 "./Tools/FBuild/FBuildCore/Graph/FileNode.h" 2



class FileNode : public Node
{
public:
 explicit FileNode( const AString & fileName, uint32_t controlFlags = Node::FLAG_TRIVIAL_BUILD );
 virtual ~FileNode();

 static inline Node::Type GetType() { return Node::FILE_NODE; }

 virtual bool IsAFile() const { return true; }

 static Node * Load( IOStream & stream );
 virtual void Save( IOStream & stream ) const;
protected:
 virtual BuildResult DoBuild( Job * job );

 friend class Client;
};
# 21 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Helpers/ToolManifest.cpp" 2







ToolManifest::File::File( const AString & name, uint64_t stamp, uint32_t hash, const Node * node, uint32_t size )
 : m_Name( name ),
 m_TimeStamp( stamp ),
 m_Hash( hash ),
 m_ContentSize( size ),
 m_Node( node ),
 m_Content( (0) ),
 m_SyncState( NOT_SYNCHRONIZED ),
 m_FileLock( (0) )
{}



ToolManifest::File::~File()
{
 ::Free( m_Content );
 delete( m_FileLock );
}



ToolManifest::ToolManifest()
 : m_ToolId( 0 )
 , m_TimeStamp( 0 )
 , m_Files( 0, true )
 , m_Synchronized( false )
 , m_RemoteEnvironmentString( (0) )
 , m_UserData( (0) )
{
}



ToolManifest::ToolManifest( uint64_t toolId )
 : m_ToolId( toolId )
 , m_TimeStamp( 0 )
 , m_Files( 0, true )
 , m_Synchronized( false )
 , m_RemoteEnvironmentString( (0) )
 , m_UserData( (0) )
{
}



ToolManifest::~ToolManifest()
{
 ::Free( (void *)m_RemoteEnvironmentString );
}



bool ToolManifest::Generate( const Node * mainExecutable, const Dependencies & dependencies )
{
 m_Files.Clear();
 m_TimeStamp = 0;
 m_Files.SetCapacity( 1 + dependencies.GetSize() );



 AddFile( mainExecutable );
 for ( size_t i=0; i<dependencies.GetSize(); ++i )
 {
  const FileNode & n = *( dependencies[ i ].GetNode()->CastTo< FileNode >() );
  if ( !AddFile( &n ) )
  {
   return false;
  }
 }


 const size_t numFiles( m_Files.GetSize() );
 const size_t memSize( numFiles * sizeof( uint32_t ) * 2 );
 uint32_t * mem = (uint32_t *)::AllocFileLine( memSize, "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Helpers/ToolManifest.cpp", 101 );
 uint32_t * pos = mem;
 for ( size_t i=0; i<numFiles; ++i )
 {
  const File & f = m_Files[ i ];


  *pos = f.m_Hash;
  ++pos;


  AStackString<> relativePath;
  GetRemoteFilePath( (uint32_t)i, relativePath, false );
  *pos = Murmur3::Calc32( relativePath );
  ++pos;
 }
 uint64_t hashA, hashB;
 hashA = Murmur3::Calc128( mem, memSize, hashB );
 m_ToolId = hashA ^ hashB;
 ::Free( mem );


 for ( size_t i=0; i<numFiles; ++i )
 {
  const File & f = m_Files[ i ];
  do { if ( !( f.m_TimeStamp ) ) { if ( AssertHandler::Failure( "f.m_TimeStamp", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Helpers/ToolManifest.cpp", 126 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;
  m_TimeStamp = Math::Max( m_TimeStamp, f.m_TimeStamp );
 }

 return true;
}



void ToolManifest::Serialize( IOStream & ms ) const
{
 ms.Write( m_ToolId );

 const uint32_t numItems( (uint32_t)m_Files.GetSize() );
 ms.Write( numItems );
 const size_t numFiles( m_Files.GetSize() );
 for ( size_t i=0; i<numFiles; ++i )
 {
  const File & f = m_Files[ i ];
  ms.Write( f.m_Name );
  ms.Write( f.m_TimeStamp );
  ms.Write( f.m_Hash );
  ms.Write( f.m_ContentSize );
 }
}



void ToolManifest::Deserialize( IOStream & ms )
{
 ms.Read( m_ToolId );

 do { if ( !( m_Files.IsEmpty() ) ) { if ( AssertHandler::Failure( "m_Files.IsEmpty()", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Helpers/ToolManifest.cpp", 158 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;

 uint32_t numFiles( 0 );
 ms.Read( numFiles );
 m_Files.SetCapacity( numFiles );

 for ( size_t i=0; i<(size_t)numFiles; ++i )
 {
  AStackString<> name;
  uint64_t timeStamp( 0 );
  uint32_t hash( 0 );
  uint32_t contentSize( 0 );
  ms.Read( name );
  ms.Read( timeStamp );
  ms.Read( hash );
  ms.Read( contentSize );
  m_Files.Append( File( name, timeStamp, hash, (0), contentSize ) );
 }


 size_t numFilesAlreadySynchronized = 0;
 for ( size_t i=0; i<(size_t)numFiles; ++i )
 {
  AStackString<> localFile;
  GetRemoteFilePath( (uint32_t)i, localFile );


  AutoPtr< FileStream > fileStream( new ( "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Helpers/ToolManifest.cpp", 185 ) FileStream );
  FileStream & f = *( fileStream.Get() );
  if ( f.Open( localFile.Get() ) == false )
  {
   continue;
  }
  if ( f.GetFileSize() != m_Files[ i ].m_ContentSize )
  {
   continue;
  }
  AutoPtr< char > mem( (char *)::AllocFileLine( (size_t)f.GetFileSize(), "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Helpers/ToolManifest.cpp", 195 ) );
  if ( f.Read( mem.Get(), (size_t)f.GetFileSize() ) != f.GetFileSize() )
  {
   continue;
  }
  if( Murmur3::Calc32( mem.Get(), (size_t)f.GetFileSize() ) != m_Files[ i ].m_Hash )
  {
   continue;
  }


  m_Files[ i ].m_FileLock = fileStream.Release();
  m_Files[ i ].m_SyncState = File::SYNCHRONIZED;
  numFilesAlreadySynchronized++;
 }


 do { if ( !( m_RemoteEnvironmentString == (0) ) ) { if ( AssertHandler::Failure( "m_RemoteEnvironmentString == nullptr", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Helpers/ToolManifest.cpp", 212 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;


 AStackString<> basePath;
 GetRemotePath( basePath );
 AStackString<> paths;
 paths.Format( "PATH=%s", basePath.Get() );


 AStackString<> normalTmp;
 Env::GetEnvVariable( "TMP", normalTmp );
 AStackString<> tmp;
 tmp.Format( "TMP=%s", normalTmp.Get() );


 AStackString<> sysRoot( "SystemRoot=C:\\Windows" );

 char * mem = (char *)::AllocFileLine( paths.GetLength() + 1 + tmp.GetLength() + 1 + sysRoot.GetLength() + 1 + 1,


 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Helpers/ToolManifest.cpp"
# 229 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Helpers/ToolManifest.cpp"
                      ,


 232
# 229 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Helpers/ToolManifest.cpp"
                      )


             ;
 m_RemoteEnvironmentString = mem;

 AString::Copy( paths.Get(), mem, paths.GetLength() + 1 );
 mem += ( paths.GetLength() + 1 );

 AString::Copy( tmp.Get(), mem, tmp.GetLength() + 1 );
 mem += ( tmp.GetLength() + 1 );

 AString::Copy( sysRoot.Get(), mem, sysRoot.GetLength() + 1 );
 mem += ( sysRoot.GetLength() + 1 );

 *mem = 0; ++mem;


 if ( numFilesAlreadySynchronized == m_Files.GetSize() )
 {
  m_Synchronized = true;
 }
}



bool ToolManifest::GetSynchronizationStatus( uint32_t & syncDone, uint32_t & syncTotal ) const
{
 syncDone = 0;
 syncTotal = 0;
 bool synching = false;

 MutexHolder mh( m_Mutex );


 const File * const end = m_Files.End();
 for ( const File * it = m_Files.Begin(); it != end; ++it )
 {
  syncTotal += it->m_ContentSize;
  if ( it->m_SyncState == File::SYNCHRONIZED )
  {
   syncDone += it->m_ContentSize;
  }
  else if ( it->m_SyncState == File::SYNCHRONIZING )
  {
   synching = true;
  }
 }

 return synching;
}



void ToolManifest::CancelSynchronizingFiles()
{
 MutexHolder mh( m_Mutex );

 bool atLeastOneFileCancelled = false;


 File * const end = m_Files.End();
 for ( File * it = m_Files.Begin(); it != end; ++it )
 {
  if ( it->m_SyncState == File::SYNCHRONIZING )
  {
   it->m_SyncState = File::NOT_SYNCHRONIZED;
   atLeastOneFileCancelled = true;
  }
 }



 do { if ( !( atLeastOneFileCancelled ) ) { if ( AssertHandler::Failure( "atLeastOneFileCancelled", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Helpers/ToolManifest.cpp", 302 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;
 (void)atLeastOneFileCancelled;
}



const void * ToolManifest::GetFileData( uint32_t fileId, size_t & dataSize ) const
{
 const File & f = m_Files[ fileId ];
 if ( f.m_Content == (0) )
 {
  if ( !LoadFile( f.m_Name, f.m_Content, f.m_ContentSize ) )
  {
   return (0);
  }
 }
 dataSize = f.m_ContentSize;
 return f.m_Content;
}



bool ToolManifest::ReceiveFileData( uint32_t fileId, const void * data, size_t & dataSize )
{
 MutexHolder mh( m_Mutex );

 File & f = m_Files[ fileId ];


 if ( f.m_Content )
 {
  do { if ( !( f.m_SyncState == File::SYNCHRONIZED ) ) { if ( AssertHandler::Failure( "f.m_SyncState == File::SYNCHRONIZED", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Helpers/ToolManifest.cpp", 333 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;
  return true;
 }

 do { if ( !( f.m_SyncState == File::SYNCHRONIZING ) ) { if ( AssertHandler::Failure( "f.m_SyncState == File::SYNCHRONIZING", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Helpers/ToolManifest.cpp", 337 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;


 AStackString<> fileName;
 GetRemoteFilePath( fileId, fileName );


 AStackString<> pathOnly( fileName.Get(), fileName.FindLast( ( '/' ) ) );
 if ( !FileIO::EnsurePathExists( pathOnly ) )
 {
  return false;
 }


 FileStream fs;
 if ( !fs.Open( fileName.Get(), FileStream::WRITE_ONLY ) )
 {
  return false;
 }
 if ( fs.Write( data, dataSize ) != dataSize )
 {
  return false;
 }
 fs.Close();


 AutoPtr< FileStream > fileStream( new ( "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Helpers/ToolManifest.cpp", 363 ) FileStream );
 if ( fileStream.Get()->Open( fileName.Get(), FileStream::READ_ONLY ) == false )
 {
  return false;
 }


 f.m_FileLock = fileStream.Release();
 f.m_SyncState = File::SYNCHRONIZED;


 const File * const end = m_Files.End();
 for ( const File * it = m_Files.Begin(); it != end; ++it )
 {
  if ( it->m_SyncState != File::SYNCHRONIZED )
  {

   return true;
  }
 }


 m_Synchronized = true;
 return true;
}



void ToolManifest::GetRemoteFilePath( uint32_t fileId, AString & exe, bool fullPath ) const
{

 if ( fullPath )
 {
  GetRemotePath( exe );
 }
 else
 {
  exe.Clear();
 }


 const File & primaryFile = m_Files[ 0 ];
 AStackString<> primaryPath( primaryFile.m_Name.Get(), primaryFile.m_Name.FindLast( ( '/' ) ) + 1 );

 const File & f = m_Files[ fileId ];
 if ( f.m_Name.BeginsWithI( primaryPath ) )
 {

  exe += ( f.m_Name.Get() + primaryPath.GetLength() );
 }
 else
 {

  const char * lastSlash = f.m_Name.FindLast( ( '/' ) );
  lastSlash = lastSlash ? lastSlash + 1 : f.m_Name.Get();
  exe += AStackString<>( lastSlash, f.m_Name.GetEnd() );
 }
}



void ToolManifest::GetRemotePath( AString & path ) const
{
 do { if ( !( FileIO::GetTempDir( path ) ) ) { if ( AssertHandler::Failure( "FileIO::GetTempDir( path )", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Helpers/ToolManifest.cpp", 426 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;
 AStackString<> subDir;



        subDir.Format( "_fbuild.tmp/worker/toolchain.%016llx/", m_ToolId );

 path += subDir;
}



bool ToolManifest::AddFile( const Node * node )
{
 do { if ( !( node->IsAFile() ) ) { if ( AssertHandler::Failure( "node->IsAFile()", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Helpers/ToolManifest.cpp", 440 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;

 uint32_t contentSize( 0 );
 void * content( (0) );
 if ( !LoadFile( node->GetName(), content, contentSize ) )
 {
  return false;
 }


 const AString & name = node->GetName();
 const uint64_t timeStamp = node->GetStamp();
 const uint32_t hash = Murmur3::Calc32( content, contentSize );
 m_Files.Append( File(name, timeStamp, hash, node, contentSize ) );



 File & f = m_Files.Top();
 f.m_Content = content;

 return true;
}



bool ToolManifest::LoadFile( const AString & fileName, void * & content, uint32_t & contentSize ) const
{

 FileStream fs;
 if ( fs.Open( fileName.Get(), FileStream::READ_ONLY ) == false )
 {
  do { FLog::Error( "Error opening file '%s' in Compiler ToolManifest\n", fileName.Get() ); } while ( false ); ;
  return false;
 }
 contentSize = (uint32_t)fs.GetFileSize();
 AutoPtr< void > mem( ::AllocFileLine( contentSize, "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Helpers/ToolManifest.cpp", 475 ) );
 if ( fs.Read( mem.Get(), contentSize ) != contentSize )
 {
  do { FLog::Error( "Error reading file '%s' in Compiler ToolManifest\n", fileName.Get() ); } while ( false ); ;
  return false;
 }

 content = mem.Release();
 return true;
}
# 11 "/home/ffulin/p4/tmp/Unity/Tools/FBuild/FBuildCore/Unity1.cpp" 2


# 1 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Helpers/FBuildStats.cpp" 1





# 1 "./Tools/FBuild/FBuildCore/PrecompiledHeader.h" 1
# 7 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Helpers/FBuildStats.cpp" 2

# 1 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Helpers/FBuildStats.h" 1


       
# 14 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Helpers/FBuildStats.h"
class Dependencies;
class Node;



struct FBuildStats
{
public:
 FBuildStats();

 void OnBuildStop( Node * node );




 uint32_t m_NodeTimeTotalms;
 uint32_t m_NodeTimeProgressms;


 float m_TotalBuildTime;
 uint32_t m_TotalLocalCPUTimeMS;
 uint32_t m_TotalRemoteCPUTimeMS;


 void GatherPostBuildStatistics( Node * node );

 void OutputSummary() const;


 uint32_t GetNodesProcessed() const { return m_Totals.m_NumProcessed; }
 uint32_t GetNodesBuilt() const { return m_Totals.m_NumBuilt; }
 uint32_t GetCacheHits() const { return m_Totals.m_NumCacheHits; }
 uint32_t GetCacheMisses() const { return m_Totals.m_NumCacheMisses; }
 uint32_t GetCacheStores() const { return m_Totals.m_NumCacheStores; }


 struct Stats;
 const Stats & GetStatsFor( Node::Type nodeType ) const { return m_PerTypeStats[ (size_t)nodeType ]; }


 struct Stats
 {
  Stats();

  uint32_t m_NumProcessed;
  uint32_t m_NumBuilt;
  uint32_t m_NumCacheHits;
  uint32_t m_NumCacheMisses;
  uint32_t m_NumCacheStores;

  uint32_t m_ProcessingTimeMS;
 };

 void FormatTime( float timeInSeconds , AString & buffer ) const;

 const Node * GetRootNode() const { return m_RootNode; }
 const Array< const Node * > & GetNodesByTime() const { return m_NodesByTime; }

private:
 void GatherPostBuildStatisticsRecurse( Node * node );
 void GatherPostBuildStatisticsRecurse( const Dependencies & dependencies );

 Node * m_RootNode;
 Array< const Node * > m_NodesByTime;

 Stats m_PerTypeStats[ Node::NUM_NODE_TYPES ];
 Stats m_Totals;
};
# 9 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Helpers/FBuildStats.cpp" 2


# 1 "./Tools/FBuild/FBuildCore/FBuild.h" 1


       





# 1 "./Tools/FBuild/FBuildCore/FBuildOptions.h" 1


       
# 14 "./Tools/FBuild/FBuildCore/FBuildOptions.h"
struct FBuildOptions
{
public:
 FBuildOptions();

 void SetWorkingDir( const AString & path );
 inline const AString & GetWorkingDir() const { return m_WorkingDir; }

 bool m_ForceCleanBuild;
 bool m_UseCacheRead;
 bool m_UseCacheWrite;
 bool m_ShowInfo;
 bool m_ShowCommandLines;
 bool m_ShowErrors;
 bool m_ShowProgress;
 bool m_AllowDistributed;
 bool m_ShowSummary;
 bool m_ShowBuildTime;
 bool m_SaveDBOnCompletion;
 bool m_GenerateReport;
 bool m_NoLocalConsumptionOfRemoteJobs;
 bool m_AllowLocalRace;
 bool m_WrapperChild;
 bool m_FixupErrorPaths;
 bool m_StopOnFirstError;
 uint32_t m_NumWorkerThreads;
 AString m_ConfigFile;

    inline uint32_t GetWorkingDirHash() const { return m_WorkingDirHash; }
    inline const AString & GetMainProcessMutexName() const { return m_ProcessMutexName; }
    inline const AString & GetFinalProcessMutexName( ) const { return m_FinalProcessMutexName; }
    inline const AString & GetSharedMemoryName() const { return m_SharedMemoryName; }

private:
 AString m_WorkingDir;

    uint32_t m_WorkingDirHash;
    AString m_ProcessMutexName;
    AString m_FinalProcessMutexName;
    AString m_SharedMemoryName;
};
# 10 "./Tools/FBuild/FBuildCore/FBuild.h" 2


# 1 "./Tools/FBuild/FBuildCore/WorkerPool/WorkerBrokerage.h" 1


       
# 16 "./Tools/FBuild/FBuildCore/WorkerPool/WorkerBrokerage.h"
class WorkerBrokerage
{
public:
 WorkerBrokerage();
 ~WorkerBrokerage();


 void FindWorkers( Array< AString > & workerList );


 void SetAvailability( bool available );
private:
 AString m_BrokerageRoot;
 bool m_Availability;
};
# 13 "./Tools/FBuild/FBuildCore/FBuild.h" 2


# 1 "./Core/Containers/Singleton.h" 1


       
# 13 "./Core/Containers/Singleton.h"
template < class T >
class Singleton
{
public:
 static T & Get();
 static inline bool IsValid() { return ( s_Instance != (0) ); }

protected:
 Singleton();
 ~Singleton();

private:
 static T * s_Instance;
};



template < class T >
T * Singleton< T >::s_Instance = (0);



template < class T >
Singleton< T >::Singleton()
{
 do { if ( !( s_Instance == (0) ) ) { if ( AssertHandler::Failure( "s_Instance == nullptr", "./Core/Containers/Singleton.h", 38 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;
 s_Instance = static_cast< T * >( this );
}



template < class T >
Singleton< T >::~Singleton()
{
 do { if ( !( s_Instance == this ) ) { if ( AssertHandler::Failure( "s_Instance == this", "./Core/Containers/Singleton.h", 47 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;
 s_Instance = (0);
}



template < class T >
T & Singleton< T >::Get()
{
 do { if ( !( s_Instance ) ) { if ( AssertHandler::Failure( "s_Instance", "./Core/Containers/Singleton.h", 56 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;

 return *s_Instance;

}
# 16 "./Tools/FBuild/FBuildCore/FBuild.h" 2





class Client;
class FileStream;
class ICache;
class JobQueue;
class Node;
class NodeGraph;



class FBuild : public Singleton< FBuild >
{
public:
 explicit FBuild( const FBuildOptions & options = FBuildOptions() );
 ~FBuild();



 bool Initialize( const char * nodeGraphDBFile = (0) );


 bool Build( const AString & target );
 bool Build( const Array< AString > & targets );
 bool Build( Node * nodeToBuild );


 bool SaveDependencyGraph( const char * nodeGraphDBFile = (0) ) const;

 const FBuildOptions & GetOptions() const { return m_Options; }
 NodeGraph & GetDependencyGraph() const { return *m_DependencyGraph; }

 const AString & GetWorkingDir() const { return m_Options.GetWorkingDir(); }

 static const char * GetDependencyGraphFileName();
 static const char * GetDefaultBFFFileName();

 const AString & GetCachePath() const { return m_CachePath; }
 void SetCachePath( const AString & path );

 const AString & GetCachePluginDLL() const { return m_CachePluginDLL; }
 void SetCachePluginDLL( const AString & plugin ) { m_CachePluginDLL = plugin; }

 void GetCacheFileName( uint64_t keyA, uint32_t keyB, uint64_t keyC,
         AString & path ) const;

 void SetWorkerList( const Array< AString > & workers ) { m_WorkerList = workers; }
 const Array< AString > & GetWorkerList() const { return m_WorkerList; }

 void SetEnvironmentString( const char * envString, uint32_t size, const AString & libEnvVar );
 inline const char * GetEnvironmentString() const { return m_EnvironmentString; }
 inline uint32_t GetEnvironmentStringSize() const { return m_EnvironmentStringSize; }

 void GetLibEnvVar( AString & libEnvVar ) const;


 const FBuildStats & GetStats() const { return m_BuildStats; }

 FBuildStats & GetStatsMutable() { return m_BuildStats; }


 static inline void AbortBuild() { s_StopBuild = true; }
 static void OnBuildError();
 static inline bool GetStopBuild() { return s_StopBuild; }

 inline ICache * GetCache() const { return m_Cache; }

private:
 void UpdateBuildStatus( const Node * node, bool forceUpdate );

 static bool s_StopBuild;

 NodeGraph * m_DependencyGraph;
 JobQueue * m_JobQueue;
 Client * m_Client;

 AString m_CachePluginDLL;
 AString m_CachePath;
 ICache * m_Cache;

 Timer m_Timer;
 float m_LastProgressOutputTime;
 float m_LastProgressCalcTime;
 float m_SmoothedProgressCurrent;
 float m_SmoothedProgressTarget;

 FBuildStats m_BuildStats;

 FBuildOptions m_Options;

 WorkerBrokerage m_WorkerBrokerage;

 Array< AString > m_WorkerList;

 AString m_OldWorkingDir;


 char * m_EnvironmentString;
 uint32_t m_EnvironmentStringSize;
 AString m_LibEnvVar;
};
# 12 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Helpers/FBuildStats.cpp" 2
# 1 "./Tools/FBuild/FBuildCore/Helpers/Report.h" 1


       






# 1 "./Core/Mem/MemPoolBlock.h" 1


       
# 13 "./Core/Mem/MemPoolBlock.h"
class MemPoolBlock
{
public:
 MemPoolBlock( size_t blockSize, size_t blockAlignment );
 ~MemPoolBlock();

 void * Alloc( size_t size );
 void Free( void * ptr );

private:
 void AllocPage();

 struct FreeBlock
 {
  FreeBlock * m_Next;
 };


 FreeBlock * m_FreeBlockChain;


 uint32_t m_NumAllocations;


 size_t m_BlockSize;
 size_t m_BlockAlignment;


 enum { PAGE_SIZE = 64 * 1024 };
 Array< void * > m_Pages;
};
# 11 "./Tools/FBuild/FBuildCore/Helpers/Report.h" 2




struct FBuildStats;
class Dependencies;
class Node;



class Report
{
public:
 Report();
 ~Report();

 void Generate( const FBuildStats & stats );
 void Save() const;

private:

 void CreateHeader();
 void CreateTitle();
 void CreateOverview( const FBuildStats & stats );
 void DoCacheStats( const FBuildStats & stats );
 void DoCPUTimeByType( const FBuildStats & stats );
 void DoCPUTimeByItem( const FBuildStats & stats );
 void DoCPUTimeByLibrary();
 void DoIncludes();

 void CreateFooter();

 struct PieItem
 {
  PieItem( const char * l, float v, uint32_t c, void * u = (0) )
   : label( l )
   , value( v )
   , color( c )
   , userData( u )
  {
  }

  const char * label;
  float value;
  uint32_t color;
  void * userData;

  bool operator < ( const PieItem & other ) const { return value > other.value; }
 };

 struct LibraryStats
 {
  const Node * library;
  uint32_t cpuTimeMS;
  uint32_t objectCount;
  uint32_t objectCount_OutOfDate;
  uint32_t objectCount_Cacheable;
  uint32_t objectCount_CacheHits;
  uint32_t objectCount_CacheStores;

  bool operator < ( const LibraryStats & other ) const { return cpuTimeMS > other.cpuTimeMS; }
 };

 struct IncludeStats
 {
  const Node * node;
  uint32_t count;
  bool inPCH;

  bool operator < ( const IncludeStats & other ) const { return count > other.count; }

  IncludeStats * m_Next;
 };

 class IncludeStatsMap
 {
 public:
  IncludeStatsMap();
  ~IncludeStatsMap();

  IncludeStats * Find( const Node * node ) const;
  IncludeStats * Insert( const Node * node );

  void Flatten( Array< const IncludeStats * > & stats ) const;
 protected:
  IncludeStats * m_Table[ 65536 ];
  MemPoolBlock m_Pool;
 };

 enum { DEFAULT_TABLE_WIDTH = 990 };


 void DoTableStart( int width = DEFAULT_TABLE_WIDTH, const char * id = (0), bool hidden = false );
 void DoTableStop();
 void DoToggleSection( size_t numMore = 0 );
 void DoSectionTitle( const char * sectionName, const char * sectionId );
 void DoPieChart( const Array< PieItem > & items, const char * units );


 void Write( const char * fmtString, ... );


 void GetLibraryStats( const FBuildStats & stats );
 void GetLibraryStatsRecurse( Array< LibraryStats * > & libStats, const Node * node, LibraryStats * currentLib ) const;
 void GetLibraryStatsRecurse( Array< LibraryStats * > & libStats, const Dependencies & dependencies, LibraryStats * currentLib ) const;
 void GetIncludeFilesRecurse( IncludeStatsMap & incStats, const Node * node) const;
 void AddInclude( IncludeStatsMap & incStats, const Node * node, const Node * parentNode) const;


 Array< LibraryStats * > m_LibraryStats;
 uint32_t m_NumPieCharts;


 AString m_Output;
};
# 13 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Helpers/FBuildStats.cpp" 2







class NodeCostSorter
{
public:
 inline bool operator () ( const Node * a, const Node * b ) const
 {
  return ( a->GetProcessingTime() > b->GetProcessingTime() );
 }
};



FBuildStats::FBuildStats()
 : m_NodeTimeTotalms( 0 )
 , m_NodeTimeProgressms( 0 )
 , m_TotalBuildTime( 0.0f )
 , m_TotalLocalCPUTimeMS( 0 )
 , m_TotalRemoteCPUTimeMS( 0 )
 , m_RootNode( (0) )
 , m_NodesByTime( 100 * 1000, true )
{}



FBuildStats::Stats::Stats()
 : m_NumProcessed( 0 )
 , m_NumBuilt( 0 )
 , m_NumCacheHits( 0 )
 , m_NumCacheMisses( 0 )
 , m_NumCacheStores( 0 )
 , m_ProcessingTimeMS( 0 )
{}



void FBuildStats::OnBuildStop( Node * node )
{
 m_RootNode = node;

 const FBuildOptions & options = FBuild::Get().GetOptions();
 const bool showSummary = options.m_ShowSummary;
 const bool generateReport = options.m_GenerateReport;


 if ( showSummary || generateReport )
 {

  GatherPostBuildStatistics( node );


  if ( generateReport )
  {
   Report r;
   r.Generate( *this );
   r.Save();
  }


  if ( showSummary )
  {
   OutputSummary();
  }
 }
}



void FBuildStats::GatherPostBuildStatistics( Node * node )
{

 GatherPostBuildStatisticsRecurse( node );

 NodeCostSorter ncs;
 m_NodesByTime.Sort( ncs );


 for ( uint32_t i=0; i< Node::NUM_NODE_TYPES; ++i )
 {
  m_Totals.m_NumProcessed += m_PerTypeStats[ i ].m_NumProcessed;
  m_Totals.m_NumBuilt += m_PerTypeStats[ i ].m_NumBuilt;
  m_Totals.m_NumCacheHits += m_PerTypeStats[ i ].m_NumCacheHits;
  m_Totals.m_NumCacheMisses += m_PerTypeStats[ i ].m_NumCacheMisses;
  m_Totals.m_NumCacheStores += m_PerTypeStats[ i ].m_NumCacheStores;
 }
}



void FBuildStats::OutputSummary() const
{


 if ( m_NodesByTime.IsEmpty() == false )
 {
  Tracing::OutputFormat( "--- Most Expensive ----------------------------------------------\n" );
  Tracing::OutputFormat( "Time (s)  Name:\n" );
  size_t itemsToDisplay = Math::Min( m_NodesByTime.GetSize(), (size_t)20 );
  for ( size_t i=0; i<itemsToDisplay; ++i )
  {
   const Node * n = m_NodesByTime[ i ];
   Tracing::OutputFormat( "%-9.3f %s\n", ( (float)n->GetProcessingTime() / 1000.0f ), n->GetName().Get() );
  }
  Tracing::OutputFormat( "\n" );
 }

 Tracing::OutputFormat( "--- Summary -----------------------------------------------------\n" );



 Tracing::OutputFormat( "                                 /----- Cache -----\\\n" );
 Tracing::OutputFormat( "Build:          Seen    Built   Hit     Miss    Store   CPU\n" );
 for ( uint32_t i=0; i< Node::NUM_NODE_TYPES; ++i )
 {

  const Stats & stats = m_PerTypeStats[ i ];
  if ( stats.m_NumProcessed == 0 )
  {
   continue;
  }

  const char * typeName = Node::GetTypeName( Node::Type( i ) );

  AStackString<> cpuTime;
  FormatTime( (float)( (double)stats.m_ProcessingTimeMS / (double)1000 ), cpuTime );

  AStackString<> cacheInfo;
  if ( ( stats.m_NumCacheHits + stats.m_NumCacheMisses + stats.m_NumCacheStores ) > 0 )
  {
   cacheInfo.Format( "%-8u%-8u%-8u",
         stats.m_NumCacheHits,
         stats.m_NumCacheMisses,
         stats.m_NumCacheStores );
  }
  else
  {
   cacheInfo = "-       -       -       ";
  }
  Tracing::OutputFormat( " - %-10s : %-8u%-8u%s%s\n", typeName, stats.m_NumProcessed, stats.m_NumBuilt, cacheInfo.Get(), cpuTime.Get() )




                     ;
 }
 Tracing::OutputFormat( "Cache:\n" );
 {
  const uint32_t hits = m_Totals.m_NumCacheHits;
  const uint32_t misses = m_Totals.m_NumCacheMisses;
  const uint32_t stores = m_Totals.m_NumCacheStores;
  float hitPerc = 0.0f;
  if ( hits > 0 || misses > 0 )
  {
   hitPerc = ( (float)hits / float( hits + misses ) * 100.0f );
  }
  Tracing::OutputFormat( " - Hits       : %u (%2.1f %%)\n", hits, hitPerc );
  Tracing::OutputFormat( " - Misses     : %u\n", misses );
  Tracing::OutputFormat( " - Stores     : %u\n", stores );
 }

 AStackString<> buffer;
 FormatTime( m_TotalBuildTime, buffer );
 Tracing::OutputFormat( "Time:\n" );
 Tracing::OutputFormat( " - Real       : %s\n", buffer.Get() );
 float totalLocalCPUInSeconds = (float)( (double)m_TotalLocalCPUTimeMS / (double)1000 );
 float totalRemoteCPUInSeconds = (float)( (double)m_TotalRemoteCPUTimeMS / (double)1000 );
 FormatTime( totalLocalCPUInSeconds, buffer );
 float localRatio = ( totalLocalCPUInSeconds / m_TotalBuildTime );
 Tracing::OutputFormat( " - Local CPU  : %s (%2.1f:1)\n", buffer.Get(), localRatio );
 FormatTime( totalRemoteCPUInSeconds, buffer );
 float remoteRatio = ( totalRemoteCPUInSeconds / m_TotalBuildTime );
 Tracing::OutputFormat( " - Remote CPU : %s (%2.1f:1)\n", buffer.Get(), remoteRatio );
 Tracing::OutputFormat( "-----------------------------------------------------------------\n" );
}



void FBuildStats::GatherPostBuildStatisticsRecurse( Node * node )
{

 if ( node->GetStatFlag( Node::STATS_STATS_PROCESSED ) )
 {
  return;
 }

 Node::Type nodeType = node->GetType();
 Stats & stats = m_PerTypeStats[ nodeType ];

 if ( node->GetType() != Node::PROXY_NODE )
 {
  stats.m_NumProcessed++;

  m_TotalLocalCPUTimeMS += node->GetProcessingTime();
  if (node->GetStatFlag(Node::STATS_BUILT_REMOTE))
  {
   m_TotalRemoteCPUTimeMS += node->GetLastBuildTime();
  }
  stats.m_ProcessingTimeMS += node->GetProcessingTime();


  if ( node->GetProcessingTime() > 0 )
  {

   if ( node->GetType() != Node::FILE_NODE )
   {
    m_NodesByTime.Append( node );
   }
  }

  if ( node->GetStatFlag( Node::STATS_BUILT ) )
  {
   stats.m_NumBuilt++;
  }
  if ( node->GetStatFlag( Node::STATS_CACHE_HIT ) )
  {
   stats.m_NumCacheHits++;
  }
  if ( node->GetStatFlag( Node::STATS_CACHE_MISS ) )
  {
   stats.m_NumCacheMisses++;
  }
  if ( node->GetStatFlag( Node::STATS_CACHE_STORE ) )
  {
   stats.m_NumCacheStores++;
  }
 }


 node->SetStatFlag( Node::STATS_STATS_PROCESSED );


 GatherPostBuildStatisticsRecurse( node->GetPreBuildDependencies() );
 GatherPostBuildStatisticsRecurse( node->GetStaticDependencies() );
 GatherPostBuildStatisticsRecurse( node->GetDynamicDependencies() );
}



void FBuildStats::GatherPostBuildStatisticsRecurse( const Dependencies & dependencies )
{
 const Dependencies::Iter end = dependencies.End();
 for ( Dependencies::Iter it = dependencies.Begin();
    it != end;
    it++ )
 {
  GatherPostBuildStatisticsRecurse( it->GetNode() );
 }
}



void FBuildStats::FormatTime( float timeInSeconds , AString & buffer ) const
{
 buffer.Clear();

 uint32_t days = (uint32_t)( timeInSeconds / ( 24.0f * 60.0f * 60.0f ) );
 timeInSeconds -= ( (float)days * ( 24.0f * 60.0f * 60.0f ) );
 uint32_t hours = (uint32_t)( timeInSeconds / ( 60.0f * 60.0f ) );
 timeInSeconds -= ( (float)hours * ( 60.0f * 60.0f ) );
 uint32_t mins = (uint32_t)( timeInSeconds / 60.0f );
 timeInSeconds -= ( (float)mins * 60.0f );

 AStackString<> temp;

 if ( days > 0 )
 {
  temp.Format( "%u days, ", days );
  buffer += temp;
 }
 if ( hours > 0 )
 {
  temp.Format( "%uh:", hours );
  buffer += temp;
 }
 if ( mins > 0 )
 {
  temp.Format( "%um ", mins );
  buffer += temp;
 }

 temp.Format( "%2.3fs", timeInSeconds );
 buffer += temp;
}
# 14 "/home/ffulin/p4/tmp/Unity/Tools/FBuild/FBuildCore/Unity1.cpp" 2


# 1 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Helpers/VSProjectGenerator.cpp" 1





# 1 "./Tools/FBuild/FBuildCore/PrecompiledHeader.h" 1
# 7 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Helpers/VSProjectGenerator.cpp" 2






# 1 "./Core/Math/CRC32.h" 1


       
# 14 "./Core/Math/CRC32.h"
class CRC32
{
public:
 static inline uint32_t Start() { return 0xFFFFFFFF; }
 static uint32_t Update( uint32_t crc32, const void * buffer, size_t len );
 static uint32_t UpdateLower( uint32_t crc32, const void * buffer, size_t len );
 static inline uint32_t Stop( uint32_t crc32 ) { return ( crc32 ^ 0xFFFFFFFF ); }

 static uint32_t Calc( const void * buffer, size_t len );
 static uint32_t CalcLower( const void * buffer, size_t len );

 inline static uint32_t Calc( const AString & string ) { return Calc( string.Get(), string.GetLength() ); }
 inline static uint32_t CalcLower( const AString & string ) { return CalcLower( string.Get(), string.GetLength() ); }
};
# 14 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Helpers/VSProjectGenerator.cpp" 2







VSProjectGenerator::VSProjectGenerator()
 : m_BasePaths( 0, true )
 , m_AllowedFileExtensions( 0, true )
 , m_References( 0, true )
 , m_ProjectReferences( 0, true )
 , m_Files( 1024, true )
{
}



VSProjectGenerator::~VSProjectGenerator()
{
}



void VSProjectGenerator::SetBasePaths( const Array< AString > & paths )
{
 m_BasePaths = paths;
}



void VSProjectGenerator::AddFile( const AString & file, bool filterByExtension )
{

 AStackString<> fileCopy( file );
 fileCopy.Replace( ( '/' ), ( '\\' ) );


 size_t numAllowedFileExtensions = m_AllowedFileExtensions.GetSize();
 if ( filterByExtension && numAllowedFileExtensions )
 {
  bool keep = false;
  for ( size_t i=0; i<numAllowedFileExtensions; ++i )
  {
   if ( file.EndsWithI( m_AllowedFileExtensions[ i ] ) )
   {
    keep = true;
    break;
   }
  }
  if ( !keep )
  {
   return;
  }
 }

 do { if ( !( !m_Files.Find( fileCopy ) ) ) { if ( AssertHandler::Failure( "!m_Files.Find( fileCopy )", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Helpers/VSProjectGenerator.cpp", 70 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;
 m_Files.Append( fileCopy );
}



void VSProjectGenerator::AddFiles( const Array< AString > & files, bool filterByExtension )
{
 const AString * const fEnd = files.End();
 for ( const AString * fIt = files.Begin(); fIt!=fEnd; ++fIt )
 {
  AddFile( *fIt, filterByExtension );
 }
}



const AString & VSProjectGenerator::GenerateVCXProj( const AString & projectFile,
              const Array< VSProjectConfig > & configs,
              const Array< VSProjectFileType > & fileTypes )
{
 do { if ( !( !m_ProjectName.IsEmpty() ) ) { if ( AssertHandler::Failure( "!m_ProjectName.IsEmpty()", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Helpers/VSProjectGenerator.cpp", 91 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;


 m_Tmp.SetReserved( (1024 * 1024) );
 m_Tmp.SetLength( 0 );


 const char * lastSlash = projectFile.FindLast( ( '/' ) );
 AStackString<> projectBasePath( projectFile.Get(), lastSlash ? lastSlash + 1 : projectFile.Get() );


 Write( "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n" );
 Write( "<Project DefaultTargets=\"Build\" ToolsVersion=\"4.0\" xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\">\n" );


 {
  Write( "  <ItemGroup Label=\"ProjectConfigurations\">\n" );
  const VSProjectConfig * const cEnd = configs.End();
  for ( const VSProjectConfig * cIt = configs.Begin(); cIt!=cEnd; ++cIt )
  {
   Write( "    <ProjectConfiguration Include=\"%s|%s\">\n", cIt->m_Config.Get(), cIt->m_Platform.Get() );
   Write( "      <Configuration>%s</Configuration>\n", cIt->m_Config.Get() );
   Write( "      <Platform>%s</Platform>\n", cIt->m_Platform.Get() );
   Write( "    </ProjectConfiguration>\n" );
  }
  Write( "  </ItemGroup>\n" );
 }


 {
  Write("  <ItemGroup>\n" );
  const AString * const fEnd = m_Files.End();
  for ( const AString * fIt = m_Files.Begin(); fIt!=fEnd; ++fIt )
  {
   const char * fileName = fIt->BeginsWithI( projectBasePath ) ? fIt->Get() + projectBasePath.GetLength() : fIt->Get();
   const char * fileType = (0);
   const VSProjectFileType * const end = fileTypes.End();
   for ( const VSProjectFileType * it=fileTypes.Begin(); it!=end; ++it )
   {
    if ( AString::MatchI( it->m_Pattern.Get(), fileName ) )
    {
     fileType = it->m_FileType.Get();
     break;
    }
   }
   if ( fileType )
   {
       Write( "    <CustomBuild Include=\"%s\">\n", fileName );
       Write( "        <FileType>%s</FileType>\n", fileType );
       Write( "    </CustomBuild>\n" );
   }
   else
   {
       Write( "    <CustomBuild Include=\"%s\" />\n", fileName );
   }
  }
  Write("  </ItemGroup>\n" );
 }


 {
  Write("  <ItemGroup>\n" );
  {

   const AString * const end = m_ProjectReferences.End();
   for ( const AString * it = m_ProjectReferences.Begin(); it != end; ++it )
   {
    AStackString<> proj( *it );
    const char * pipe = proj.Find( '|' );
    if ( pipe )
    {
     proj.SetLength( (uint32_t)( pipe - proj.Get() ) );
     AStackString<> guid( pipe + 1 );
     Write( "    <ProjectReference Include=\"%s\">\n", proj.Get() );
     Write( "      <Project>%s</Project>\n", guid.Get() );
     Write( "    </ProjectReference>\n" );
    }
    else
    {
     Write( "    <ProjectReference Include=\"%s\" />\n", proj.Get() );
    }
   }
  }
  {

   const AString * const end = m_References.End();
   for ( const AString * it = m_References.Begin(); it != end; ++it )
   {
       Write( "    <Reference Include=\"%s\" />\n", it->Get() );
   }
  }
  Write("  </ItemGroup>\n" );
 }


 AStackString<> guid;
 if ( m_ProjectGuid.IsEmpty() )
 {
  guid.Format( "{%08x-6c94-4f93-bc2a-7f5284b7d434}", CRC32::Calc( m_ProjectName ) );
 }
 else
 {
  guid = m_ProjectGuid;
 }


 Write( "  <PropertyGroup Label=\"Globals\">\n" );
 WritePGItem( "RootNamespace", m_RootNamespace );
 WritePGItem( "ProjectGuid", guid );
 WritePGItem( "DefaultLanguage", m_DefaultLanguage );
    WritePGItem( "Keyword", AStackString<>( "MakeFileProj" ) );
 WritePGItem( "ApplicationEnvironment", m_ApplicationEnvironment );
 Write( "  </PropertyGroup>\n" );


 Write( "  <Import Project=\"$(VCTargetsPath)\\Microsoft.Cpp.Default.props\" />\n" );


 {
  const VSProjectConfig * const cEnd = configs.End();
  for ( const VSProjectConfig * cIt = configs.Begin(); cIt!=cEnd; ++cIt )
  {
   Write( "  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='%s|%s'\" Label=\"Configuration\">\n", cIt->m_Config.Get(), cIt->m_Platform.Get() );
   Write( "    <ConfigurationType>Makefile</ConfigurationType>\n" );
   Write( "    <UseDebugLibraries>false</UseDebugLibraries>\n" );

   WritePGItem( "PlatformToolset", cIt->m_PlatformToolset );
   WritePGItem( "LocalDebuggerCommandArguments", cIt->m_LocalDebuggerCommandArguments );
   WritePGItem( "LocalDebuggerCommand", cIt->m_LocalDebuggerCommand );
   WritePGItem( "LocalDebuggerEnvironment", cIt->m_LocalDebuggerEnvironment );

   Write( "  </PropertyGroup>\n" );
  }
 }


 {
  Write( "  <Import Project=\"$(VCTargetsPath)\\Microsoft.Cpp.props\" />\n" );
  Write( "  <ImportGroup Label=\"ExtensionSettings\">\n" );
  Write( "  </ImportGroup>\n" );
 }


 {
  const VSProjectConfig * const cEnd = configs.End();
  for ( const VSProjectConfig * cIt = configs.Begin(); cIt!=cEnd; ++cIt )
  {
   Write( "  <ImportGroup Label=\"PropertySheets\" Condition=\"'$(Configuration)|$(Platform)'=='%s|%s'\">\n", cIt->m_Config.Get(), cIt->m_Platform.Get() );
   Write( "    <Import Project=\"$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props\" Condition=\"exists('$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props')\" Label=\"LocalAppDataPlatform\" />\n" );
   Write( "  </ImportGroup>\n" );
  }
 }


 Write( "  <PropertyGroup Label=\"UserMacros\" />\n" );


 {
  const VSProjectConfig * const cEnd = configs.End();
  for ( const VSProjectConfig * cIt = configs.Begin(); cIt!=cEnd; ++cIt )
  {
   Write( "  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='%s|%s'\">\n", cIt->m_Config.Get(), cIt->m_Platform.Get() );

   WritePGItem( "NMakeBuildCommandLine", cIt->m_BuildCommand );
   WritePGItem( "NMakeReBuildCommandLine", cIt->m_RebuildCommand );
   WritePGItem( "NMakeCleanCommandLine", cIt->m_CleanCommand );
   WritePGItem( "NMakeOutput", cIt->m_Output );
   WritePGItem( "NMakePreprocessorDefinitions", cIt->m_PreprocessorDefinitions );
   WritePGItem( "NMakeIncludeSearchPath", cIt->m_IncludeSearchPath );
   WritePGItem( "NMakeForcedIncludes", cIt->m_ForcedIncludes );
   WritePGItem( "NMakeAssemblySearchPath", cIt->m_AssemblySearchPath );
   WritePGItem( "NMakeForcedUsingAssemblies", cIt->m_ForcedUsingAssemblies );
   WritePGItem( "AdditionalOptions", cIt->m_AdditionalOptions );
   WritePGItem( "Xbox360DebuggerCommand", cIt->m_Xbox360DebuggerCommand );
   WritePGItem( "DebuggerFlavor", cIt->m_DebuggerFlavor );
   WritePGItem( "AumidOverride", cIt->m_AumidOverride );
   WritePGItem( "LocalDebuggerWorkingDirectory", cIt->m_LocalDebuggerWorkingDirectory );
   WritePGItem( "IntDir", cIt->m_IntermediateDirectory );
   WritePGItem( "OutDir", cIt->m_OutputDirectory );
   WritePGItem( "LayoutDir", cIt->m_LayoutDir );
   WritePGItem( "LayoutExtensionFilter", cIt->m_LayoutExtensionFilter );
   Write( "  </PropertyGroup>\n" );
  }
 }


 {
  const VSProjectConfig * const cEnd = configs.End();
  for ( const VSProjectConfig * cIt = configs.Begin(); cIt!=cEnd; ++cIt )
  {
   Write( "  <ItemDefinitionGroup Condition=\"'$(Configuration)|$(Platform)'=='%s|%s'\">\n", cIt->m_Config.Get(), cIt->m_Platform.Get() );
   Write( "    <BuildLog>\n" );
   Write( "      <Path />\n" );
   Write( "    </BuildLog>\n" );
   if ( ( !cIt->m_DeploymentType.IsEmpty() ) || ( !cIt->m_DeploymentFiles.IsEmpty() ) )
   {
    Write( "    <Deploy>\n" );
    WritePGItem( "DeploymentType", cIt->m_DeploymentType );
    WritePGItem( "DeploymentFiles", cIt->m_DeploymentFiles );
    Write( "    </Deploy>\n" );
   }
   Write( "  </ItemDefinitionGroup>\n" );
  }
 }


 Write("  <Import Project=\"$(VCTargetsPath)\\Microsoft.Cpp.targets\" />\n" );
 Write("  <ImportGroup Label=\"ExtensionTargets\">\n" );
 Write("  </ImportGroup>\n" );
 Write("  <Import Condition=\"'$(ConfigurationType)' == 'Makefile' and Exists('$(VCTargetsPath)\\Platforms\\$(Platform)\\SCE.Makefile.$(Platform).targets')\" Project=\"$(VCTargetsPath)\\Platforms\\$(Platform)\\SCE.Makefile.$(Platform).targets\" />\n");
 Write( "</Project>" );

 m_OutputVCXProj = m_Tmp;
 return m_OutputVCXProj;
}



const AString & VSProjectGenerator::GenerateVCXProjFilters( const AString & projectFile )
{

 m_Tmp.SetReserved( (1024 * 1024) );
 m_Tmp.SetLength( 0 );


 const char * lastProjSlash = projectFile.FindLast( ( '/' ) );
 AStackString<> projectBasePath( projectFile.Get(), lastProjSlash ? lastProjSlash + 1 : projectFile.Get() );


 Write( "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n" );
 Write( "<Project ToolsVersion=\"4.0\" xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\">\n" );


 Array< AString > folders( 1024, true );


 {
  Write( "  <ItemGroup>\n" );
  const AString * const fEnd = m_Files.End();
  for ( const AString * fIt = m_Files.Begin(); fIt!=fEnd; ++fIt )
  {

   AStackString<> folder;
   GetFolderPath( *fIt, folder );
   const char * fileName = fIt->BeginsWithI( projectBasePath ) ? fIt->Get() + projectBasePath.GetLength() : fIt->Get();
   Write( "    <CustomBuild Include=\"%s\">\n", fileName );
   if ( !folder.IsEmpty() )
   {
    Write( "      <Filter>%s</Filter>\n", folder.Get() );
   }
   Write( "    </CustomBuild>\n" );


   if ( !folder.IsEmpty() )
   {
    for (;;)
    {

     bool found = false;
     for ( const AString * it=folders.Begin(); it!=folders.End(); ++it )
     {
      if ( it->CompareI( folder ) == 0 )
      {
       found = true;
       break;
      }
     }
     if ( !found )
     {
      folders.Append( folder );
     }


     const char * lastSlash = folder.FindLast( ( '\\' ) );
     if ( lastSlash == (0) )
     {
      break;
     }
     folder.SetLength( (uint32_t)( lastSlash - folder.Get() ) );
    }
   }
  }
  Write( "  </ItemGroup>\n" );
 }


 {
  const AString * const fEnd = folders.End();
  for ( const AString * fIt = folders.Begin(); fIt!=fEnd; ++fIt )
  {
   Write( "  <ItemGroup>\n" );
   Write( "    <Filter Include=\"%s\">\n", fIt->Get() );
   Write( "      <UniqueIdentifier>{%08x-6c94-4f93-bc2a-7f5284b7d434}</UniqueIdentifier>\n", CRC32::Calc( *fIt ) );
   Write( "    </Filter>\n" );
   Write( "  </ItemGroup>\n" );
  }
 }


 Write( "</Project>" );

 m_OutputVCXProjFilters = m_Tmp;
 return m_OutputVCXProjFilters;
}



void VSProjectGenerator::Write( const char * fmtString, ... )
{
 AStackString< 1024 > tmp;

 va_list args;
 __builtin_va_start(args,fmtString);
 tmp.VFormat( fmtString, args );
 __builtin_va_end(args);


 if ( m_Tmp.GetLength() + tmp.GetLength() > m_Tmp.GetReserved() )
 {
  m_Tmp.SetReserved( m_Tmp.GetReserved() + (1024 * 1024) );
 }

 m_Tmp += tmp;
}



void VSProjectGenerator::WritePGItem( const char * xmlTag, const AString & value )
{
 if ( value.IsEmpty() )
 {
  return;
 }
 Write( "    <%s>%s</%s>\n", xmlTag, value.Get(), xmlTag );
}



void VSProjectGenerator::GetFolderPath( const AString & fileName, AString & folder ) const
{
 const AString * const bEnd = m_BasePaths.End();
 for ( const AString * bIt = m_BasePaths.Begin(); bIt != bEnd; ++bIt )
 {
  const AString & basePath = *bIt;
  const char * begin = fileName.Get();
  const char * end = fileName.GetEnd();

  if ( fileName.BeginsWithI( basePath ) )
  {
   begin = fileName.Get() + basePath.GetLength();
   const char * lastSlash = fileName.FindLast( ( '\\' ) );
   end = ( lastSlash ) ? lastSlash : end;
   if ( begin < end )
   {
    folder.Assign( begin, end );
    return;
   }
  }
 }


 folder.Clear();
}



           void VSProjectConfig::Save( IOStream & stream, const Array< VSProjectConfig > & configs )
{
 uint32_t numConfigs = (uint32_t)configs.GetSize();
 stream.Write( numConfigs );
 for ( uint32_t i=0; i<numConfigs; ++i )
 {
  const VSProjectConfig & cfg = configs[ i ];

  stream.Write( cfg.m_Platform );
  stream.Write( cfg.m_Config );

  stream.Write( cfg.m_BuildCommand );
  stream.Write( cfg.m_RebuildCommand );
  stream.Write( cfg.m_CleanCommand );

  stream.Write( cfg.m_Output );
  stream.Write( cfg.m_PreprocessorDefinitions );
  stream.Write( cfg.m_IncludeSearchPath );
  stream.Write( cfg.m_ForcedIncludes );
  stream.Write( cfg.m_AssemblySearchPath );
  stream.Write( cfg.m_ForcedUsingAssemblies );
  stream.Write( cfg.m_AdditionalOptions );
  stream.Write( cfg.m_OutputDirectory );
  stream.Write( cfg.m_IntermediateDirectory );
  stream.Write( cfg.m_LayoutDir );
  stream.Write( cfg.m_LayoutExtensionFilter );
  stream.Write( cfg.m_Xbox360DebuggerCommand );
  stream.Write( cfg.m_DebuggerFlavor );
  stream.Write( cfg.m_AumidOverride );
  stream.Write( cfg.m_PlatformToolset );
  stream.Write( cfg.m_DeploymentType );
  stream.Write( cfg.m_DeploymentFiles );

  stream.Write( cfg.m_LocalDebuggerCommandArguments );
  stream.Write( cfg.m_LocalDebuggerWorkingDirectory );
  stream.Write( cfg.m_LocalDebuggerCommand );
  stream.Write( cfg.m_LocalDebuggerEnvironment );
 }
}



           bool VSProjectConfig::Load( IOStream & stream, Array< VSProjectConfig > & configs )
{
 do { if ( !( configs.IsEmpty() ) ) { if ( AssertHandler::Failure( "configs.IsEmpty()", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Helpers/VSProjectGenerator.cpp", 501 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;

 uint32_t numConfigs( 0 );
 if ( !stream.Read( numConfigs ) )
 {
  return false;
 }
 configs.SetSize( numConfigs );
 for ( uint32_t i=0; i<numConfigs; ++i )
 {
  VSProjectConfig & cfg = configs[ i ];

  if ( stream.Read( cfg.m_Platform ) == false ) { return false; }
  if ( stream.Read( cfg.m_Config ) == false ) { return false; }

  if ( stream.Read( cfg.m_BuildCommand ) == false ) { return false; }
  if ( stream.Read( cfg.m_RebuildCommand ) == false ) { return false; }
  if ( stream.Read( cfg.m_CleanCommand ) == false ) { return false; }

  if ( stream.Read( cfg.m_Output ) == false ) { return false; }
  if ( stream.Read( cfg.m_PreprocessorDefinitions ) == false ) { return false; }
  if ( stream.Read( cfg.m_IncludeSearchPath ) == false ) { return false; }
  if ( stream.Read( cfg.m_ForcedIncludes ) == false ) { return false; }
  if ( stream.Read( cfg.m_AssemblySearchPath ) == false ) { return false; }
  if ( stream.Read( cfg.m_ForcedUsingAssemblies ) == false ) { return false; }
  if ( stream.Read( cfg.m_AdditionalOptions ) == false ) { return false; }
  if ( stream.Read( cfg.m_OutputDirectory ) == false ) { return false; }
  if ( stream.Read( cfg.m_IntermediateDirectory ) == false ) { return false; }
  if ( stream.Read( cfg.m_LayoutDir ) == false ) { return false; }
  if ( stream.Read( cfg.m_LayoutExtensionFilter ) == false ) { return false; }
  if ( stream.Read( cfg.m_Xbox360DebuggerCommand ) == false ) { return false; }
  if ( stream.Read( cfg.m_DebuggerFlavor ) == false ) { return false; }
  if ( stream.Read( cfg.m_AumidOverride ) == false ) { return false; }
  if ( stream.Read( cfg.m_PlatformToolset ) == false ) { return false; }
  if ( stream.Read( cfg.m_DeploymentType ) == false ) { return false; }
  if ( stream.Read( cfg.m_DeploymentFiles ) == false ) { return false; }

  if ( stream.Read( cfg.m_LocalDebuggerCommandArguments ) == false ) { return false; }
  if ( stream.Read( cfg.m_LocalDebuggerWorkingDirectory ) == false ) { return false; }
  if ( stream.Read( cfg.m_LocalDebuggerCommand ) == false ) { return false; }
  if ( stream.Read( cfg.m_LocalDebuggerEnvironment ) == false ) { return false; }
 }
 return true;
}



           void VSProjectFileType::Save( IOStream & stream, const Array< VSProjectFileType > & fileTypes )
{
 uint32_t numFileTypes = (uint32_t)fileTypes.GetSize();
 stream.Write( numFileTypes );
 for ( uint32_t i=0; i<numFileTypes; ++i )
 {
  const VSProjectFileType & ft = fileTypes[ i ];

  stream.Write( ft.m_FileType );
  stream.Write( ft.m_Pattern );
 }
}



           bool VSProjectFileType::Load( IOStream & stream, Array< VSProjectFileType > & fileTypes )
{
 do { if ( !( fileTypes.IsEmpty() ) ) { if ( AssertHandler::Failure( "fileTypes.IsEmpty()", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Helpers/VSProjectGenerator.cpp", 565 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;

 uint32_t numFileTypes( 0 );
 if ( !stream.Read( numFileTypes ) )
 {
  return false;
 }
 fileTypes.SetSize( numFileTypes );
 for ( uint32_t i=0; i<numFileTypes; ++i )
 {
  VSProjectFileType & ft = fileTypes[ i ];

  if ( stream.Read( ft.m_FileType ) == false ) { return false; }
  if ( stream.Read( ft.m_Pattern ) == false ) { return false; }
 }
 return true;
}
# 17 "/home/ffulin/p4/tmp/Unity/Tools/FBuild/FBuildCore/Unity1.cpp" 2


# 1 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Helpers/Args.cpp" 1





# 1 "./Tools/FBuild/FBuildCore/PrecompiledHeader.h" 1
# 7 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Helpers/Args.cpp" 2

# 1 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Helpers/Args.h" 1


       





class AString;






class Args
{
public:

 static void StripQuotes( const char * start, const char * end, AString & out );

private:
};
# 9 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Helpers/Args.cpp" 2






           void Args::StripQuotes( const char * start, const char * end, AString & out )
{
 do { if ( !( start ) ) { if ( AssertHandler::Failure( "start", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Helpers/Args.cpp", 17 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;
 do { if ( !( end ) ) { if ( AssertHandler::Failure( "end", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Helpers/Args.cpp", 18 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;


 if ( start == end )
 {
  out.Clear();
  return;
 }


 const char firstChar = *start;
 if ( ( firstChar == '"' ) || ( firstChar == '\'' ) )
 {
  ++start;
 }


 const char lastChar = *( end - 1 );
 if ( ( lastChar == '"' ) || ( lastChar == '\'' ) )
 {
  --end;
 }


 if ( end < start )
 {
  out.Clear();
  return;
 }


 out.Assign( start, end );
}
# 20 "/home/ffulin/p4/tmp/Unity/Tools/FBuild/FBuildCore/Unity1.cpp" 2


# 1 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Helpers/Compressor.cpp" 1





# 1 "./Tools/FBuild/FBuildCore/PrecompiledHeader.h" 1
# 7 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Helpers/Compressor.cpp" 2

# 1 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Helpers/Compressor.h" 1


       
# 13 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Helpers/Compressor.h"
class Compressor
{
public:
 explicit Compressor();
 ~Compressor();

 bool IsValidData( const void * data, size_t dataSize ) const;

 bool Compress( const void * data, size_t dataSize );
 void Decompress( const void * data );

 const void * GetResult() const { return m_Result; }
 size_t GetResultSize() const { return m_ResultSize; }

 inline void * ReleaseResult() { void * r = m_Result; m_Result = (0); m_ResultSize = 0; return r; }

private:
 struct Header
 {
  uint32_t m_CompressionType;
  uint32_t m_UncompressedSize;
  uint32_t m_CompressedSize;
 };
 void * m_Result;
 size_t m_ResultSize;
};
# 9 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Helpers/Compressor.cpp" 2







# 1 "../External/LZ4/lz4-r127/lz4.h" 1
# 34 "../External/LZ4/lz4-r127/lz4.h"
       


extern "C" {
# 53 "../External/LZ4/lz4-r127/lz4.h"
int LZ4_versionNumber (void);
# 72 "../External/LZ4/lz4-r127/lz4.h"
int LZ4_compress (const char* source, char* dest, int sourceSize);
int LZ4_decompress_safe (const char* source, char* dest, int compressedSize, int maxDecompressedSize);
# 113 "../External/LZ4/lz4-r127/lz4.h"
int LZ4_compressBound(int isize);
# 128 "../External/LZ4/lz4-r127/lz4.h"
int LZ4_compress_limitedOutput (const char* source, char* dest, int sourceSize, int maxOutputSize);
# 137 "../External/LZ4/lz4-r127/lz4.h"
int LZ4_sizeofState(void);
int LZ4_compress_withState (void* state, const char* source, char* dest, int inputSize);
int LZ4_compress_limitedOutput_withState (void* state, const char* source, char* dest, int inputSize, int maxOutputSize);
# 153 "../External/LZ4/lz4-r127/lz4.h"
int LZ4_decompress_fast (const char* source, char* dest, int originalSize);
# 168 "../External/LZ4/lz4-r127/lz4.h"
int LZ4_decompress_safe_partial (const char* source, char* dest, int compressedSize, int targetOutputSize, int maxDecompressedSize);
# 184 "../External/LZ4/lz4-r127/lz4.h"
typedef struct { long long table[((1 << (14 -3)) + 4)]; } LZ4_stream_t;





void LZ4_resetStream (LZ4_stream_t* LZ4_streamPtr);







LZ4_stream_t* LZ4_createStream(void);
int LZ4_freeStream (LZ4_stream_t* LZ4_streamPtr);
# 208 "../External/LZ4/lz4-r127/lz4.h"
int LZ4_loadDict (LZ4_stream_t* LZ4_streamPtr, const char* dictionary, int dictSize);






int LZ4_compress_continue (LZ4_stream_t* LZ4_streamPtr, const char* source, char* dest, int inputSize);






int LZ4_compress_limitedOutput_continue (LZ4_stream_t* LZ4_streamPtr, const char* source, char* dest, int inputSize, int maxOutputSize);
# 233 "../External/LZ4/lz4-r127/lz4.h"
int LZ4_saveDict (LZ4_stream_t* LZ4_streamPtr, char* safeBuffer, int dictSize);
# 242 "../External/LZ4/lz4-r127/lz4.h"
typedef struct { unsigned long long table[4]; } LZ4_streamDecode_t;
# 253 "../External/LZ4/lz4-r127/lz4.h"
LZ4_streamDecode_t* LZ4_createStreamDecode(void);
int LZ4_freeStreamDecode (LZ4_streamDecode_t* LZ4_stream);







int LZ4_setStreamDecode (LZ4_streamDecode_t* LZ4_streamDecode, const char* dictionary, int dictSize);
# 271 "../External/LZ4/lz4-r127/lz4.h"
int LZ4_decompress_safe_continue (LZ4_streamDecode_t* LZ4_streamDecode, const char* source, char* dest, int compressedSize, int maxDecompressedSize);
int LZ4_decompress_fast_continue (LZ4_streamDecode_t* LZ4_streamDecode, const char* source, char* dest, int originalSize);
# 282 "../External/LZ4/lz4-r127/lz4.h"
int LZ4_decompress_safe_usingDict (const char* source, char* dest, int compressedSize, int maxDecompressedSize, const char* dictStart, int dictSize);
int LZ4_decompress_fast_usingDict (const char* source, char* dest, int originalSize, const char* dictStart, int dictSize);
# 303 "../External/LZ4/lz4-r127/lz4.h"
void* LZ4_create (const char* inputBuffer);
int LZ4_sizeofStreamState(void);
int LZ4_resetStreamState(void* state, const char* inputBuffer);
char* LZ4_slideInputBuffer (void* state);


int LZ4_decompress_safe_withPrefix64k (const char* source, char* dest, int compressedSize, int maxOutputSize);
int LZ4_decompress_fast_withPrefix64k (const char* source, char* dest, int originalSize);



}
# 17 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Helpers/Compressor.cpp" 2




Compressor::Compressor()
 : m_Result( (0) )
 , m_ResultSize( 0 )
{
}



Compressor::~Compressor()
{
 ::Free( m_Result );
}



bool Compressor::IsValidData( const void * data, size_t dataSize ) const
{
 const Header * header = (const Header *)data;
 if ( header->m_CompressionType > 1 )
 {
  return false;
 }
 if ( ( header->m_CompressedSize + sizeof( Header ) ) != dataSize )
 {
  return false;
 }
 if ( header->m_CompressedSize > header->m_UncompressedSize )
 {
  return false;
 }
 return true;
}



bool Compressor::Compress( const void * data, size_t dataSize )
{
 do { if ( !( data ) ) { if ( AssertHandler::Failure( "data", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Helpers/Compressor.cpp", 58 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;
 do { if ( !( ( (size_t)data % 4 ) == 0 ) ) { if ( AssertHandler::Failure( "( (size_t)data % 4 ) == 0", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Helpers/Compressor.cpp", 59 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;
 do { if ( !( m_Result == (0) ) ) { if ( AssertHandler::Failure( "m_Result == nullptr", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Helpers/Compressor.cpp", 60 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;


 const int worstCaseSize = LZ4_compressBound( (int)dataSize );
 AutoPtr< char > output( (char *)::AllocFileLine( worstCaseSize, "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Helpers/Compressor.cpp", 64 ) );


 const int compressedSize = LZ4_compress( (const char*)data, output.Get(), (int)dataSize);


 const bool compressed = ( compressedSize < (int)dataSize );

 if ( compressed )
 {

  m_Result = ::AllocFileLine( compressedSize + sizeof( Header ), "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Helpers/Compressor.cpp", 75 );
  memcpy( (char *)m_Result + sizeof( Header ), output.Get(), compressedSize );
  m_ResultSize = compressedSize + sizeof( Header );
 }
 else
 {

  m_Result = ::AllocFileLine( dataSize + sizeof( Header ), "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Helpers/Compressor.cpp", 82 );
  memcpy( (char *)m_Result + sizeof( Header ), data, dataSize );
  m_ResultSize = dataSize + sizeof( Header );
 }


 Header * header = (Header*)m_Result;
 header->m_CompressionType = compressed ? 1 : 0;
 header->m_UncompressedSize = (uint32_t)dataSize;
 header->m_CompressedSize = compressed ? compressedSize : (uint32_t)dataSize;

 return compressed;
}



void Compressor::Decompress( const void * data )
{
 do { if ( !( data ) ) { if ( AssertHandler::Failure( "data", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Helpers/Compressor.cpp", 100 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;
 do { if ( !( ( (size_t)data % 4 ) == 0 ) ) { if ( AssertHandler::Failure( "( (size_t)data % 4 ) == 0", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Helpers/Compressor.cpp", 101 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;
 do { if ( !( m_Result == (0) ) ) { if ( AssertHandler::Failure( "m_Result == nullptr", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Helpers/Compressor.cpp", 102 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;

 const Header * header = (const Header *)data;


 if ( header->m_CompressionType == 0 )
 {
  m_Result = ::AllocFileLine( header->m_UncompressedSize, "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Helpers/Compressor.cpp", 109 );
  memcpy( m_Result, (char *)data + sizeof( Header ), header->m_UncompressedSize );
  m_ResultSize = header->m_UncompressedSize;
  return;
 }
 do { if ( !( header->m_CompressionType == 1 ) ) { if ( AssertHandler::Failure( "header->m_CompressionType == 1", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Helpers/Compressor.cpp", 114 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;


 const uint32_t uncompressedSize = header->m_UncompressedSize;
 m_Result = ::AllocFileLine( uncompressedSize, "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Helpers/Compressor.cpp", 118 );
 m_ResultSize = uncompressedSize;


 const char * compressedData = ( (const char *)data + sizeof( Header ) );


 const int compressedSize = LZ4_decompress_fast( compressedData, (char *)m_Result, (int)uncompressedSize);
 do { if ( !( compressedSize == (int)header->m_CompressedSize ) ) { if ( AssertHandler::Failure( "compressedSize == (int)header->m_CompressedSize", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Helpers/Compressor.cpp", 126 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ; (void)compressedSize;
}
# 23 "/home/ffulin/p4/tmp/Unity/Tools/FBuild/FBuildCore/Unity1.cpp" 2


# 1 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Helpers/Report.cpp" 1





# 1 "./Tools/FBuild/FBuildCore/PrecompiledHeader.h" 1
# 7 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Helpers/Report.cpp" 2





# 1 "./Tools/FBuild/FBuildCore/FBuildVersion.h" 1


       
# 13 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Helpers/Report.cpp" 2
# 1 "./Tools/FBuild/FBuildCore/Graph/ObjectNode.h" 1


       
# 13 "./Tools/FBuild/FBuildCore/Graph/ObjectNode.h"
# 1 "./Core/Process/Process.h" 1


       
# 14 "./Core/Process/Process.h"
class Process
{
public:
 Process();
 ~Process();

 bool Spawn( const char * executable,
    const char * args,
    const char * workingDir,
    const char * environment,
    bool shareHandles = false );
 bool IsRunning() const;
 int WaitForExit();
 void Detach();



 void ReadAllData( AutoPtr< char > & memOut, uint32_t * memOutSize,
       AutoPtr< char > & errOut, uint32_t * errOutSize );
# 48 "./Core/Process/Process.h"
 static uint32_t GetCurrentId();
private:





        void Read( int handle, AutoPtr< char > & buffer, uint32_t & sizeSoFar, uint32_t & bufferSize );
# 72 "./Core/Process/Process.h"
 bool m_Started;
# 86 "./Core/Process/Process.h"
        int m_ChildPID;
        mutable bool m_HasAlreadyWaitTerminated;
        mutable int m_ReturnStatus;
        int m_StdOutRead;
        int m_StdErrRead;

};
# 14 "./Tools/FBuild/FBuildCore/Graph/ObjectNode.h" 2



class NodeProxy;



class ObjectNode : public FileNode
{
public:
 explicit ObjectNode( const AString & objectName,
       Node * inputNode,
       Node * compilerNode,
       const AString & compilerArgs,
       const AString & compilerArgsDeoptimized,
       Node * precompiledHeader,
       uint32_t flags,
       const Dependencies & compilerForceUsing,
       bool deoptimizeWritableFiles,
       bool deoptimizeWritableFilesWithToken );

 explicit ObjectNode( const AString & objectName,
       NodeProxy * srcFile,
       const AString & compilerArgs,
       uint32_t flags );
 virtual ~ObjectNode();

 static inline Node::Type GetType() { return Node::OBJECT_NODE; }


 enum Flags
 {
  FLAG_CAN_BE_CACHED = 0x01,
  FLAG_CAN_BE_DISTRIBUTED = 0x02,
  FLAG_USING_PCH = 0x04,
  FLAG_GCC = 0x10,
  FLAG_MSVC = 0x20,
  FLAG_CREATING_PCH = 0x40,
  FLAG_SNC = 0x80,
  FLAG_USING_CLR = 0x100,
  FLAG_CLANG = 0x200,
  FLAG_UNITY = 0x400,
  FLAG_ISOLATED_FROM_UNITY= 0x800,
  FLAG_USING_PDB = 0x1000,
  CODEWARRIOR_WII = 0x2000,
  GREENHILLS_WIIU = 0x4000,
  FLAG_CUDA_NVCC = 0x10000,
 };
 static uint32_t DetermineFlags( const Node * compilerNode, const AString & args );

 inline bool IsCreatingPCH() const { return GetFlag( FLAG_CREATING_PCH ); }
 inline bool IsMSVC() const { return GetFlag( FLAG_MSVC ); }
 inline bool IsUsingPDB() const { return GetFlag( FLAG_USING_PDB ); }

 virtual void Save( IOStream & stream ) const;
 static Node * Load( IOStream & stream );

 virtual void SaveRemote( IOStream & stream ) const;
 static Node * LoadRemote( IOStream & stream );

 inline Node * GetCompiler() const { return m_StaticDependencies[ 0 ].GetNode(); }
 inline Node * GetSourceFile() const { return m_StaticDependencies[ 1 ].GetNode(); }
 inline Node * GetPrecompiledHeaderCPPFile() const { do { if ( !( GetFlag( FLAG_CREATING_PCH ) ) ) { if ( AssertHandler::Failure( "GetFlag( FLAG_CREATING_PCH )", "./Tools/FBuild/FBuildCore/Graph/ObjectNode.h", 76 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ; return m_StaticDependencies[ 1 ].GetNode(); }

 void GetPDBName( AString & pdbName ) const;

 virtual Priority GetPriority() const override;

 const char * GetObjExtension() const;
private:
 virtual BuildResult DoBuild( Job * job );
 virtual BuildResult DoBuild2( Job * job, bool racingRemoteJob );
 virtual bool Finalize();

 BuildResult DoBuildMSCL_NoCache( Job * job, bool useDeoptimization );
 BuildResult DoBuildWithPreProcessor( Job * job, bool useDeoptimization, bool useCache );
 BuildResult DoBuildWithPreProcessor2( Job * job, bool useDeoptimization, bool stealingRemoteJob, bool racingRemoteJob );
 BuildResult DoBuildOther( Job * job, bool useDeoptimization );

 bool ProcessIncludesMSCL( const char * output, uint32_t outputSize );
 bool ProcessIncludesWithPreProcessor( Job * job );

 const AString & GetCacheName( Job * job ) const;
 bool RetrieveFromCache( Job * job );
 void WriteToCache( Job * job );

 static void DumpOutput( Job * job, const char * data, uint32_t dataSize, const AString & name );

 void EmitCompilationMessage( const AString & fullArgs, bool useDeoptimization, bool stealingRemoteJob = false, bool racingRemoteJob = false ) const;

 enum Pass
 {
  PASS_PREPROCESSOR_ONLY,
  PASS_COMPILE_PREPROCESSED,
  PASS_COMPILE
 };
 static bool StripTokenWithArg( const char * tokenToCheckFor, const AString & token, size_t & index );
 static bool StripToken( const char * tokenToCheckFor, const AString & token, bool allowStartsWith = false );
 void BuildFullArgs( const Job * job, AString & fullArgs, Pass pass, bool useDeoptimization ) const;

 void ExpandTokenList( const Dependencies & nodes, AString & fullArgs, const AString & pre, const AString & post ) const;
 bool BuildPreprocessedOutput( const AString & fullArgs, Job * job, bool useDeoptimization ) const;
 bool WriteTmpFile( Job * job, AString & tmpFileName ) const;
 bool BuildFinalOutput( Job * job, const AString & fullArgs ) const;

 inline bool GetFlag( uint32_t flag ) const { return ( ( m_Flags & flag ) != 0 ); }

 static void HandleSystemFailures( Job * job, int result, const char * stdOut, const char * stdErr );
 bool ShouldUseDeoptimization() const;
 friend class Client;
 bool ShouldUseCache() const;

 class CompileHelper
 {
 public:
  CompileHelper( bool handleOutput = true );
  ~CompileHelper();


  bool SpawnCompiler( Job * job, const AString & name, const AString & compiler, const AString & fullArgs, bool useResponseFile, const char * workingDir = (0) );


  inline int GetResult() const { return m_Result; }


  inline const AutoPtr< char > & GetOut() const { return m_Out; }
  inline uint32_t GetOutSize() const { return m_OutSize; }
  inline const AutoPtr< char > & GetErr() const { return m_Err; }
  inline uint32_t GetErrSize() const { return m_ErrSize; }

 private:
  bool m_HandleOutput;
  Process m_Process;
  AutoPtr< char > m_Out;
  uint32_t m_OutSize;
  AutoPtr< char > m_Err;
  uint32_t m_ErrSize;
  int m_Result;
 };

 Array< AString > m_Includes;
 uint32_t m_Flags;
 AString m_CompilerArgs;
 AString m_CompilerArgsDeoptimized;
 AString m_ObjExtensionOverride;
 Dependencies m_CompilerForceUsing;
 bool m_DeoptimizeWritableFiles;
 bool m_DeoptimizeWritableFilesWithToken;
 bool m_Remote;
};
# 14 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Helpers/Report.cpp" 2
# 30 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Helpers/Report.cpp"
uint32_t g_ReportNodeColors[] = { 0x000000,
          0xFFFFFF,
          0xAAAAAA,
          0x000000,
          0x888888,
          0x88FF88,
          0xFF8888,
          0x228B22,
          0xFFFF88,
          0x88AAFF,
          0x88CCFF,
          0xFFAAFF,
          0xDDA0DD,
          0xFFCC88,
          0xFFFFFF,
          0x444444,
          0x000000 };



Report::Report()
 : m_LibraryStats( 512, true )
 , m_NumPieCharts( 0 )
{

 do { compile_time_assert_failure< ( sizeof( g_ReportNodeColors ) / sizeof (uint32_t) == Node::NUM_NODE_TYPES ) > (); } while ( false ); ;
}



Report::~Report()
{
 const LibraryStats * const * end = m_LibraryStats.End();
 for ( LibraryStats ** it=m_LibraryStats.Begin(); it != end; ++it )
 {
  delete *it;
 }
}



void Report::Generate( const FBuildStats & stats )
{
 Timer t;


 m_Output.SetReserved( (1024 * 1024) );
 m_Output.SetLength( 0 );


 GetLibraryStats( stats );


 CreateHeader();

 CreateTitle();

 CreateOverview( stats );

 DoCPUTimeByType( stats );
 DoCacheStats( stats );
 DoCPUTimeByLibrary();
 DoCPUTimeByItem( stats );

 DoIncludes();

 CreateFooter();


 const float time = t.GetElapsed();
 AStackString<> timeTakenBuffer;
 stats.FormatTime( time, timeTakenBuffer );
 char * placeholder = m_Output.Find( "^^^^    " );
 memcpy( placeholder, timeTakenBuffer.Get(), timeTakenBuffer.GetLength() );

}



void Report::Save() const
{
 FileStream f;
 if ( f.Open( "report.html", FileStream::WRITE_ONLY ) )
 {
  f.Write( m_Output.Get(), m_Output.GetLength() );
 }
}



void Report::CreateHeader()
{
 const char * header =
  "<!doctype html>\n"
  "<style type=\"text/css\">\n"
  "body{\n"
  "font-family:arial;\n"
  "width:1000px;\n"
  "margin:0 auto;\n"
  "font-size:13px\n"
  "}\n"
  "th{\n"
  "background-color:#e0e0e0;\n"
  "padding:4px;\n"
  "height:15px;\n"
  "text-align:left;\n"
  "border-top-left-radius:5px;\n"
  "-moz-border-radius-topleft:5px;\n"
  "border-top-right-radius:5px;\n"
  "-moz-border-radius-topright:5px;\n"
  "font-weight:bold;\n"
  "}\n"
  "tr:nth-child(odd){\n"
  "background-color:#f0f0f0;\n"
  "}\n"
  "h1{\n"
  "background-color:#b0b0b0;\n"
  "border-radius:5px;\n"
  "padding:4px;\n"
  "height:40px;\n"
  "text-align:left;\n"
  "font-weight:bold;\n"
  "}\n"
  "h2{\n"
  "background-color:#d0d0d0;\n"
  "border-radius:5px;\n"
  "padding:4px;\n"
  "height:27px;\n"
  "text-align:left;\n"
  "font-weight:bold;\n"
  "}\n"
  "table{\n"
  "  padding-left:10px;\n"
  "}\n"
  "td\n"
  "word-break:break-all;\n"
  "padding:3px;\n"
  "}\n"
  ".perc{\n"
  "color:#aaaaaa;\n"
  "font-size:10px\n"
  "}\n"
  "</style>\n"

  "<html>\n"
  "<head>\n"
  "<meta charset=\"UTF-8\" />\n"
  "<title>FASTBuild Report</title>\n"
  "</head>\n"
  "<body>\n"
  "<script type=\"text/javascript\">\n"
  "function getTotal(data)\n"
  "{\n"
  " var total = 0;\n"
  " for (var j = 0; j < data.length; j++)\n"
  " {\n"
  "  total += (typeof data[j] == 'number') ? data[j] : 0;\n"
  " }\n"
  " return total;\n"
  "}\n"
  "function plotData(canvasName,myData,myLabels,myColor, units)\n"
  "{\n"
  " var canvas;\n"
  " var ctx;\n"
  " var lastend = 0;\n"
  " var myTotal = getTotal(myData);\n"

  " canvas = document.getElementById(canvasName);\n"
  " ctx = canvas.getContext(\"2d\");\n"
  " ctx.clearRect(0, 0, canvas.width, canvas.height);\n"

  " ctx.fillStyle = \"black\";\n"
  " ctx.beginPath();\n"
  " ctx.moveTo(70,70);\n"
  " ctx.arc(70,70,66,0,(Math.PI*2),false);\n"
  " ctx.lineTo(70,70);\n"
  " ctx.fill();\n"

  " for (var i = 0; i < myData.length; i++)\n"
  " {\n"
  "  ctx.fillStyle = myColor[i];\n"
  "  ctx.beginPath();\n"
  "  ctx.moveTo(70,70);\n"
  "  ctx.arc(70,70,65,lastend,lastend+(Math.PI*2*(myData[i]/myTotal)),false);\n"
  "  ctx.lineTo(70,70);\n"
  "  ctx.fill();\n"
  "  lastend += Math.PI*2*(myData[i]/myTotal);\n"
  " }\n"


  " for (var i = 0; i < myData.length; i++)\n"
  " {\n"
  "  var y = 20 + ( i * 25 );\n"


  "  ctx.fillStyle=\"#888888\";\n"
  "  ctx.fillRect(200-1,y-15-1,22,22)\n"
  "  ctx.fillStyle=myColor[ i ];\n"
  "  ctx.fillRect(200,y-15,20,20)\n"


  "  ctx.fillStyle = \"black\";\n"
  "  ctx.font = \"16px Arial\";\n"
  "  ctx.fillText(myLabels[ i ], 230, y );\n"


  "  var perc = ( 100.0 * myData[ i ] / myTotal ).toFixed(1);\n"
  "  ctx.fillText( perc + \"% (\" + myData[ i ] + units + \")\", 330, y );\n"
  " }\n"
  "}\n"


  "function toggleTable(tableName)\n"
  "{\n"
  " var table = document.getElementById(tableName);\n"
  " table.style.display = (table.style.display == \"table\") ? \"none\" : \"table\";\n"
  "}\n"

  "</script>\n";
 m_Output += header;
}



void Report::CreateTitle()
{

 Write( "<h1>FASTBuild Report</h1>\n" );
}



void Report::CreateOverview( const FBuildStats & stats )
{
 DoSectionTitle( "Overview", "overview" );

 AStackString<> buffer;

 DoTableStart();


 Write( "<tr><th width=150>Item</th><th>Details</th></tr>\n" );


 const char * commandLine = Env::GetCmdLine();
 const char * exeExtension = strstr( commandLine, ".exe\"" );
 commandLine = exeExtension ? ( exeExtension + 5 ) : commandLine;
 Write( "<tr><td width=80>Cmd Line Options</td><td>%s</td></tr>", commandLine );


 AStackString<> targets;
 const Node * rootNode = stats.GetRootNode();
 if (rootNode->GetType() != Node::PROXY_NODE)
 {
  targets = rootNode->GetName();
 }
 else
 {
  const Dependencies & childNodes = rootNode->GetStaticDependencies();
  size_t num = childNodes.GetSize();
  for ( size_t i=0; i<num; ++i )
  {
   if ( i != 0 )
   {
    targets += ", ";
   }
   const Node * child = childNodes[ i ].GetNode();
   targets += child->GetName();
  }
 }
 Write( "<tr><td>Target(s)</td><td>%s</td></tr>\n", targets.Get() );


 const bool buildOK = ( stats.GetRootNode()->GetState() == Node::UP_TO_DATE );
 Write( "<tr><td>Result</td><td>%s</td></tr>\n", buildOK ? "OK" : "FAILED" );


 float totalBuildTime = stats.m_TotalBuildTime;
 stats.FormatTime( totalBuildTime, buffer );
 Write( "<tr><td>Time</td><td>%s</td></tr>\n", buffer.Get() );


 float totalLocalCPUInSeconds = (float)( (double)stats.m_TotalLocalCPUTimeMS / (double)1000 );
 stats.FormatTime( totalLocalCPUInSeconds, buffer );
 float localRatio = ( totalLocalCPUInSeconds / totalBuildTime );
 Write( "<tr><td>CPU Time</td><td>%s (%2.1f:1)</td></tr>\n", buffer.Get(), localRatio );


 Write( "<tr><td>Version</td><td>%s %s</td></tr>\n", "v0.80", "x64" );


 char timeBuffer[ 256 ];
# 332 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Helpers/Report.cpp"
  timeBuffer[ 0 ] = '\000';




 char dateBuffer[ 256 ];
# 348 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Helpers/Report.cpp"
  dateBuffer[ 0 ] = '\000';





 Write( "<tr><td>Report Generated</td><td>^^^^                         - %s %s</td></tr>\n", dateBuffer, timeBuffer );

 DoTableStop();
}



void Report::DoCacheStats( const FBuildStats & stats )
{
 (void)stats;

 DoSectionTitle( "Cache Stats", "cacheStats" );

 const FBuildOptions & options = FBuild::Get().GetOptions();
 if ( options.m_UseCacheRead || options.m_UseCacheWrite )
 {

  uint32_t totalOutOfDateItems( 0 );
  uint32_t totalCacheable( 0 );
  uint32_t totalCacheHits( 0 );
  const LibraryStats * const * end = m_LibraryStats.End();
  for ( LibraryStats ** it = m_LibraryStats.Begin(); it != end; ++it )
  {
   const LibraryStats & ls = *( *it );
   totalOutOfDateItems += ls.objectCount_OutOfDate;
   totalCacheable += ls.objectCount_Cacheable;
   totalCacheHits += ls.objectCount_CacheHits;
  }
  if ( totalOutOfDateItems == 0 )
  {
   Write( "No cacheable items were built.\n" );
   return;
  }
  uint32_t totalCacheMisses( totalCacheable - totalCacheHits );

  Array< PieItem > pieItems( 3, false );
  pieItems.Append(PieItem("Uncacheable", (float)(totalOutOfDateItems - totalCacheable), 0xFF8888));
  pieItems.Append(PieItem("Cache Miss", (float)totalCacheMisses, 0xFFCC88));
  pieItems.Append(PieItem("Cache Hit", (float)totalCacheHits, 0x88FF88));
  DoPieChart(pieItems, "");

  DoTableStart();


  Write( "<tr><th>Library</th><th style=\"width:70px;\">Items</th><th style=\"width:90px;\">Out-of-Date</th><th style=\"width:90px;\">Cacheable</th><th style=\"width:70px;\">Hits</th><th style=\"width:70px;\">Misses</th><th style=\"width:60px;\">Stores</th></tr>\n" );

  size_t numOutput( 0 );


  for ( LibraryStats ** it = m_LibraryStats.Begin(); it != end; ++it )
  {
   const LibraryStats & ls = *( *it );
   const char * libraryName = ls.library->GetName().Get();


   const uint32_t items = ls.objectCount;


   const uint32_t outOfDateItems = ls.objectCount_OutOfDate;
   const float outOfDateItemsPerc = ( (float)outOfDateItems / (float)items ) * 100.0f;


   const uint32_t cItems = ls.objectCount_Cacheable;
   const float cItemsPerc = ( (float)cItems / (float)outOfDateItems ) * 100.0f;


   const uint32_t cHits = ls.objectCount_CacheHits;
   const float cHitsPerc = ( cItems > 0 ) ? ( (float)cHits / (float)cItems ) * 100.0f : 0.0f;


   const uint32_t cMisses = ( cItems - cHits );
   const float cMissesPerc = ( cMisses > 0 ) ? 100.0f - cHitsPerc : 0.0f;


   const uint32_t cStores = ls.objectCount_CacheStores;


   if ( outOfDateItems == 0 )
   {
    continue;
   }


   if ( numOutput == 10 )
   {
    DoToggleSection();
   }

   Write( ( numOutput == 10 ) ? "<tr></tr><tr><td>%s</td><td style=\"width:70px;\">%u</td><td style=\"width:90px;\">%u <font class='perc'>(%2.1f%%)</font></td><td style=\"width:90px;\">%u <font class='perc'>(%2.1f%%)</font></td><td style=\"width:70px;\">%u <font class='perc'>(%2.1f%%)</font></td><td style=\"width:70px;\">%u <font class='perc'>(%2.1f%%)</font></td><td style=\"width:60px;\">%u</td></tr>\n"
            : "<tr><td>%s</td><td>%u</td><td>%u <font class='perc'>(%2.1f%%)</font></td><td>%u <font class='perc'>(%2.1f%%)</font></td><td>%u <font class='perc'>(%2.1f%%)</font></td><td>%u <font class='perc'>(%2.1f%%)</font></td><td>%u</td></tr>\n",
      libraryName,
      items,
      outOfDateItems, outOfDateItemsPerc,
      cItems, cItemsPerc,
      cHits, cHitsPerc,
      cMisses, cMissesPerc,
      cStores );
   numOutput++;
  }

  DoTableStop();

  if ( numOutput > 10 )
  {
   Write( "</details>\n" );
  }
 }
 else
 {
  Write( "Cache not used.\n" );
 }
}



void Report::DoCPUTimeByType( const FBuildStats & stats )
{
 DoSectionTitle( "CPU Time by Node Type", "cpuTimeByNodeType" );


 Array< PieItem > items( 32, true );

 for ( size_t i=0; i < (size_t)Node::NUM_NODE_TYPES; ++i )
 {
  const FBuildStats::Stats & nodeStats = stats.GetStatsFor( (Node::Type)i );
  if ( nodeStats.m_NumProcessed == 0 )
  {
   continue;
  }


  const char * typeName = Node::GetTypeName( Node::Type( i ) );
  const float value = (float)( (double)nodeStats.m_ProcessingTimeMS / (double)1000 );
  const uint32_t color = g_ReportNodeColors[ i ];

  PieItem item( typeName, value, color, (void *)i );
  items.Append( item );
 }

 items.Sort();


 DoPieChart( items, " s" );


 DoTableStart();
 Write( "<tr><th width=80>Type</th><th width=80>Time</th><th width=80>Processed</th><th width=80>Built</th><th width=80>Cache Hits</th></tr>\n" );
 for ( size_t i=0; i < items.GetSize(); ++i )
 {
  Node::Type type = (Node::Type)(size_t)items[ i ].userData;
  const FBuildStats::Stats & nodeStats = stats.GetStatsFor( type );
  if ( nodeStats.m_NumProcessed == 0 )
  {
   continue;
  }

  const char * typeName = Node::GetTypeName( type );
  const float value = (float)( (double)nodeStats.m_ProcessingTimeMS / (double)1000 );
  const uint32_t processed = nodeStats.m_NumProcessed;
  const uint32_t built = nodeStats.m_NumBuilt;
  const uint32_t cacheHits = nodeStats.m_NumCacheHits;

  Write( "<tr><td>%s</td><td>%2.3fs</td><td>%u</td><td>%u</td>",
     typeName,
     value,
     processed,
     built,
     cacheHits );
  if ( type == Node::OBJECT_NODE )
  {

   Write( "<td>%u</td></tr>\n", cacheHits );
  }
  else
  {

   Write( "<td>-</td></tr>\n" );
  }
 }
 DoTableStop();
}



void Report::DoCPUTimeByItem( const FBuildStats & stats )
{
 DoSectionTitle( "CPU Time by Item", "cpuTimeByItem" );

 DoTableStart();


 Write( "<tr><th style=\"width:100px;\">Time</th><th style=\"width:100px;\">Type</th><th>Name</th></tr>\n" );

 size_t numOutput = 0;


 const Array< const Node * > & nodes = stats.GetNodesByTime();
 for ( const Node ** it = nodes.Begin();
    it != nodes.End();
    ++ it )
 {
  const Node * node = *it;
  float time = ( (float)node->GetProcessingTime() * 0.001f );
  const char * type = node->GetTypeName();
  const char * name = node->GetName().Get();


  if ( numOutput == 10 )
  {
   DoToggleSection( (uint32_t)nodes.GetSize() - 10 );
  }

  Write( ( numOutput == 10 ) ? "<tr></tr><tr><td style=\"width:100px;\">%2.3fs</td><td style=\"width:100px;\">%s</td><td>%s</td></tr>\n"
           : "<tr><td>%2.3fs</td><td>%s</td><td>%s</td></tr>\n", time, type, name );
  numOutput++;
 }

 DoTableStop();

 if ( numOutput > 10 )
 {
  Write( "</details>\n" );
 }
}



void Report::DoCPUTimeByLibrary()
{
 DoSectionTitle( "CPU Time by Library", "cpuTimeByLibrary" );

 DoTableStart();


 uint32_t total = 0;
 const LibraryStats * const * end = m_LibraryStats.End();
 for ( LibraryStats ** it = m_LibraryStats.Begin(); it != end; ++it )
 {
  total += ( *it )->cpuTimeMS;
 }
 if ( total == 0 )
 {
  Write( "No libraries built.\n" );
  return;
 }


 Write( "<tr><th style=\"width:80px;\">Time</th><th style=\"width:50px;\">%%</th><th style=\"width:70px;\">Obj Built</th><th style=\"width:50px;\">Type</th><th>Name</th></tr>\n" );

 const float totalS = (float)( (double)total * 0.001 );
 size_t numOutput( 0 );

 for ( LibraryStats ** it = m_LibraryStats.Begin(); it != end; ++it )
 {
  const LibraryStats & ls = *( *it );
  if ( ls.cpuTimeMS == 0 )
  {
   continue;
  }


  if ( numOutput == 10 )
  {
   DoToggleSection();
  }

  const uint32_t objCount = ls.objectCount_OutOfDate;
  const float time = ( (float)ls.cpuTimeMS * 0.001f );
  const float perc = (float)( (double)time / (double)totalS * 100 );
  const char * type = "??";
  switch ( ls.library->GetType() )
  {
   case Node::LIBRARY_NODE: type = "Static"; break;
   case Node::DLL_NODE: type = "DLL"; break;
   case Node::CS_NODE: type = "C# DLL"; break;
   default: do { if ( !( false ) ) { if ( AssertHandler::Failure( "false", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Helpers/Report.cpp", 629 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ; break;
  }
  const char * name = ls.library->GetName().Get();
  Write( ( numOutput == 10 ) ? "<tr></tr><tr><td style=\"width:80px;\">%2.3fs</td><td style=\"width:50px;\">%2.1f</td><td style=\"width:70px;\">%u</td><td style=\"width:50px;\">%s</td><td>%s</td></tr>\n"
           : "<tr><td>%2.3fs</td><td>%2.1f</td><td>%u</td><td>%s</td><td>%s</td></tr>\n",
          time, perc, objCount, type, name );
  numOutput++;
 }

 DoTableStop();

 if ( numOutput > 10 )
 {
  Write( "</details>\n" );
 }
}




void Report::DoIncludes()
{
 DoSectionTitle( "Includes", "includes" );

 size_t numLibsOutput = 0;


 const LibraryStats * const * end = m_LibraryStats.End();
 for ( LibraryStats ** it = m_LibraryStats.Begin(); it != end; ++it )
 {
  if ( ( *it )->objectCount_OutOfDate == 0 )
  {
   continue;
  }


  const Node * library = ( *it )->library;
  IncludeStatsMap incStatsMap;
  GetIncludeFilesRecurse( incStatsMap, library );


  Array< const IncludeStats * > incStats( 10 * 1024, true );
  incStatsMap.Flatten( incStats );
  incStats.SortDeref();

  Write( "<h3>%s</h3>\n", library->GetName().Get() );
  numLibsOutput++;

  if ( incStats.GetSize() == 0 )
  {
   Write( "No inludes.\n" );
   continue;
  }

  DoTableStart();
  Write( "<tr><th style=\"width:80px;\">Objects</th><th style=\"width:80px;\">Included</td><th style=\"width:60px;\">PCH</th><th>Name</th></tr>\n" );

  const uint32_t numObjects = ( *it )->objectCount;


  const size_t numIncludes = incStats.GetSize();
  size_t numOutput = 0;
  for ( size_t i=0; i<numIncludes; ++i )
  {
   const IncludeStats & s = *incStats[ i ];
   const char * fileName = s.node->GetName().Get();
   const uint32_t included = s.count;
   const bool inPCH = s.inPCH;


   if ( numOutput == 10 )
   {
    DoToggleSection( numIncludes - 10 );
   }

   Write( ( numOutput == 10 ) ? "<tr></tr><tr><td style=\"width:80px;\">%u</td><td style=\"width:80px;\">%u</td><td style=\"width:60px;\">%s</td><td>%s</td></tr>\n"
            : "<tr><td>%u</td><td>%u</td><td>%s</td><td>%s</td></tr>\n",
      numObjects,
      included,
      inPCH ? "YES" : "no",
      fileName );
   numOutput++;
  }

  DoTableStop();


  if ( numOutput > 10 )
  {
   Write( "</details>\n" );
  }
 }

 DoTableStop();

 if ( numLibsOutput == 0 )
 {
  Write( "No libraries built.\n" );
 }
}




void Report::DoPieChart( const Array< PieItem > & items, const char * units )
{
 AStackString<> buffer;

 uint32_t height = Math::Max< uint32_t >( 140, 40 + 25 * (uint32_t)items.GetSize() );

 m_NumPieCharts++;

 Write( "<section>\n" );
 Write( "<div>\n" );
 Write( "<canvas id=\"canvas%u\" width=\"500\" height=\"%u\">\n", m_NumPieCharts, height );
 Write( "HTML5 Canvas support required.\n" );
 Write( "</canvas>\n" );
 Write( "</div>\n" );

 Write( "<script type=\"text/javascript\">\n" );
 Write( "	var myData = [" );
 for ( size_t i=0; i<items.GetSize(); ++i )
 {
  if ( i > 0 )
  {
   Write( "," );
  }
  buffer.Format( "%2.3f", items[ i ].value );
  Write( buffer.Get() );
 }
 Write( "];\n" );
 Write( "	var myLabels = [" );
 for ( size_t i=0; i<items.GetSize(); ++i )
 {
  if ( i > 0 )
  {
   Write( "," );
  }
  Write( "\"%s\"", items[ i ].label );
 }
 Write( "];\n" );
 Write( "	var myColors = [" );
 for ( size_t i=0; i<items.GetSize(); ++i )
 {
  if ( i > 0 )
  {
   Write( "," );
  }
  Write( "\"#%x\"", items[ i ].color );
 }
 Write( "];\n" );

 Write( "	plotData(\"canvas%u\",myData,myLabels,myColors,\"%s\");\n", m_NumPieCharts, units );
 Write( "</script>\n" );
 Write( "</section>\n" );
}



void Report::CreateFooter()
{
 const char * footer =
  "<br><br><br>\n"
  "</body>\n"
  "</html>\n";
 m_Output += footer;
}



void Report::DoSectionTitle( const char * sectionName, const char * sectionId )
{
 Write( "<h2 id=\"%s\">%s</h2>\n", sectionId, sectionName );
}



void Report::DoTableStart( int width, const char * id, bool hidden )
{
 AStackString<> output;
 output.Format( "<table width=%u", width );
 if ( id )
 {
  output += " id=\"";
  output += id;
  output += "\"";
 }
 if ( hidden )
 {
  output += " style=\"display:none;\"";
 }
 output += ">\n";
 Write( output.Get() );
}



void Report::DoTableStop()
{
 Write( "</table>\n" );
}



void Report::DoToggleSection( size_t numMore )
{
 static int tableId = 0;
 ++tableId;
 AStackString<> tableIdStr;
 tableIdStr.Format( "table%u", tableId );

 DoTableStop();
 AStackString<> more;
 if ( numMore )
 {
  more.Format( "%u ", (uint32_t)numMore );
 }
 Write( "<a href='javascript:toggleTable(\"%s\");'>%sMore...</a>\n", tableIdStr.Get(), more.Get() );
 DoTableStart( DEFAULT_TABLE_WIDTH, tableIdStr.Get(), true );
}



void Report::Write( const char * fmtString, ... )
{
 AStackString< 1024 > tmp;

 va_list args;
 __builtin_va_start(args,fmtString);
 tmp.VFormat( fmtString, args );
 __builtin_va_end(args);


 if ( m_Output.GetLength() + tmp.GetLength() > m_Output.GetReserved() )
 {
  m_Output.SetReserved( m_Output.GetReserved() + (1024 * 1024) );
 }

 m_Output += tmp;
}



void Report::GetLibraryStats( const FBuildStats & stats )
{

 GetLibraryStatsRecurse( m_LibraryStats, stats.GetRootNode(), (0) );
 m_LibraryStats.SortDeref();
}



void Report::GetLibraryStatsRecurse( Array< LibraryStats * > & libStats, const Node * node, LibraryStats * currentLib ) const
{

 if ( node->GetStatFlag( Node::STATS_REPORT_PROCESSED ) )
 {
  return;
 }
 node->SetStatFlag( Node::STATS_REPORT_PROCESSED );

 Node::Type type = node->GetType();


 if ( type == Node::OBJECT_NODE )
 {
  if ( currentLib == (0) )
  {
   do { if ( !( false ) ) { if ( AssertHandler::Failure( "false", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Helpers/Report.cpp", 897 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;
   return;
  }

  currentLib->objectCount++;

  bool cacheHit = node->GetStatFlag( Node::STATS_CACHE_HIT );
  bool cacheMiss = node->GetStatFlag( Node::STATS_CACHE_MISS );
  if ( cacheHit || cacheMiss )
  {
   currentLib->objectCount_Cacheable++;

   if ( cacheHit )
   {
    currentLib->objectCount_CacheHits++;
   }
   if ( node->GetStatFlag( Node::STATS_CACHE_STORE ) )
   {
    currentLib->objectCount_CacheStores++;
   }
  }

  if ( cacheHit || cacheMiss || node->GetStatFlag( Node::STATS_BUILT ) )
  {
   currentLib->objectCount_OutOfDate++;
   currentLib->cpuTimeMS += node->GetProcessingTime();
  }

  return;
 }

 bool isLibrary = false;
 switch ( type )
 {
  case Node::DLL_NODE: isLibrary = true; break;
  case Node::LIBRARY_NODE: isLibrary = true; break;
  case Node::OBJECT_LIST_NODE: isLibrary = true; break;
  case Node::CS_NODE:
  {
   isLibrary = node->GetName().EndsWithI( ".dll" );
   break;
  }
  default: break;
 }

 if ( isLibrary )
 {
  currentLib = new ( "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Helpers/Report.cpp", 944 ) LibraryStats;
  currentLib->library = node;
  currentLib->cpuTimeMS = 0;
  currentLib->objectCount = 0;
  currentLib->objectCount_OutOfDate = 0;
  currentLib->objectCount_Cacheable = 0;
  currentLib->objectCount_CacheHits = 0;
  currentLib->objectCount_CacheStores = 0;


  if ( node->GetStatFlag( Node::STATS_BUILT ) )
  {
   currentLib->cpuTimeMS += node->GetProcessingTime();
  }

  libStats.Append( currentLib );


 }


 GetLibraryStatsRecurse( libStats, node->GetPreBuildDependencies(), currentLib );
 GetLibraryStatsRecurse( libStats, node->GetStaticDependencies(), currentLib );
 GetLibraryStatsRecurse( libStats, node->GetDynamicDependencies(), currentLib );
}



void Report::GetLibraryStatsRecurse( Array< LibraryStats * > & libStats, const Dependencies & dependencies, LibraryStats * currentLib ) const
{
 const Dependency * const end = dependencies.End();
 for ( const Dependency * it = dependencies.Begin(); it != end; ++it )
 {
  GetLibraryStatsRecurse( libStats, it->GetNode(), currentLib );
 }
}



void Report::GetIncludeFilesRecurse( IncludeStatsMap & incStats, const Node * node ) const
{
 Node::Type type = node->GetType();
 if ( type == Node::OBJECT_NODE )
 {

  const Dependencies & dynamicDeps = node->GetDynamicDependencies();
  const Dependency * const end = dynamicDeps.End();
  for ( const Dependency * it = dynamicDeps.Begin(); it != end; ++it )
  {
   AddInclude( incStats, it->GetNode(), node );
  }

  return;
 }


 const Dependencies & staticDeps = node->GetStaticDependencies();
 const Dependency * end = staticDeps.End();
 for ( const Dependency * it = staticDeps.Begin(); it != end; ++it )
 {
  GetIncludeFilesRecurse( incStats, it->GetNode() );
 }


 const Dependencies & dynamicDeps = node->GetDynamicDependencies();
 end = dynamicDeps.End();
 for ( const Dependency * it = dynamicDeps.Begin(); it != end; ++it )
 {
  GetIncludeFilesRecurse( incStats, it->GetNode() );
 }
}



void Report::AddInclude( IncludeStatsMap & incStats, const Node * node, const Node * parentNode ) const
{
 bool isHeaderInPCH = false;
 if ( parentNode->GetType() == Node::OBJECT_NODE )
 {
  const ObjectNode * obj = parentNode->CastTo< ObjectNode >();
  isHeaderInPCH = obj->IsCreatingPCH();
 }


 IncludeStats * stats = incStats.Find( node );
 if ( stats == (0) )
 {
  stats = incStats.Insert( node );
 }

 stats->count++;
 stats->inPCH |= isHeaderInPCH;
}



Report::IncludeStatsMap::IncludeStatsMap()
 : m_Pool( sizeof( IncludeStats ), __alignof( IncludeStats ) )
{
 memset( m_Table, 0, sizeof( m_Table ) );
}



Report::IncludeStatsMap::~IncludeStatsMap()
{
 for ( size_t i=0; i<65536; ++i )
 {
  IncludeStats * item = m_Table[ i ];
  while ( item )
  {
   IncludeStats * next = item->m_Next;
   m_Pool.Free( item );
   item = next;
  }
 }
}



Report::IncludeStats * Report::IncludeStatsMap::Find( const Node * node ) const
{

 uint32_t hash = node->GetNameCRC();
 uint32_t key = ( hash & 0xFFFF );
 IncludeStats * item = m_Table[ key ];


 while ( item )
 {
  if ( item->node == node )
  {
   return item;
  }
  item = item->m_Next;
 }


 return (0);
}



Report::IncludeStats * Report::IncludeStatsMap::Insert( const Node * node )
{

 uint32_t hash = node->GetNameCRC();
 uint32_t key = ( hash & 0xFFFF );


 IncludeStats * newStats = (IncludeStats *)m_Pool.Alloc( sizeof( IncludeStats ) );
 newStats->node = node;
 newStats->count = 0;
 newStats->inPCH = false;
 newStats->m_Next = m_Table[ key ];
 m_Table[ key ] = newStats;

 return newStats;
}



void Report::IncludeStatsMap::Flatten( Array< const IncludeStats * > & stats ) const
{
 for ( size_t i=0; i<65536; ++i )
 {
  IncludeStats * item = m_Table[ i ];
  while ( item )
  {
   IncludeStats * next = item->m_Next;
   stats.Append( item );
   item = next;
  }
 }
}
# 26 "/home/ffulin/p4/tmp/Unity/Tools/FBuild/FBuildCore/Unity1.cpp" 2


# 1 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/FLog.cpp" 1





# 1 "./Tools/FBuild/FBuildCore/PrecompiledHeader.h" 1
# 7 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/FLog.cpp" 2
# 17 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/FLog.cpp"
# 1 "/usr/include/stdio.h" 1 3 4
# 29 "/usr/include/stdio.h" 3 4
extern "C" {



# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.9/include/stddef.h" 1 3 4
# 34 "/usr/include/stdio.h" 2 3 4
# 44 "/usr/include/stdio.h" 3 4
struct _IO_FILE;



typedef struct _IO_FILE FILE;





# 64 "/usr/include/stdio.h" 3 4
typedef struct _IO_FILE __FILE;
# 74 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/libio.h" 1 3 4
# 31 "/usr/include/libio.h" 3 4
# 1 "/usr/include/_G_config.h" 1 3 4
# 15 "/usr/include/_G_config.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.9/include/stddef.h" 1 3 4
# 16 "/usr/include/_G_config.h" 2 3 4




# 1 "/usr/include/wchar.h" 1 3 4
# 82 "/usr/include/wchar.h" 3 4
typedef struct
{
  int __count;
  union
  {

    unsigned int __wch;



    char __wchb[4];
  } __value;
} __mbstate_t;
# 21 "/usr/include/_G_config.h" 2 3 4
typedef struct
{
  __off_t __pos;
  __mbstate_t __state;
} _G_fpos_t;
typedef struct
{
  __off64_t __pos;
  __mbstate_t __state;
} _G_fpos64_t;
# 32 "/usr/include/libio.h" 2 3 4
# 144 "/usr/include/libio.h" 3 4
struct _IO_jump_t; struct _IO_FILE;
# 154 "/usr/include/libio.h" 3 4
typedef void _IO_lock_t;





struct _IO_marker {
  struct _IO_marker *_next;
  struct _IO_FILE *_sbuf;



  int _pos;
# 177 "/usr/include/libio.h" 3 4
};


enum __codecvt_result
{
  __codecvt_ok,
  __codecvt_partial,
  __codecvt_error,
  __codecvt_noconv
};
# 245 "/usr/include/libio.h" 3 4
struct _IO_FILE {
  int _flags;




  char* _IO_read_ptr;
  char* _IO_read_end;
  char* _IO_read_base;
  char* _IO_write_base;
  char* _IO_write_ptr;
  char* _IO_write_end;
  char* _IO_buf_base;
  char* _IO_buf_end;

  char *_IO_save_base;
  char *_IO_backup_base;
  char *_IO_save_end;

  struct _IO_marker *_markers;

  struct _IO_FILE *_chain;

  int _fileno;



  int _flags2;

  __off_t _old_offset;



  unsigned short _cur_column;
  signed char _vtable_offset;
  char _shortbuf[1];



  _IO_lock_t *_lock;
# 293 "/usr/include/libio.h" 3 4
  __off64_t _offset;
# 302 "/usr/include/libio.h" 3 4
  void *__pad1;
  void *__pad2;
  void *__pad3;
  void *__pad4;
  size_t __pad5;

  int _mode;

  char _unused2[15 * sizeof (int) - 4 * sizeof (void *) - sizeof (size_t)];

};





struct _IO_FILE_plus;

extern struct _IO_FILE_plus _IO_2_1_stdin_;
extern struct _IO_FILE_plus _IO_2_1_stdout_;
extern struct _IO_FILE_plus _IO_2_1_stderr_;
# 338 "/usr/include/libio.h" 3 4
typedef __ssize_t __io_read_fn (void *__cookie, char *__buf, size_t __nbytes);







typedef __ssize_t __io_write_fn (void *__cookie, const char *__buf,
     size_t __n);







typedef int __io_seek_fn (void *__cookie, __off64_t *__pos, int __w);


typedef int __io_close_fn (void *__cookie);




typedef __io_read_fn cookie_read_function_t;
typedef __io_write_fn cookie_write_function_t;
typedef __io_seek_fn cookie_seek_function_t;
typedef __io_close_fn cookie_close_function_t;


typedef struct
{
  __io_read_fn *read;
  __io_write_fn *write;
  __io_seek_fn *seek;
  __io_close_fn *close;
} _IO_cookie_io_functions_t;
typedef _IO_cookie_io_functions_t cookie_io_functions_t;

struct _IO_cookie_file;


extern void _IO_cookie_init (struct _IO_cookie_file *__cfile, int __read_write,
        void *__cookie, _IO_cookie_io_functions_t __fns);




extern "C" {


extern int __underflow (_IO_FILE *);
extern int __uflow (_IO_FILE *);
extern int __overflow (_IO_FILE *, int);
# 434 "/usr/include/libio.h" 3 4
extern int _IO_getc (_IO_FILE *__fp);
extern int _IO_putc (int __c, _IO_FILE *__fp);
extern int _IO_feof (_IO_FILE *__fp) throw ();
extern int _IO_ferror (_IO_FILE *__fp) throw ();

extern int _IO_peekc_locked (_IO_FILE *__fp);





extern void _IO_flockfile (_IO_FILE *) throw ();
extern void _IO_funlockfile (_IO_FILE *) throw ();
extern int _IO_ftrylockfile (_IO_FILE *) throw ();
# 464 "/usr/include/libio.h" 3 4
extern int _IO_vfscanf (_IO_FILE * __restrict, const char * __restrict,
   __gnuc_va_list, int *__restrict);
extern int _IO_vfprintf (_IO_FILE *__restrict, const char *__restrict,
    __gnuc_va_list);
extern __ssize_t _IO_padn (_IO_FILE *, int, __ssize_t);
extern size_t _IO_sgetn (_IO_FILE *, void *, size_t);

extern __off64_t _IO_seekoff (_IO_FILE *, __off64_t, int, int);
extern __off64_t _IO_seekpos (_IO_FILE *, __off64_t, int);

extern void _IO_free_backup_area (_IO_FILE *) throw ();
# 526 "/usr/include/libio.h" 3 4
}
# 75 "/usr/include/stdio.h" 2 3 4
# 108 "/usr/include/stdio.h" 3 4


typedef _G_fpos_t fpos_t;





typedef _G_fpos64_t fpos64_t;
# 164 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/stdio_lim.h" 1 3 4
# 165 "/usr/include/stdio.h" 2 3 4



extern struct _IO_FILE *stdin;
extern struct _IO_FILE *stdout;
extern struct _IO_FILE *stderr;







extern int remove (const char *__filename) throw ();

extern int rename (const char *__old, const char *__new) throw ();




extern int renameat (int __oldfd, const char *__old, int __newfd,
       const char *__new) throw ();








extern FILE *tmpfile (void) ;
# 205 "/usr/include/stdio.h" 3 4
extern FILE *tmpfile64 (void) ;



extern char *tmpnam (char *__s) throw () ;





extern char *tmpnam_r (char *__s) throw () ;
# 227 "/usr/include/stdio.h" 3 4
extern char *tempnam (const char *__dir, const char *__pfx)
     throw () __attribute__ ((__malloc__)) ;








extern int fclose (FILE *__stream);




extern int fflush (FILE *__stream);

# 252 "/usr/include/stdio.h" 3 4
extern int fflush_unlocked (FILE *__stream);
# 262 "/usr/include/stdio.h" 3 4
extern int fcloseall (void);









extern FILE *fopen (const char *__restrict __filename,
      const char *__restrict __modes) ;




extern FILE *freopen (const char *__restrict __filename,
        const char *__restrict __modes,
        FILE *__restrict __stream) ;
# 295 "/usr/include/stdio.h" 3 4


extern FILE *fopen64 (const char *__restrict __filename,
        const char *__restrict __modes) ;
extern FILE *freopen64 (const char *__restrict __filename,
   const char *__restrict __modes,
   FILE *__restrict __stream) ;




extern FILE *fdopen (int __fd, const char *__modes) throw () ;





extern FILE *fopencookie (void *__restrict __magic_cookie,
     const char *__restrict __modes,
     _IO_cookie_io_functions_t __io_funcs) throw () ;




extern FILE *fmemopen (void *__s, size_t __len, const char *__modes)
  throw () ;




extern FILE *open_memstream (char **__bufloc, size_t *__sizeloc) throw () ;






extern void setbuf (FILE *__restrict __stream, char *__restrict __buf) throw ();



extern int setvbuf (FILE *__restrict __stream, char *__restrict __buf,
      int __modes, size_t __n) throw ();





extern void setbuffer (FILE *__restrict __stream, char *__restrict __buf,
         size_t __size) throw ();


extern void setlinebuf (FILE *__stream) throw ();








extern int fprintf (FILE *__restrict __stream,
      const char *__restrict __format, ...);




extern int printf (const char *__restrict __format, ...);

extern int sprintf (char *__restrict __s,
      const char *__restrict __format, ...) throw ();





extern int vfprintf (FILE *__restrict __s, const char *__restrict __format,
       __gnuc_va_list __arg);




extern int vprintf (const char *__restrict __format, __gnuc_va_list __arg);

extern int vsprintf (char *__restrict __s, const char *__restrict __format,
       __gnuc_va_list __arg) throw ();





extern int snprintf (char *__restrict __s, size_t __maxlen,
       const char *__restrict __format, ...)
     throw () __attribute__ ((__format__ (__printf__, 3, 4)));

extern int vsnprintf (char *__restrict __s, size_t __maxlen,
        const char *__restrict __format, __gnuc_va_list __arg)
     throw () __attribute__ ((__format__ (__printf__, 3, 0)));






extern int vasprintf (char **__restrict __ptr, const char *__restrict __f,
        __gnuc_va_list __arg)
     throw () __attribute__ ((__format__ (__printf__, 2, 0))) ;
extern int __asprintf (char **__restrict __ptr,
         const char *__restrict __fmt, ...)
     throw () __attribute__ ((__format__ (__printf__, 2, 3))) ;
extern int asprintf (char **__restrict __ptr,
       const char *__restrict __fmt, ...)
     throw () __attribute__ ((__format__ (__printf__, 2, 3))) ;




extern int vdprintf (int __fd, const char *__restrict __fmt,
       __gnuc_va_list __arg)
     __attribute__ ((__format__ (__printf__, 2, 0)));
extern int dprintf (int __fd, const char *__restrict __fmt, ...)
     __attribute__ ((__format__ (__printf__, 2, 3)));








extern int fscanf (FILE *__restrict __stream,
     const char *__restrict __format, ...) ;




extern int scanf (const char *__restrict __format, ...) ;

extern int sscanf (const char *__restrict __s,
     const char *__restrict __format, ...) throw ();
# 463 "/usr/include/stdio.h" 3 4








extern int vfscanf (FILE *__restrict __s, const char *__restrict __format,
      __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 2, 0))) ;





extern int vscanf (const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 1, 0))) ;


extern int vsscanf (const char *__restrict __s,
      const char *__restrict __format, __gnuc_va_list __arg)
     throw () __attribute__ ((__format__ (__scanf__, 2, 0)));
# 522 "/usr/include/stdio.h" 3 4









extern int fgetc (FILE *__stream);
extern int getc (FILE *__stream);





extern int getchar (void);

# 550 "/usr/include/stdio.h" 3 4
extern int getc_unlocked (FILE *__stream);
extern int getchar_unlocked (void);
# 561 "/usr/include/stdio.h" 3 4
extern int fgetc_unlocked (FILE *__stream);











extern int fputc (int __c, FILE *__stream);
extern int putc (int __c, FILE *__stream);





extern int putchar (int __c);

# 594 "/usr/include/stdio.h" 3 4
extern int fputc_unlocked (int __c, FILE *__stream);







extern int putc_unlocked (int __c, FILE *__stream);
extern int putchar_unlocked (int __c);






extern int getw (FILE *__stream);


extern int putw (int __w, FILE *__stream);








extern char *fgets (char *__restrict __s, int __n, FILE *__restrict __stream)
     ;
# 638 "/usr/include/stdio.h" 3 4
extern char *gets (char *__s) __attribute__ ((__deprecated__));


# 649 "/usr/include/stdio.h" 3 4
extern char *fgets_unlocked (char *__restrict __s, int __n,
        FILE *__restrict __stream) ;
# 665 "/usr/include/stdio.h" 3 4
extern __ssize_t __getdelim (char **__restrict __lineptr,
          size_t *__restrict __n, int __delimiter,
          FILE *__restrict __stream) ;
extern __ssize_t getdelim (char **__restrict __lineptr,
        size_t *__restrict __n, int __delimiter,
        FILE *__restrict __stream) ;







extern __ssize_t getline (char **__restrict __lineptr,
       size_t *__restrict __n,
       FILE *__restrict __stream) ;








extern int fputs (const char *__restrict __s, FILE *__restrict __stream);





extern int puts (const char *__s);






extern int ungetc (int __c, FILE *__stream);






extern size_t fread (void *__restrict __ptr, size_t __size,
       size_t __n, FILE *__restrict __stream) ;




extern size_t fwrite (const void *__restrict __ptr, size_t __size,
        size_t __n, FILE *__restrict __s);

# 726 "/usr/include/stdio.h" 3 4
extern int fputs_unlocked (const char *__restrict __s,
      FILE *__restrict __stream);
# 737 "/usr/include/stdio.h" 3 4
extern size_t fread_unlocked (void *__restrict __ptr, size_t __size,
         size_t __n, FILE *__restrict __stream) ;
extern size_t fwrite_unlocked (const void *__restrict __ptr, size_t __size,
          size_t __n, FILE *__restrict __stream);








extern int fseek (FILE *__stream, long int __off, int __whence);




extern long int ftell (FILE *__stream) ;




extern void rewind (FILE *__stream);

# 773 "/usr/include/stdio.h" 3 4
extern int fseeko (FILE *__stream, __off_t __off, int __whence);




extern __off_t ftello (FILE *__stream) ;
# 792 "/usr/include/stdio.h" 3 4






extern int fgetpos (FILE *__restrict __stream, fpos_t *__restrict __pos);




extern int fsetpos (FILE *__stream, const fpos_t *__pos);
# 815 "/usr/include/stdio.h" 3 4



extern int fseeko64 (FILE *__stream, __off64_t __off, int __whence);
extern __off64_t ftello64 (FILE *__stream) ;
extern int fgetpos64 (FILE *__restrict __stream, fpos64_t *__restrict __pos);
extern int fsetpos64 (FILE *__stream, const fpos64_t *__pos);




extern void clearerr (FILE *__stream) throw ();

extern int feof (FILE *__stream) throw () ;

extern int ferror (FILE *__stream) throw () ;




extern void clearerr_unlocked (FILE *__stream) throw ();
extern int feof_unlocked (FILE *__stream) throw () ;
extern int ferror_unlocked (FILE *__stream) throw () ;








extern void perror (const char *__s);






# 1 "/usr/include/x86_64-linux-gnu/bits/sys_errlist.h" 1 3 4
# 26 "/usr/include/x86_64-linux-gnu/bits/sys_errlist.h" 3 4
extern int sys_nerr;
extern const char *const sys_errlist[];


extern int _sys_nerr;
extern const char *const _sys_errlist[];
# 854 "/usr/include/stdio.h" 2 3 4




extern int fileno (FILE *__stream) throw () ;




extern int fileno_unlocked (FILE *__stream) throw () ;
# 873 "/usr/include/stdio.h" 3 4
extern FILE *popen (const char *__command, const char *__modes) ;





extern int pclose (FILE *__stream);





extern char *ctermid (char *__s) throw ();





extern char *cuserid (char *__s);




struct obstack;


extern int obstack_printf (struct obstack *__restrict __obstack,
      const char *__restrict __format, ...)
     throw () __attribute__ ((__format__ (__printf__, 2, 3)));
extern int obstack_vprintf (struct obstack *__restrict __obstack,
       const char *__restrict __format,
       __gnuc_va_list __args)
     throw () __attribute__ ((__format__ (__printf__, 2, 0)));







extern void flockfile (FILE *__stream) throw ();



extern int ftrylockfile (FILE *__stream) throw () ;


extern void funlockfile (FILE *__stream) throw ();
# 943 "/usr/include/stdio.h" 3 4
}
# 18 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/FLog.cpp" 2
# 1 "/usr/include/stdlib.h" 1 3 4
# 32 "/usr/include/stdlib.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.9/include/stddef.h" 1 3 4
# 33 "/usr/include/stdlib.h" 2 3 4

extern "C" {






# 1 "/usr/include/x86_64-linux-gnu/bits/waitflags.h" 1 3 4
# 50 "/usr/include/x86_64-linux-gnu/bits/waitflags.h" 3 4
typedef enum
{
  P_ALL,
  P_PID,
  P_PGID
} idtype_t;
# 42 "/usr/include/stdlib.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/waitstatus.h" 1 3 4
# 66 "/usr/include/x86_64-linux-gnu/bits/waitstatus.h" 3 4
union wait
  {
    int w_status;
    struct
      {

 unsigned int __w_termsig:7;
 unsigned int __w_coredump:1;
 unsigned int __w_retcode:8;
 unsigned int:16;







      } __wait_terminated;
    struct
      {

 unsigned int __w_stopval:8;
 unsigned int __w_stopsig:8;
 unsigned int:16;






      } __wait_stopped;
  };
# 43 "/usr/include/stdlib.h" 2 3 4
# 95 "/usr/include/stdlib.h" 3 4


typedef struct
  {
    int quot;
    int rem;
  } div_t;



typedef struct
  {
    long int quot;
    long int rem;
  } ldiv_t;







__extension__ typedef struct
  {
    long long int quot;
    long long int rem;
  } lldiv_t;


# 139 "/usr/include/stdlib.h" 3 4
extern size_t __ctype_get_mb_cur_max (void) throw () ;




extern double atof (const char *__nptr)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;

extern int atoi (const char *__nptr)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;

extern long int atol (const char *__nptr)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;





__extension__ extern long long int atoll (const char *__nptr)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;





extern double strtod (const char *__restrict __nptr,
        char **__restrict __endptr)
     throw () __attribute__ ((__nonnull__ (1)));





extern float strtof (const char *__restrict __nptr,
       char **__restrict __endptr) throw () __attribute__ ((__nonnull__ (1)));

extern long double strtold (const char *__restrict __nptr,
       char **__restrict __endptr)
     throw () __attribute__ ((__nonnull__ (1)));





extern long int strtol (const char *__restrict __nptr,
   char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1)));

extern unsigned long int strtoul (const char *__restrict __nptr,
      char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1)));




__extension__
extern long long int strtoq (const char *__restrict __nptr,
        char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1)));

__extension__
extern unsigned long long int strtouq (const char *__restrict __nptr,
           char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1)));





__extension__
extern long long int strtoll (const char *__restrict __nptr,
         char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1)));

__extension__
extern unsigned long long int strtoull (const char *__restrict __nptr,
     char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1)));

# 239 "/usr/include/stdlib.h" 3 4
extern long int strtol_l (const char *__restrict __nptr,
     char **__restrict __endptr, int __base,
     __locale_t __loc) throw () __attribute__ ((__nonnull__ (1, 4)));

extern unsigned long int strtoul_l (const char *__restrict __nptr,
        char **__restrict __endptr,
        int __base, __locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 4)));

__extension__
extern long long int strtoll_l (const char *__restrict __nptr,
    char **__restrict __endptr, int __base,
    __locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 4)));

__extension__
extern unsigned long long int strtoull_l (const char *__restrict __nptr,
       char **__restrict __endptr,
       int __base, __locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 4)));

extern double strtod_l (const char *__restrict __nptr,
   char **__restrict __endptr, __locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 3)));

extern float strtof_l (const char *__restrict __nptr,
         char **__restrict __endptr, __locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 3)));

extern long double strtold_l (const char *__restrict __nptr,
         char **__restrict __endptr,
         __locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 3)));
# 305 "/usr/include/stdlib.h" 3 4
extern char *l64a (long int __n) throw () ;


extern long int a64l (const char *__s)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;
# 321 "/usr/include/stdlib.h" 3 4
extern long int random (void) throw ();


extern void srandom (unsigned int __seed) throw ();





extern char *initstate (unsigned int __seed, char *__statebuf,
   size_t __statelen) throw () __attribute__ ((__nonnull__ (2)));



extern char *setstate (char *__statebuf) throw () __attribute__ ((__nonnull__ (1)));







struct random_data
  {
    int32_t *fptr;
    int32_t *rptr;
    int32_t *state;
    int rand_type;
    int rand_deg;
    int rand_sep;
    int32_t *end_ptr;
  };

extern int random_r (struct random_data *__restrict __buf,
       int32_t *__restrict __result) throw () __attribute__ ((__nonnull__ (1, 2)));

extern int srandom_r (unsigned int __seed, struct random_data *__buf)
     throw () __attribute__ ((__nonnull__ (2)));

extern int initstate_r (unsigned int __seed, char *__restrict __statebuf,
   size_t __statelen,
   struct random_data *__restrict __buf)
     throw () __attribute__ ((__nonnull__ (2, 4)));

extern int setstate_r (char *__restrict __statebuf,
         struct random_data *__restrict __buf)
     throw () __attribute__ ((__nonnull__ (1, 2)));






extern int rand (void) throw ();

extern void srand (unsigned int __seed) throw ();




extern int rand_r (unsigned int *__seed) throw ();







extern double drand48 (void) throw ();
extern double erand48 (unsigned short int __xsubi[3]) throw () __attribute__ ((__nonnull__ (1)));


extern long int lrand48 (void) throw ();
extern long int nrand48 (unsigned short int __xsubi[3])
     throw () __attribute__ ((__nonnull__ (1)));


extern long int mrand48 (void) throw ();
extern long int jrand48 (unsigned short int __xsubi[3])
     throw () __attribute__ ((__nonnull__ (1)));


extern void srand48 (long int __seedval) throw ();
extern unsigned short int *seed48 (unsigned short int __seed16v[3])
     throw () __attribute__ ((__nonnull__ (1)));
extern void lcong48 (unsigned short int __param[7]) throw () __attribute__ ((__nonnull__ (1)));





struct drand48_data
  {
    unsigned short int __x[3];
    unsigned short int __old_x[3];
    unsigned short int __c;
    unsigned short int __init;
    __extension__ unsigned long long int __a;

  };


extern int drand48_r (struct drand48_data *__restrict __buffer,
        double *__restrict __result) throw () __attribute__ ((__nonnull__ (1, 2)));
extern int erand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        double *__restrict __result) throw () __attribute__ ((__nonnull__ (1, 2)));


extern int lrand48_r (struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern int nrand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int mrand48_r (struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern int jrand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int srand48_r (long int __seedval, struct drand48_data *__buffer)
     throw () __attribute__ ((__nonnull__ (2)));

extern int seed48_r (unsigned short int __seed16v[3],
       struct drand48_data *__buffer) throw () __attribute__ ((__nonnull__ (1, 2)));

extern int lcong48_r (unsigned short int __param[7],
        struct drand48_data *__buffer)
     throw () __attribute__ ((__nonnull__ (1, 2)));









extern void *malloc (size_t __size) throw () __attribute__ ((__malloc__)) ;

extern void *calloc (size_t __nmemb, size_t __size)
     throw () __attribute__ ((__malloc__)) ;










extern void *realloc (void *__ptr, size_t __size)
     throw () __attribute__ ((__warn_unused_result__));

extern void free (void *__ptr) throw ();




extern void cfree (void *__ptr) throw ();



# 1 "/usr/include/alloca.h" 1 3 4
# 24 "/usr/include/alloca.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.9/include/stddef.h" 1 3 4
# 25 "/usr/include/alloca.h" 2 3 4

extern "C" {





extern void *alloca (size_t __size) throw ();





}
# 493 "/usr/include/stdlib.h" 2 3 4





extern void *valloc (size_t __size) throw () __attribute__ ((__malloc__)) ;




extern int posix_memalign (void **__memptr, size_t __alignment, size_t __size)
     throw () __attribute__ ((__nonnull__ (1))) ;




extern void *aligned_alloc (size_t __alignment, size_t __size)
     throw () __attribute__ ((__malloc__)) __attribute__ ((__alloc_size__ (2))) ;




extern void abort (void) throw () __attribute__ ((__noreturn__));



extern int atexit (void (*__func) (void)) throw () __attribute__ ((__nonnull__ (1)));




extern "C++" int at_quick_exit (void (*__func) (void))
     throw () __asm ("at_quick_exit") __attribute__ ((__nonnull__ (1)));









extern int on_exit (void (*__func) (int __status, void *__arg), void *__arg)
     throw () __attribute__ ((__nonnull__ (1)));






extern void exit (int __status) throw () __attribute__ ((__noreturn__));





extern void quick_exit (int __status) throw () __attribute__ ((__noreturn__));







extern void _Exit (int __status) throw () __attribute__ ((__noreturn__));






extern char *getenv (const char *__name) throw () __attribute__ ((__nonnull__ (1))) ;





extern char *secure_getenv (const char *__name)
     throw () __attribute__ ((__nonnull__ (1))) ;






extern int putenv (char *__string) throw () __attribute__ ((__nonnull__ (1)));





extern int setenv (const char *__name, const char *__value, int __replace)
     throw () __attribute__ ((__nonnull__ (2)));


extern int unsetenv (const char *__name) throw () __attribute__ ((__nonnull__ (1)));






extern int clearenv (void) throw ();
# 606 "/usr/include/stdlib.h" 3 4
extern char *mktemp (char *__template) throw () __attribute__ ((__nonnull__ (1)));
# 620 "/usr/include/stdlib.h" 3 4
extern int mkstemp (char *__template) __attribute__ ((__nonnull__ (1))) ;
# 630 "/usr/include/stdlib.h" 3 4
extern int mkstemp64 (char *__template) __attribute__ ((__nonnull__ (1))) ;
# 642 "/usr/include/stdlib.h" 3 4
extern int mkstemps (char *__template, int __suffixlen) __attribute__ ((__nonnull__ (1))) ;
# 652 "/usr/include/stdlib.h" 3 4
extern int mkstemps64 (char *__template, int __suffixlen)
     __attribute__ ((__nonnull__ (1))) ;
# 663 "/usr/include/stdlib.h" 3 4
extern char *mkdtemp (char *__template) throw () __attribute__ ((__nonnull__ (1))) ;
# 674 "/usr/include/stdlib.h" 3 4
extern int mkostemp (char *__template, int __flags) __attribute__ ((__nonnull__ (1))) ;
# 684 "/usr/include/stdlib.h" 3 4
extern int mkostemp64 (char *__template, int __flags) __attribute__ ((__nonnull__ (1))) ;
# 694 "/usr/include/stdlib.h" 3 4
extern int mkostemps (char *__template, int __suffixlen, int __flags)
     __attribute__ ((__nonnull__ (1))) ;
# 706 "/usr/include/stdlib.h" 3 4
extern int mkostemps64 (char *__template, int __suffixlen, int __flags)
     __attribute__ ((__nonnull__ (1))) ;









extern int system (const char *__command) ;






extern char *canonicalize_file_name (const char *__name)
     throw () __attribute__ ((__nonnull__ (1))) ;
# 734 "/usr/include/stdlib.h" 3 4
extern char *realpath (const char *__restrict __name,
         char *__restrict __resolved) throw () ;






typedef int (*__compar_fn_t) (const void *, const void *);


typedef __compar_fn_t comparison_fn_t;



typedef int (*__compar_d_fn_t) (const void *, const void *, void *);





extern void *bsearch (const void *__key, const void *__base,
        size_t __nmemb, size_t __size, __compar_fn_t __compar)
     __attribute__ ((__nonnull__ (1, 2, 5))) ;







extern void qsort (void *__base, size_t __nmemb, size_t __size,
     __compar_fn_t __compar) __attribute__ ((__nonnull__ (1, 4)));

extern void qsort_r (void *__base, size_t __nmemb, size_t __size,
       __compar_d_fn_t __compar, void *__arg)
  __attribute__ ((__nonnull__ (1, 4)));




extern int abs (int __x) throw () __attribute__ ((__const__)) ;
extern long int labs (long int __x) throw () __attribute__ ((__const__)) ;



__extension__ extern long long int llabs (long long int __x)
     throw () __attribute__ ((__const__)) ;







extern div_t div (int __numer, int __denom)
     throw () __attribute__ ((__const__)) ;
extern ldiv_t ldiv (long int __numer, long int __denom)
     throw () __attribute__ ((__const__)) ;




__extension__ extern lldiv_t lldiv (long long int __numer,
        long long int __denom)
     throw () __attribute__ ((__const__)) ;

# 812 "/usr/include/stdlib.h" 3 4
extern char *ecvt (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign) throw () __attribute__ ((__nonnull__ (3, 4))) ;




extern char *fcvt (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign) throw () __attribute__ ((__nonnull__ (3, 4))) ;




extern char *gcvt (double __value, int __ndigit, char *__buf)
     throw () __attribute__ ((__nonnull__ (3))) ;




extern char *qecvt (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign)
     throw () __attribute__ ((__nonnull__ (3, 4))) ;
extern char *qfcvt (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign)
     throw () __attribute__ ((__nonnull__ (3, 4))) ;
extern char *qgcvt (long double __value, int __ndigit, char *__buf)
     throw () __attribute__ ((__nonnull__ (3))) ;




extern int ecvt_r (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign, char *__restrict __buf,
     size_t __len) throw () __attribute__ ((__nonnull__ (3, 4, 5)));
extern int fcvt_r (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign, char *__restrict __buf,
     size_t __len) throw () __attribute__ ((__nonnull__ (3, 4, 5)));

extern int qecvt_r (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign,
      char *__restrict __buf, size_t __len)
     throw () __attribute__ ((__nonnull__ (3, 4, 5)));
extern int qfcvt_r (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign,
      char *__restrict __buf, size_t __len)
     throw () __attribute__ ((__nonnull__ (3, 4, 5)));






extern int mblen (const char *__s, size_t __n) throw ();


extern int mbtowc (wchar_t *__restrict __pwc,
     const char *__restrict __s, size_t __n) throw ();


extern int wctomb (char *__s, wchar_t __wchar) throw ();



extern size_t mbstowcs (wchar_t *__restrict __pwcs,
   const char *__restrict __s, size_t __n) throw ();

extern size_t wcstombs (char *__restrict __s,
   const wchar_t *__restrict __pwcs, size_t __n)
     throw ();








extern int rpmatch (const char *__response) throw () __attribute__ ((__nonnull__ (1))) ;
# 899 "/usr/include/stdlib.h" 3 4
extern int getsubopt (char **__restrict __optionp,
        char *const *__restrict __tokens,
        char **__restrict __valuep)
     throw () __attribute__ ((__nonnull__ (1, 2, 3))) ;





extern void setkey (const char *__key) throw () __attribute__ ((__nonnull__ (1)));







extern int posix_openpt (int __oflag) ;







extern int grantpt (int __fd) throw ();



extern int unlockpt (int __fd) throw ();




extern char *ptsname (int __fd) throw () ;






extern int ptsname_r (int __fd, char *__buf, size_t __buflen)
     throw () __attribute__ ((__nonnull__ (2)));


extern int getpt (void);






extern int getloadavg (double __loadavg[], int __nelem)
     throw () __attribute__ ((__nonnull__ (1)));


# 1 "/usr/include/x86_64-linux-gnu/bits/stdlib-float.h" 1 3 4
# 956 "/usr/include/stdlib.h" 2 3 4
# 968 "/usr/include/stdlib.h" 3 4
}
# 19 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/FLog.cpp" 2





    void _itoa_s( int value, char * buffer, int bufferSize, int base )
    {
        (void)bufferSize;
        do { if ( !( base == 10 ) ) { if ( AssertHandler::Failure( "base == 10", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/FLog.cpp", 27 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;
        sprintf( buffer, "%i", value );
    }




           bool FLog::s_ShowInfo = false;
           bool FLog::s_ShowErrors = true;
           bool FLog::s_ShowProgress = false;
           AStackString< 64 > FLog::m_ProgressText;
static AStackString< 72 > g_ClearLineString( "\r                                                               \r" );
static AStackString< 64 > g_OutputString( "\r99.9 % [....................] " );


           void FLog::Info( const char * formatString, ... )
{
 AStackString< 8192 > buffer;

 va_list args;
 __builtin_va_start(args,formatString);
 buffer.VFormat( formatString, args );
 __builtin_va_end(args);

 Output( "Info:", buffer.Get() );
}



           void FLog::Build( const char * formatString, ... )
{
 AStackString< 8192 > buffer;

 va_list args;
 __builtin_va_start(args,formatString);
 buffer.VFormat( formatString, args );
 __builtin_va_end(args);

 Output( (0), buffer.Get() );
}



           void FLog::Warning( const char * formatString, ... )
{
 AStackString< 8192 > buffer;

 va_list args;
 __builtin_va_start(args,formatString);
 buffer.VFormat( formatString, args );
 __builtin_va_end(args);

 Output( "Warning:", buffer.Get() );
}



           void FLog::Error( const char * formatString, ... )
{



 if ( FLog::ShowErrors() == false )
 {
  return;
 }

 AStackString< 8192 > buffer;

 va_list args;
 __builtin_va_start(args,formatString);
 buffer.VFormat( formatString, args );
 __builtin_va_end(args);

 Output( "Error:", buffer.Get() );
}



           void FLog::ErrorDirect( const char * message )
{
 if ( FLog::ShowErrors() == false )
 {
  return;
 }

 Tracing::Output( message );
}



           void FLog::Output( const char * type, const char * message )
{
 if( type == (0) )
 {
  Tracing::OutputFormat( "%s", message );
  return;
 }

 AStackString< 1024 > buffer( message );
 if ( buffer.IsEmpty() )
 {
  return;
 }
 if ( buffer[ buffer.GetLength() - 1 ] != '\n' )
 {
  buffer += '\n';
 }

 Tracing::OutputFormat( "%s", buffer.Get() );
}



           void FLog::StartBuild()
{

 {
  Tracing::SetCallbackOutput( &TracingOutputCallback );
 }
}



           void FLog::StopBuild()
{
 if ( s_ShowProgress )
 {
  Tracing::SetCallbackOutput( (0) );
  fputs( g_ClearLineString.Get(), stdout );
  m_ProgressText.Clear();
 }
}



           void FLog::OutputProgress( float time,
           float percentage,
           uint32_t numJobs,
           uint32_t numJobsActive,
           uint32_t numJobsDist,
           uint32_t numJobsDistActive )
{
 do { if ( !( s_ShowProgress ) ) { if ( AssertHandler::Failure( "s_ShowProgress", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/FLog.cpp", 170 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;


 uint32_t intPerc = (uint32_t)( percentage * 10.0f );
 uint32_t hundreds = ( intPerc / 100 ); intPerc -= ( hundreds * 100 );
 uint32_t tens = ( intPerc / 10 ); intPerc -= ( tens * 10 );
 uint32_t ones = intPerc;
 m_ProgressText = g_OutputString;
 m_ProgressText[ 1 ] = ( hundreds > 0 ) ? ( '0' + (char)hundreds ) : ' ';
 m_ProgressText[ 2 ] = '0' + (char)tens;
 m_ProgressText[ 4 ] = '0' + (char)ones;


 uint32_t numStarsDone = (uint32_t)( percentage * 20.0f / 100.0f );
 for ( uint32_t i=0; i<20; ++i )
 {
  m_ProgressText[ 9 + i ] = ( i < numStarsDone ) ? '*' : '-';
 }


 uint32_t timeTakenMinutes = uint32_t( time / 60.0f );
 uint32_t timeTakenSeconds = (uint32_t)time - ( timeTakenMinutes * 60 );
 if ( timeTakenMinutes > 0 )
 {
  char buffer[ 8 ];
  _itoa_s( timeTakenMinutes, buffer, 8, 10 );
  m_ProgressText += buffer;
  m_ProgressText.Append( "m ", 2 );
 }
 char buffer[ 8 ];
 _itoa_s( timeTakenSeconds, buffer, 8, 10 );
 if ( timeTakenSeconds < 10 ) { m_ProgressText += '0'; }
 m_ProgressText += buffer;
 m_ProgressText += 's';


 m_ProgressText.Append( " (", 2 );
 _itoa_s( numJobsActive, buffer, 8, 10 );
 m_ProgressText += buffer;
 m_ProgressText += '/';
 _itoa_s( numJobsActive + numJobs, buffer, 8, 10 );
 m_ProgressText += buffer;
 m_ProgressText += ')';


 if ( FBuild::Get().GetOptions().m_AllowDistributed )
 {
  m_ProgressText.Append( "+(", 2 );
  _itoa_s( numJobsDistActive, buffer, 8, 10 );
  m_ProgressText += buffer;
  m_ProgressText += '/';
  _itoa_s( numJobsDistActive + numJobsDist, buffer, 8, 10 );
  m_ProgressText += buffer;
  m_ProgressText += ')';
 }

 m_ProgressText.Append( "    \b\b\b", 7 );


 if ( FBuild::Get().GetStopBuild() )
 {
  m_ProgressText.Format( "\rBUILD ABORTED - STOPPING (%u) ", numJobsActive );
  m_ProgressText += "                                  \b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b";
 }


 static int animIndex = 0;
 static char anim[] = { '\\', '|', '/', '-', '\\', '|', '/', '-' };
 m_ProgressText += anim[ ( animIndex++ ) % 8 ];


 fwrite( m_ProgressText.Get(), 1, m_ProgressText.GetLength(), stdout );
}



           bool FLog::TracingOutputCallback( const char * message )
{
 uint32_t threadIndex = WorkerThread::GetThreadIndex();

 AStackString< 2048 > tmp;

 if ( s_ShowProgress )
 {

  tmp += g_ClearLineString;
 }


 if ( threadIndex > 0 )
 {
  char buffer[ 8 ];
  _itoa_s( threadIndex, buffer, 8, 10 );
  tmp += buffer;
  tmp += '>';
  if ( threadIndex < 10 )
  {
   tmp += ' ';
  }
 }

 tmp += message;
# 280 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/FLog.cpp"
 tmp += m_ProgressText;

 fwrite( tmp.Get(), 1, tmp.GetLength(), stdout );

 return false;
}
# 29 "/home/ffulin/p4/tmp/Unity/Tools/FBuild/FBuildCore/Unity1.cpp" 2


# 1 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/WorkerPool/WorkerThreadRemote.cpp" 1





# 1 "./Tools/FBuild/FBuildCore/PrecompiledHeader.h" 1
# 7 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/WorkerPool/WorkerThreadRemote.cpp" 2

# 1 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/WorkerPool/WorkerThreadRemote.h" 1


       
# 14 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/WorkerPool/WorkerThreadRemote.h"
class Job;



class WorkerThreadRemote : public WorkerThread
{
public:
 WorkerThreadRemote( uint32_t threadIndex );
 virtual ~WorkerThreadRemote();

 void GetStatus( AString & hostName, AString & status, bool & isIdle ) const;


 static void SetNumCPUsToUse( uint32_t c ) { s_NumCPUsToUse = c; }
 static uint32_t GetNumCPUsToUse() { return s_NumCPUsToUse; }
private:
 virtual void Main();

 bool IsEnabled() const;

 mutable Mutex m_CurrentJobMutex;
 Job * m_CurrentJob;


 static uint32_t s_NumCPUsToUse;
};
# 9 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/WorkerPool/WorkerThreadRemote.cpp" 2
# 1 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/WorkerPool/Job.h" 1


       
# 14 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/WorkerPool/Job.h"
class IOStream;
class Node;
class ToolManifest;



class Job
{
public:
 explicit Job( Node * node );
 explicit Job( IOStream & stream );
   ~Job();

 inline uint32_t GetJobId() const { return m_JobId; }
 inline bool operator == ( uint32_t jobId ) const { return ( m_JobId == jobId ); }

 inline Node * GetNode() const { return m_Node; }
 inline const AString & GetRemoteName() const { return m_RemoteName; }

 inline void SetCacheName( const AString & cacheName ) { m_CacheName = cacheName; }
 inline const AString & GetCacheName() const { return m_CacheName; }


 void OwnData( void * data, size_t size, bool compressed = false );

 inline void * GetData() const { return m_Data; }
 inline size_t GetDataSize() const { return m_DataSize; }

 inline void SetUserData( void * data ) { m_UserData = data; }
 inline void * GetUserData() const { return m_UserData; }

 inline void SetToolManifest( ToolManifest * manifest ) { m_ToolManifest = manifest; }
 inline ToolManifest * GetToolManifest() const { return m_ToolManifest; }

 inline bool IsDataCompressed() const { return m_DataIsCompressed; }
 inline bool IsLocal() const { return m_IsLocal; }

 inline const Array< AString > & GetMessages() const { return m_Messages; }


 void Error( const char * format, ... );


 void OnSystemError() { ++m_SystemErrorCount; }
 inline uint8_t GetSystemErrorCount() const { return m_SystemErrorCount; }


 void Serialize( IOStream & stream );
 void Deserialize( IOStream & stream );

private:
 friend class JobSubQueue;
 Job * m_Next;

 uint32_t m_JobId;
 Node * m_Node;
 void * m_Data;
 uint32_t m_DataSize;
 void * m_UserData;
 bool m_DataIsCompressed;
 bool m_IsLocal;
 uint8_t m_SystemErrorCount;
 AString m_RemoteName;
 AString m_CacheName;

 ToolManifest * m_ToolManifest;

 Array< AString > m_Messages;
};
# 10 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/WorkerPool/WorkerThreadRemote.cpp" 2

# 1 "./Tools/FBuild/FBuildWorker/Worker/WorkerSettings.h" 1


       
# 16 "./Tools/FBuild/FBuildWorker/Worker/WorkerSettings.h"
class WorkerSettings : public Singleton< WorkerSettings >
{
public:
 explicit WorkerSettings();
 ~WorkerSettings();


 enum Mode
 {
  DISABLED = 0,
  WHEN_IDLE = 1,
  DEDICATED = 2
 };
 inline Mode GetMode() const { return m_Mode; }
 void SetMode( Mode m );


 inline uint32_t GetNumCPUsToUse() const { return m_NumCPUsToUse; }
 void SetNumCPUsToUse( uint32_t c );


 void SetStartMinimized( bool startMinimized );
 inline bool GetStartMinimzed() { return m_StartMinimized; }

 void Load();
 void Save();
private:
 Mode m_Mode;
 uint32_t m_NumCPUsToUse;
 bool m_StartMinimized;
};
# 12 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/WorkerPool/WorkerThreadRemote.cpp" 2



# 1 "./Tools/FBuild/FBuildCore/Protocol/Server.h" 1


       





# 1 "./Core/Network/TCPConnectionPool.h" 1


       





# 1 "./Core/Network/NetworkStartupHelper.h" 1


       
# 18 "./Core/Network/NetworkStartupHelper.h"
class NetworkStartupHelper
{
public:

 NetworkStartupHelper();
    ~NetworkStartupHelper();

private:



 static Mutex s_Mutex;
    static uint32_t s_RefCount;
};
# 10 "./Core/Network/TCPConnectionPool.h" 2




# 1 "./Core/Process/Thread.h" 1


       
# 17 "./Core/Process/Thread.h"
class Thread
{
public:
# 29 "./Core/Process/Thread.h"
        typedef pthread_t ThreadId;
        typedef void * ThreadHandle;
        typedef uint32_t (*ThreadEntryFunction)( void * param );







 static ThreadId GetCurrentThreadId();
 static bool IsThread( ThreadId threadId ) { return ( GetCurrentThreadId() == threadId ); }
 static bool IsMainThread() { return GetCurrentThreadId() == s_MainThreadId; }

    static void Sleep( int32_t ms );

 static ThreadHandle CreateThread( ThreadEntryFunction entryFunc,
           const char * threadName = (0),
           uint32_t stackSize = ( 64 * (1024) ),
           void * userData = (0)
         );
 static int WaitForThread( ThreadHandle handle, uint32_t timeoutMS, bool & timedOut );
 static void CloseHandle( ThreadHandle h );

 static void SetThreadName( const char * name );

private:
 static ThreadId s_MainThreadId;
};
# 15 "./Core/Network/TCPConnectionPool.h" 2




class TCPConnectionPool;




    typedef int TCPSocket;




class ConnectionInfo
{
public:
 ConnectionInfo( TCPConnectionPool * ownerPool );


 void SetUserData( void * userData ) const { m_UserData = userData; }
 void * GetUserData() const { return m_UserData; }


 TCPConnectionPool & GetTCPConnectionPool() const { return *m_TCPConnectionPool; }
 inline uint32_t GetRemoteAddress() const { return m_RemoteAddress; }

private:
 friend class TCPConnectionPool;

 TCPSocket m_Socket;
 uint32_t m_RemoteAddress;
 uint16_t m_RemotePort;
 volatile mutable bool m_ThreadQuitNotification;
 TCPConnectionPool * m_TCPConnectionPool;
 mutable void * m_UserData;


 mutable bool m_InUse;

};



class TCPConnectionPool
{
public:
    TCPConnectionPool();
    virtual ~TCPConnectionPool();


 void ShutdownAllConnections();


    bool Listen( uint16_t port );
 void StopListening();
    const ConnectionInfo * Connect( const AString & host, uint16_t port, uint32_t timeout = 2000 );
 const ConnectionInfo * Connect( uint32_t hostIP, uint16_t port, uint32_t timeout = 2000 );
    void Disconnect( const ConnectionInfo * ci );
 void SetShuttingDown() { m_ShuttingDown = true; }


 size_t GetNumConnections() const;


    bool Send( const ConnectionInfo * connection, const void * data, size_t size, uint32_t timeoutMS = 2000 );
    bool Broadcast( const void * data, size_t size );

 static void GetAddressAsString( uint32_t addr, AString & address );

protected:

    virtual void OnReceive( const ConnectionInfo *, void * , uint32_t , bool & ) {}
    virtual void OnConnected( const ConnectionInfo * ) {}
    virtual void OnDisconnected( const ConnectionInfo * ) {}


    virtual void * AllocBuffer( uint32_t size );
    virtual void FreeBuffer( void * data );

private:

    bool HandleRead( ConnectionInfo * ci );


    int GetLastError() const;
    bool WouldBlock() const;
    int CloseSocket( TCPSocket socket ) const;
    int Select( TCPSocket maxSocketPlusOne,
                     void * readSocketSet,
                 void * writeSocketSet,
                     void * exceptionSocketSet,
                        struct timeval * timeOut ) const;
    TCPSocket Accept( TCPSocket socket,
                        struct sockaddr * address,
                        int * addressSize ) const;


    void CreateListenThread( TCPSocket socket, uint32_t host, uint16_t port );
    static uint32_t ListenThreadWrapperFunction( void * data );
    void ListenThreadFunction( ConnectionInfo * ci );
 ConnectionInfo * CreateConnectionThread( TCPSocket socket, uint32_t host, uint16_t port );
    static uint32_t ConnectionThreadWrapperFunction( void * data );
 void ConnectionThreadFunction( ConnectionInfo * ci );


 ConnectionInfo * m_ListenConnection;


 mutable Mutex m_ConnectionsMutex;
 Array< ConnectionInfo * > m_Connections;

 bool m_ShuttingDown;


    NetworkStartupHelper m_EnsureNetworkStarted;
};
# 10 "./Tools/FBuild/FBuildCore/Protocol/Server.h" 2




class Job;
namespace Protocol
{
 class IMessage;
 class MsgConnection;
 class MsgJob;
 class MsgManifest;
 class MsgNoJobAvailable;
 class MsgStatus;
 class MsgFile;
}
class ToolManifest;



class Server : public TCPConnectionPool
{
public:
 Server();
 ~Server();

 static void GetHostForJob( const Job * job, AString & hostName );

 bool IsSynchingTool( AString & statusStr ) const;
 void StopRequestingJobs() { m_RequestJobs = false; }

private:

 virtual void OnConnected( const ConnectionInfo * connection );
 virtual void OnDisconnected( const ConnectionInfo * connection );
 virtual void OnReceive( const ConnectionInfo * connection, void * data, uint32_t size, bool & keepMemory );


 void Process( const ConnectionInfo * connection, const Protocol::MsgConnection * msg );
 void Process( const ConnectionInfo * connection, const Protocol::MsgStatus * msg );
 void Process( const ConnectionInfo * connection, const Protocol::MsgNoJobAvailable * msg );
 void Process( const ConnectionInfo * connection, const Protocol::MsgJob * msg, const void * payload, size_t payloadSize );
 void Process( const ConnectionInfo * connection, const Protocol::MsgManifest * msg, const void * payload, size_t payloadSize );
 void Process( const ConnectionInfo * connection, const Protocol::MsgFile * msg, const void * payload, size_t payloadSize );

 static uint32_t ThreadFuncStatic( void * param );
 void ThreadFunc();

 void FindNeedyClients();
 void FinalizeCompletedJobs();
 void SendServerStatus();
 void CheckWaitingJobs( const ToolManifest * manifest );

 void RequestMissingFiles( const ConnectionInfo * connection, ToolManifest * manifest ) const;

 struct ClientState
 {
  ClientState( const ConnectionInfo * ci ) : m_CurrentMessage( (0) ), m_Connection( ci ), m_NumJobsAvailable( 0 ), m_NumJobsRequested( 0 ), m_NumJobsActive( 0 ), m_WaitingJobs( 16, true ) {}

  inline bool operator < ( const ClientState & other ) const { return ( m_NumJobsAvailable > other.m_NumJobsAvailable ); }

  Mutex m_Mutex;

  const Protocol::IMessage * m_CurrentMessage;
  const ConnectionInfo * m_Connection;
  uint32_t m_NumJobsAvailable;
  uint32_t m_NumJobsRequested;
  uint32_t m_NumJobsActive;

  AString m_HostName;

  Array< Job * > m_WaitingJobs;

  Timer m_StatusTimer;
 };

 volatile bool m_ShouldExit;
 volatile bool m_Exited;
 bool m_RequestJobs;
 Thread::ThreadHandle m_Thread;
 Mutex m_ClientListMutex;
 Array< ClientState * > m_ClientList;

 mutable Mutex m_ToolManifestsMutex;
 Array< ToolManifest * > m_Tools;
};
# 16 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/WorkerPool/WorkerThreadRemote.cpp" 2
# 1 "./Tools/FBuild/FBuildCore/WorkerPool/JobQueueRemote.h" 1


       
# 17 "./Tools/FBuild/FBuildCore/WorkerPool/JobQueueRemote.h"
class Node;
class Job;
class WorkerThread;



class JobQueueRemote : public Singleton< JobQueueRemote >
{
public:
 JobQueueRemote( uint32_t numWorkerThreads );
 ~JobQueueRemote();


 void QueueJob( Job * job );
 Job * GetCompletedJob();
 void CancelJobsWithUserData( void * userData );


 void SignalStopWorkers();
 bool HaveWorkersStopped() const;

 inline size_t GetNumWorkers() const { return m_Workers.GetSize(); }
 void GetWorkerStatus( size_t index, AString & hostName, AString & status, bool & isIdle ) const;
private:

 friend class WorkerThread;
 friend class WorkerThreadRemote;
 Job * GetJobToProcess();
 static Node::BuildResult DoBuild( Job * job, bool racingRemoteJob );
 void FinishedProcessingJob( Job * job, bool result );


 static bool ReadResults( Job * job );

 mutable Mutex m_PendingJobsMutex;
 Array< Job * > m_PendingJobs;
 mutable Mutex m_InFlightJobsMutex;
 Array< Job * > m_InFlightJobs;
 Mutex m_CompletedJobsMutex;
 Array< Job * > m_CompletedJobs;
 Array< Job * > m_CompletedJobsFailed;

 Array< WorkerThread * > m_Workers;
};
# 17 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/WorkerPool/WorkerThreadRemote.cpp" 2






           uint32_t WorkerThreadRemote::s_NumCPUsToUse( 999 );


WorkerThreadRemote::WorkerThreadRemote( uint32_t threadIndex )
: WorkerThread( threadIndex )
, m_CurrentJob( (0) )
{
}


WorkerThreadRemote::~WorkerThreadRemote()
{
}



            void WorkerThreadRemote::Main()
{
 while ( m_ShouldExit == false )
 {
  if ( IsEnabled() == false )
  {
   Thread::Sleep( 500 );
   continue;
  }


  Job * job = JobQueueRemote::Get().GetJobToProcess();
  if ( job != (0) )
  {
   {
    MutexHolder mh( m_CurrentJobMutex );
    m_CurrentJob = job;
   }


   Node::BuildResult result = JobQueueRemote::DoBuild( job, false );
   do { if ( !( ( result == Node::NODE_RESULT_OK ) || ( result == Node::NODE_RESULT_FAILED ) ) ) { if ( AssertHandler::Failure( "( result == Node::NODE_RESULT_OK ) || ( result == Node::NODE_RESULT_FAILED )", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/WorkerPool/WorkerThreadRemote.cpp", 60 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;

   {
    MutexHolder mh( m_CurrentJobMutex );
    m_CurrentJob = (0);
   }

   JobQueueRemote::Get().FinishedProcessingJob( job, ( result != Node::NODE_RESULT_FAILED ) );


   continue;
  }


  Thread::Sleep( 16 );
 }

 m_Exited = true;
}



void WorkerThreadRemote::GetStatus( AString & hostName, AString & status, bool & isIdle ) const
{
 isIdle = false;

 MutexHolder mh( m_CurrentJobMutex );
 if ( m_CurrentJob )
 {
  Server::GetHostForJob( m_CurrentJob, hostName );
  if ( IsEnabled() == false )
  {
   status = "(Finishing) ";
  }
  status += m_CurrentJob->GetRemoteName();
 }
 else
 {
  hostName.Clear();

  if ( IsEnabled() == false )
  {
   status = "(Disabled)";
  }
  else
  {
   status = "Idle";
   isIdle = true;
  }
 }
}



bool WorkerThreadRemote::IsEnabled() const
{

 uint32_t cpuId = ( m_ThreadIndex - 1000 );


 return ( cpuId <= s_NumCPUsToUse );
}
# 32 "/home/ffulin/p4/tmp/Unity/Tools/FBuild/FBuildCore/Unity1.cpp" 2


# 1 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/WorkerPool/JobQueueRemote.cpp" 1





# 1 "./Tools/FBuild/FBuildCore/PrecompiledHeader.h" 1
# 7 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/WorkerPool/JobQueueRemote.cpp" 2
# 27 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/WorkerPool/JobQueueRemote.cpp"
JobQueueRemote::JobQueueRemote( uint32_t numWorkerThreads ) :
 m_PendingJobs( 1024, true ),
 m_CompletedJobs( 1024, true ),
 m_CompletedJobsFailed( 1024, true ),
 m_Workers( numWorkerThreads, false )
{
 WorkerThread::InitTmpDir( true );

 for ( uint32_t i=0; i<numWorkerThreads; ++i )
 {


  uint32_t threadIndex = ( i + 1001 );
  WorkerThread * wt = new ( "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/WorkerPool/JobQueueRemote.cpp", 40 ) WorkerThreadRemote( threadIndex );
  wt->Init();
  m_Workers.Append( wt );
 }
}



JobQueueRemote::~JobQueueRemote()
{

 SignalStopWorkers();


 const size_t numWorkerThreads = m_Workers.GetSize();
 for ( size_t i=0; i<numWorkerThreads; ++i )
 {
  m_Workers[ i ]->WaitForStop();
  delete m_Workers[ i ];
 }
}



void JobQueueRemote::SignalStopWorkers()
{
 const size_t numWorkerThreads = m_Workers.GetSize();
 for ( size_t i=0; i<numWorkerThreads; ++i )
 {
  m_Workers[ i ]->Stop();
 }
}



bool JobQueueRemote::HaveWorkersStopped() const
{
 const size_t numWorkerThreads = m_Workers.GetSize();
 for ( size_t i=0; i<numWorkerThreads; ++i )
 {
  if ( m_Workers[ i ]->HasExited() == false )
  {
   return false;
  }
 }
 return true;
}



void JobQueueRemote::GetWorkerStatus( size_t index, AString & hostName, AString & status, bool & isIdle ) const
{
 ( (WorkerThreadRemote *)m_Workers[ index ] )->GetStatus( hostName, status, isIdle );
}



void JobQueueRemote::QueueJob( Job * job )
{
 MutexHolder m( m_PendingJobsMutex );
 m_PendingJobs.Append( job );
}




Job * JobQueueRemote::GetCompletedJob()
{
 MutexHolder m( m_CompletedJobsMutex );


 if ( !m_CompletedJobs.IsEmpty() )
 {
  Job * job = m_CompletedJobs[ 0 ];
  m_CompletedJobs.PopFront();
  job->GetNode()->SetState( Node::UP_TO_DATE );
  return job;
 }


 if ( !m_CompletedJobsFailed.IsEmpty() )
 {
  Job * job = m_CompletedJobsFailed[ 0 ];
  m_CompletedJobsFailed.PopFront();
  job->GetNode()->SetState( Node::FAILED );
  return job;
 }

 return (0);
}



void JobQueueRemote::CancelJobsWithUserData( void * userData )
{

 {
  MutexHolder m( m_PendingJobsMutex );
  Job ** it = m_PendingJobs.Begin();
  while ( it != m_PendingJobs.End() )
  {
   if ( ( *it )->GetUserData() == userData )
   {
    delete *it;
    m_PendingJobs.Erase( it );
    continue;
   }
   ++it;
  }
 }


 {
  MutexHolder m( m_CompletedJobsMutex );
  Job ** it = m_CompletedJobs.Begin();
  while ( it != m_CompletedJobs.End() )
  {
   if ( ( *it )->GetUserData() == userData )
   {
    delete *it;
    m_CompletedJobs.Erase( it );
    continue;
   }
   ++it;
  }
 }




 MutexHolder mh( m_InFlightJobsMutex );
 Job ** it = m_InFlightJobs.Begin();
 while ( it != m_InFlightJobs.End() )
 {
  if ( ( *it )->GetUserData() == userData )
  {
   ( *it )->SetUserData( (0) );
  }
  ++it;
 }
}



Job * JobQueueRemote::GetJobToProcess()
{
 MutexHolder m( m_PendingJobsMutex );
 if ( m_PendingJobs.IsEmpty() )
 {
  return (0);
 }


 Job * job = m_PendingJobs[ 0 ];
 m_PendingJobs.PopFront();

 MutexHolder mh( m_InFlightJobsMutex );
 m_InFlightJobs.Append( job );

 return job;
}



void JobQueueRemote::FinishedProcessingJob( Job * job, bool success )
{



 {
  MutexHolder mh( m_InFlightJobsMutex );
  Job ** it = m_InFlightJobs.Find( job );
  do { if ( !( it != (0) ) ) { if ( AssertHandler::Failure( "it != nullptr", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/WorkerPool/JobQueueRemote.cpp", 212 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;
  m_InFlightJobs.Erase( it );
 }


 if ( job->GetUserData() == (0) )
 {
  delete job;
  return;
 }


 MutexHolder m( m_CompletedJobsMutex );
 if ( success )
 {
  m_CompletedJobs.Append( job );
 }
 else
 {
  m_CompletedJobsFailed.Append( job );
 }
}



           Node::BuildResult JobQueueRemote::DoBuild( Job * job, bool racingRemoteJob )
{
 Timer timer;

 ObjectNode * node = job->GetNode()->CastTo< ObjectNode >();


 if ( job->IsLocal() == false )
 {

  const char * fileName = ( job->GetRemoteName().FindLast( ( '/' ) ) + 1 );

  AStackString<> tmpFileName;
  WorkerThread::CreateTempFilePath( fileName, tmpFileName );
  node->ReplaceDummyName( tmpFileName );


   Tracing::DebugSpamFormat( "REMOTE: %s (%s)\n", fileName, job->GetRemoteName().Get() );

 }

 do { if ( !( node->IsAFile() ) ) { if ( AssertHandler::Failure( "node->IsAFile()", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/WorkerPool/JobQueueRemote.cpp", 258 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;


 if ( Node::EnsurePathExistsForFile( node->GetName() ) == false )
 {

  return Node::NODE_RESULT_FAILED;
 }


 if ( node->IsUsingPDB() && ( job->IsLocal() == false ) )
 {
  AStackString<> pdbName;
  node->GetPDBName( pdbName );
  FileIO::FileDelete( pdbName.Get() );
 }

 Node::BuildResult result = ((Node *)node )->DoBuild2( job, racingRemoteJob );

 uint32_t timeTakenMS = uint32_t( timer.GetElapsedMS() );

 if ( result == Node::NODE_RESULT_OK )
 {


  node->SetLastBuildTime( timeTakenMS );
  node->SetStatFlag( Node::STATS_BUILT );



   if ( job->IsLocal() )
   {

    do { if ( !( node->m_Stamp == FileIO::GetFileLastWriteTime(node->GetName()) ) ) { if ( AssertHandler::Failure( "node->m_Stamp == FileIO::GetFileLastWriteTime(node->GetName())", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/WorkerPool/JobQueueRemote.cpp", 291 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;
   }

 }

 if ( result == Node::NODE_RESULT_FAILED )
 {

  if ( FileIO::FileExists( node->GetName().Get() ) )
  {

   if ( FileIO::FileDelete( node->GetName().Get() ) == false )
   {

    do { FLog::Error( "Post failure deletion failed for '%s'", node->GetName().Get() ); } while ( false ); ;
   }
  }
 }
 else
 {

  do { if ( !( result == Node::NODE_RESULT_OK ) ) { if ( AssertHandler::Failure( "result == Node::NODE_RESULT_OK", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/WorkerPool/JobQueueRemote.cpp", 312 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;


  if ( job->IsLocal() == false )
  {

   if ( ReadResults( job ) == false )
   {
    result = Node::NODE_RESULT_FAILED;
   }
  }
 }


 if ( job->IsLocal() == false )
 {

  FileIO::FileDelete( node->GetName().Get() );


  if ( node->IsUsingPDB() )
  {
   AStackString<> pdbName;
   node->GetPDBName( pdbName );
   FileIO::FileDelete( pdbName.Get() );
  }
 }


 node->AddProcessingTime( timeTakenMS );

 return result;
}



           bool JobQueueRemote::ReadResults( Job * job )
{
 const ObjectNode * node = job->GetNode()->CastTo< ObjectNode >();
 const bool includePDB = ( node->IsUsingPDB() && ( job->IsLocal() == false ) );


 FileStream fs;
 if ( fs.Open( node->GetName().Get() ) == false )
 {
  do { FLog::Error( "File missing despite success: '%s'", node->GetName().Get() ); } while ( false ); ;
  return false;
 }
 uint32_t size = (uint32_t)fs.GetFileSize();
 uint32_t size2 = 0;


 FileStream fs2;
 if ( includePDB )
 {
  AStackString<> pdbName;
  node->GetPDBName( pdbName );
  if ( fs2.Open( pdbName.Get() ) == false )
  {
   do { FLog::Error( "File missing despite success: '%s'", pdbName.Get() ); } while ( false ); ;
   return false;
  }
  size2 = (uint32_t)fs2.GetFileSize();
 }


 size_t memSize = sizeof( uint32_t );
 memSize += size;
 if ( includePDB )
 {
  memSize += sizeof( uint32_t );
  memSize += size2;
 }


 AutoPtr< char > mem( (char *)::AllocFileLine( memSize, "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/WorkerPool/JobQueueRemote.cpp", 387 ) );


 *( (uint32_t *)mem.Get() ) = size;


 if ( fs.Read( mem.Get() + sizeof( uint32_t ), size ) != size )
 {
  do { FLog::Error( "File read error for '%s'", node->GetName().Get() ); } while ( false ); ;
  return false;
 }

 if ( includePDB )
 {

  *( (uint32_t *)( mem.Get() + sizeof( uint32_t ) + size ) ) = size2;


  if ( fs2.Read( mem.Get() + sizeof( uint32_t ) + size + sizeof( uint32_t ), size2 ) != size2 )
  {
   do { FLog::Error( "File read error for '%s'", node->GetName().Get() ); } while ( false ); ;
   return false;
  }
 }


 job->OwnData( mem.Release(), memSize );

 return true;
}
# 35 "/home/ffulin/p4/tmp/Unity/Tools/FBuild/FBuildCore/Unity1.cpp" 2


# 1 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/WorkerPool/WorkerBrokerage.cpp" 1





# 1 "./Tools/FBuild/FBuildCore/PrecompiledHeader.h" 1
# 7 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/WorkerPool/WorkerBrokerage.cpp" 2




# 1 "./Tools/FBuild/FBuildCore/Protocol/Protocol.h" 1


       
# 13 "./Tools/FBuild/FBuildCore/Protocol/Protocol.h"
class ConnectionInfo;
class ConstMemoryStream;
class MemoryStream;
class TCPConnectionPool;
# 30 "./Tools/FBuild/FBuildCore/Protocol/Protocol.h"
namespace Protocol
{
 enum { PROTOCOL_PORT = 31264 };
 enum { PROTOCOL_VERSION = 14 };

 enum { SERVER_STATUS_FREQUENCY_MS = 1000 };
 enum { SERVER_STATUS_TIMEOUT = 5000 };



 enum MessageType
 {
  MSG_CONNECTION = 1,
  MSG_STATUS = 2,

  MSG_REQUEST_JOB = 3,
  MSG_NO_JOB_AVAILABLE = 4,
  MSG_JOB = 5,

  MSG_JOB_RESULT = 6,

  MSG_REQUEST_MANIFEST = 7,
  MSG_MANIFEST = 8,

  MSG_REQUEST_FILE = 9,
  MSG_FILE = 10,

  MSG_SERVER_STATUS = 11,

  NUM_MESSAGES
 };
};





namespace Protocol
{


 class IMessage
 {
 public:
  void Send( const ConnectionInfo * connection ) const;
  void Send( const ConnectionInfo * connection, const MemoryStream & payload ) const;
  void Send( const ConnectionInfo * connection, const ConstMemoryStream & payload ) const;
  void Broadcast( TCPConnectionPool * pool ) const;

  inline MessageType GetType() const { return m_MsgType; }
  inline bool HasPayload() const { return m_HasPayload; }

 protected:
  IMessage( MessageType msgType, uint32_t msgSize, bool hasPayload );


  MessageType m_MsgType;
  uint32_t m_MsgSize;
  bool m_HasPayload;
 };



 class MsgConnection : public IMessage
 {
 public:
  MsgConnection( uint32_t numJobsAvailable );

  inline uint32_t GetProtocolVersion() const { return m_ProtocolVersion; }
  inline uint32_t GetNumJobsAvailable() const { return m_NumJobsAvailable; }
  const char * GetHostName() const { return m_HostName; }
 private:
  uint32_t m_ProtocolVersion;
  uint32_t m_NumJobsAvailable;
  char m_HostName[ 64 ];
 };



 class MsgStatus : public IMessage
 {
 public:
  MsgStatus( uint32_t numJobsAvailable );

  inline uint32_t GetNumJobsAvailable() const { return m_NumJobsAvailable; }
 private:
  uint32_t m_NumJobsAvailable;
 };



 class MsgRequestJob : public IMessage
 {
 public:
  MsgRequestJob();
 };



 class MsgNoJobAvailable : public IMessage
 {
 public:
  MsgNoJobAvailable();
 };



 class MsgJob : public IMessage
 {
 public:
  MsgJob( uint64_t toolId );

  inline uint64_t GetToolId() const { return m_ToolId; }
 private:
  uint64_t m_ToolId;
 };



 class MsgJobResult : public IMessage
 {
 public:
  MsgJobResult();
 };



 class MsgRequestManifest : public IMessage
 {
 public:
  explicit MsgRequestManifest( uint64_t toolId );

  inline uint64_t GetToolId() const { return m_ToolId; }
 private:
  uint64_t m_ToolId;
 };



 class MsgManifest : public IMessage
 {
 public:
  explicit MsgManifest( uint64_t toolId );

  inline uint64_t GetToolId() const { return m_ToolId; }
 private:
  uint64_t m_ToolId;
 };



 class MsgRequestFile : public IMessage
 {
 public:
  MsgRequestFile( uint64_t toolId, uint32_t fileId );

  inline uint64_t GetToolId() const { return m_ToolId; }
  inline uint32_t GetFileId() const { return m_FileId; }
 private:
  uint64_t m_ToolId;
  uint32_t m_FileId;
 };



 class MsgFile : public IMessage
 {
 public:
  MsgFile( uint64_t toolId, uint32_t fileId );

  inline uint64_t GetToolId() const { return m_ToolId; }
  inline uint32_t GetFileId() const { return m_FileId; }
 private:
  uint64_t m_ToolId;
  uint32_t m_FileId;
 };



 class MsgServerStatus : public IMessage
 {
 public:
  MsgServerStatus();
 };
};
# 12 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/WorkerPool/WorkerBrokerage.cpp" 2






# 1 "./Core/Network/Network.h" 1


       
# 15 "./Core/Network/Network.h"
class AString;



class Network
{
public:
 static void GetHostName( AString & hostName );

 static uint32_t GetHostIPFromName( const AString & hostName, uint32_t timeoutMS = 1000 );

private:
 static uint32_t NameResolutionThreadFunc( void * userData );

 struct NameResolutionData
 {
  AStackString<> hostName;
  bool safeToFree;
 };
 static Mutex s_GetHostByNameMutex;
};
# 19 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/WorkerPool/WorkerBrokerage.cpp" 2




WorkerBrokerage::WorkerBrokerage()
 : m_Availability( false )
{

 uint32_t protocolVersion = Protocol::PROTOCOL_VERSION;


 AStackString<> root;
 if ( Env::GetEnvVariable( "FASTBUILD_BROKERAGE_PATH", root ) )
    {




            m_BrokerageRoot.Format( "%s/main/%u/", root.Get(), protocolVersion );


        FileIO::EnsurePathExists( m_BrokerageRoot );
    }
}



WorkerBrokerage::~WorkerBrokerage()
{
}



void WorkerBrokerage::FindWorkers( Array< AString > & workerList )
{
 if ( m_BrokerageRoot.IsEmpty() )
 {
  return;
 }

 Array< AString > results( 256, true );
 if ( !FileIO::GetFiles( m_BrokerageRoot,
       AStackString<>( "*" ),
       false,
       &results ) )
 {
  return;
 }


 if ( ( workerList.GetSize() + results.GetSize() ) > workerList.GetCapacity() )
 {
  workerList.SetCapacity( workerList.GetSize() + results.GetSize() );
 }


 AStackString<> hostName;
 Network::GetHostName( hostName );


 const AString * const end = results.End();
 for ( AString * it = results.Begin(); it != end; ++it )
 {
  const AString & fileName = *it;
  const char * lastSlash = fileName.FindLast( ( '/' ) );
  AStackString<> workerName( lastSlash + 1 );
  if ( workerName.CompareI( hostName ) != 0 )
  {
   workerList.Append( workerName );
  }
 }
}



void WorkerBrokerage::SetAvailability( bool available )
{

 if ( m_BrokerageRoot.IsEmpty() )
 {
  return;
 }

 if ( m_Availability == available )
 {
  return;
 }
 m_Availability = available;

 FileIO::EnsurePathExists( m_BrokerageRoot );


 AStackString<> hostName;
 Network::GetHostName( hostName );


 AStackString<> filePath;
 filePath.Format( "%s\\%s", m_BrokerageRoot.Get(), hostName.Get() );

 if ( available )
 {

  FileStream fs;
  fs.Open( filePath.Get(), FileStream::WRITE_ONLY );
 }
 else
 {

  FileIO::FileDelete( filePath.Get() );
 }
}
# 38 "/home/ffulin/p4/tmp/Unity/Tools/FBuild/FBuildCore/Unity1.cpp" 2


# 1 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/WorkerPool/WorkerThread.cpp" 1





# 1 "./Tools/FBuild/FBuildCore/PrecompiledHeader.h" 1
# 7 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/WorkerPool/WorkerThread.cpp" 2







# 1 "./Tools/FBuild/FBuildCore/WorkerPool/JobQueue.h" 1


       
# 17 "./Tools/FBuild/FBuildCore/WorkerPool/JobQueue.h"
class Node;
class Job;
class WorkerThread;




class JobSubQueue
{
public:
 explicit JobSubQueue();
 ~JobSubQueue();

 inline uint32_t GetCount() const { return m_Count; }


 void QueueJob( Job * job );


 Job * RemoveJob();
private:
 uint32_t m_Count;
 Mutex m_Mutex;
 Job * m_Head;
 Job * m_Tail;
};



class JobQueue : public Singleton< JobQueue >
{
public:
 JobQueue( uint32_t numWorkerThreads );
 ~JobQueue();


 void QueueJob( Node * node );
 void FinalizeCompletedJobs();


 void SignalStopWorkers();
 bool HaveWorkersStopped() const;


 size_t GetNumDistributableJobsAvailable() const;
 inline size_t GetDistributableJobsMemUsage() const { return m_DistributableJobsMemoryUsage; }

 void GetJobStats( uint32_t & numJobs, uint32_t & numJobsActive,
       uint32_t & numJobsDist, uint32_t & numJobsDistActive ) const;

private:

 friend class WorkerThread;
 Job * GetJobToProcess();
 Job * GetDistributableJobToRace();
 static Node::BuildResult DoBuild( Job * job );
 void FinishedProcessingJob( Job * job, bool result, bool wasARemoteJob, bool localRaceOfRemoteJob );

 void QueueJob2( Job * job );


 friend class Client;
 Job * GetDistributableJobToProcess( bool remote );
 Job * OnReturnRemoteJob( uint32_t jobId, bool & cancelled );
 void ReturnUnfinishedDistributableJob( Job * job, bool systemError = false );


 JobSubQueue m_LocalAvailableJobs[ Node::NUM_PRIORITY_LEVELS ];


 uint32_t m_NumLocalJobsActive;


 mutable Mutex m_DistributableAvailableJobsMutex;
 Array< Job * > m_DistributableAvailableJobs;
 size_t m_DistributableJobsMemoryUsage;


 mutable Mutex m_DistributedJobsMutex;
 Array< Job * > m_DistributedJobsRemote;
 Array< Job * > m_DistributedJobsLocal;
 Array< Job * > m_DistributedJobsBeingRaced;
 struct CancelledJob
 {
  inline CancelledJob( Job * job, uint32_t jobId ) : m_JobId( jobId ), m_Job( job ) {}
  inline bool operator == ( uint32_t jobId ) const { return ( m_JobId == jobId ); }
  inline bool operator == ( const Job * job ) const { return ( m_Job == job ); }
  uint32_t m_JobId;
  Job * m_Job;
 };
 Array< CancelledJob > m_DistributedJobsCancelled;


 mutable Mutex m_CompletedJobsMutex;
 Array< Job * > m_CompletedJobs;
 Array< Job * > m_CompletedJobsFailed;


 Array< Job * > m_CompletedJobs2;
 Array< Job * > m_CompletedJobsFailed2;

 Array< WorkerThread * > m_Workers;
};
# 15 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/WorkerPool/WorkerThread.cpp" 2







# 1 "./Core/Profile/Profile.h" 1


       





# 1 "./Core/Profile/ProfileManager.h" 1


       
# 19 "./Core/Profile/ProfileManager.h"
struct ProfileSection;
struct ProfileEvent;



class ProfileManager
{
public:

 static void Synchronize();



 static void Start( const char * id );
 static void Stop();
private:

 static void RegisterThread();



 friend struct ProfileEventBuffer;
 static void PushThreadEvents( const ProfileEvent * events, size_t num );

 struct ProfileEventInfo
 {
  Thread::ThreadId m_ThreadId;
  const ProfileEvent * m_Events;
  size_t m_NumEvents;
 };
 static Array< ProfileEventInfo > s_ProfileEventInfo;
};
# 10 "./Core/Profile/Profile.h" 2
# 27 "./Core/Profile/Profile.h"
 class ProfileHelper
 {
 public:
  inline ProfileHelper( const char * id )
  {
   ProfileManager::Start( id );
  }
  inline ~ProfileHelper()
  {
   ProfileManager::Stop();
  }
 private:
 };
# 23 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/WorkerPool/WorkerThread.cpp" 2



static __thread uint32_t s_WorkerThreadThreadIndex = 0;
AStackString<> WorkerThread::s_TmpRoot;


WorkerThread::WorkerThread( uint32_t threadIndex )
: m_ShouldExit( false )
, m_Exited( false )
, m_ThreadIndex( threadIndex )
{
}



void WorkerThread::Init()
{

 Thread::ThreadHandle h = Thread::CreateThread( ThreadWrapperFunc,
               "WorkerThread",
               64 * (1024),
               this );
 do { if ( !( h != (0) ) ) { if ( AssertHandler::Failure( "h != nullptr", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/WorkerPool/WorkerThread.cpp", 46 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;
 Thread::CloseHandle( h );
}


WorkerThread::~WorkerThread()
{
}



           void WorkerThread::InitTmpDir( bool remote )
{
 do { if ( !( FileIO::GetTempDir( s_TmpRoot ) ) ) { if ( AssertHandler::Failure( "FileIO::GetTempDir( s_TmpRoot )", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/WorkerPool/WorkerThread.cpp", 59 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;



        s_TmpRoot += "_fbuild.tmp/";



    AStackString<> buffer;
    const uint32_t workingDirHash = remote ? 0 : FBuild::Get().GetOptions().GetWorkingDirHash();
    buffer.Format( "0x%08x", workingDirHash );
    s_TmpRoot += buffer;
    s_TmpRoot += ( '/' );

 do { if ( !( FileIO::EnsurePathExists( s_TmpRoot ) ) ) { if ( AssertHandler::Failure( "FileIO::EnsurePathExists( s_TmpRoot )", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/WorkerPool/WorkerThread.cpp", 73 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;
}



void WorkerThread::WaitForStop()
{
 while ( m_Exited == false )
 {
  Thread::Sleep( 1 );
 }
}



           uint32_t WorkerThread::GetThreadIndex()
{
 return s_WorkerThreadThreadIndex;
}



           uint32_t WorkerThread::ThreadWrapperFunc( void * param )
{
 WorkerThread * wt = reinterpret_cast< WorkerThread * >( param );
 s_WorkerThreadThreadIndex = wt->m_ThreadIndex;

 CreateThreadLocalTmpDir();

 wt->Main();
 return 0;
}



            void WorkerThread::Main()
{
 while ( ( m_ShouldExit == false ) && ( FBuild::GetStopBuild() == false ) )
 {
  ProfileHelper ph112( __FUNCTION__ );

  bool didSomeWork = Update();
  if ( didSomeWork )
  {
   continue;
  }


  {
   ProfileHelper ph122( "WorkerThread::Main::Sleep" );
   Thread::Sleep( 1 );
  }
 }

 m_Exited = true;
}



           bool WorkerThread::Update()
{

 Job * job = JobQueue::IsValid() ? JobQueue::Get().GetJobToProcess() : (0);
 if ( job != (0) )
 {

  do { if ( !( job->GetNode()->GetState() == Node::BUILDING ) ) { if ( AssertHandler::Failure( "job->GetNode()->GetState() == Node::BUILDING", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/WorkerPool/WorkerThread.cpp", 139 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;


  Node::BuildResult result = JobQueue::DoBuild( job );

  if ( result == Node::NODE_RESULT_FAILED )
  {
   FBuild::OnBuildError();
  }

  if ( result == Node::NODE_RESULT_NEED_SECOND_BUILD_PASS )
  {
   JobQueue::Get().QueueJob2( job );
  }
  else
  {
   JobQueue::Get().FinishedProcessingJob( job, ( result != Node::NODE_RESULT_FAILED ), false, false );
  }

  return true;
 }


 if ( FBuild::Get().GetOptions().m_NoLocalConsumptionOfRemoteJobs == false )
 {
  job = JobQueue::IsValid() ? JobQueue::Get().GetDistributableJobToProcess( false ) : (0);
  if ( job != (0) )
  {

   Node::BuildResult result = JobQueueRemote::DoBuild( job, false );

   if ( result == Node::NODE_RESULT_FAILED )
   {
    FBuild::OnBuildError();
   }

   JobQueue::Get().FinishedProcessingJob( job, ( result != Node::NODE_RESULT_FAILED ), true, false );

   return true;
  }
 }


 if ( FBuild::Get().GetOptions().m_AllowLocalRace )
 {
  job = JobQueue::IsValid() ? JobQueue::Get().GetDistributableJobToRace() : (0);
  if ( job != (0) )
  {

   Node::BuildResult result = JobQueueRemote::DoBuild( job, true );

   if ( result == Node::NODE_RESULT_FAILED )
   {
    FBuild::OnBuildError();
   }

   JobQueue::Get().FinishedProcessingJob( job, ( result != Node::NODE_RESULT_FAILED ), true, true );

   return true;
  }
 }

 return false;
}



           void WorkerThread::CreateTempFilePath( const char * fileName,
              AString & tmpFileName )
{
 do { if ( !( fileName ) ) { if ( AssertHandler::Failure( "fileName", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/WorkerPool/WorkerThread.cpp", 209 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;
 do { if ( !( !s_TmpRoot.IsEmpty() ) ) { if ( AssertHandler::Failure( "!s_TmpRoot.IsEmpty()", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/WorkerPool/WorkerThread.cpp", 210 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;



 const uint32_t threadIndex = WorkerThread::GetThreadIndex();

 tmpFileName.Format( "%score_%u%c%s", s_TmpRoot.Get(), threadIndex, ( '/' ), fileName );
}



           bool WorkerThread::CreateTempFile( const AString & tmpFileName,
          FileStream & file )
{
 do { if ( !( tmpFileName.IsEmpty() == false ) ) { if ( AssertHandler::Failure( "tmpFileName.IsEmpty() == false", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/WorkerPool/WorkerThread.cpp", 224 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;
 do { if ( !( PathUtils::IsFullPath( tmpFileName ) ) ) { if ( AssertHandler::Failure( "PathUtils::IsFullPath( tmpFileName )", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/WorkerPool/WorkerThread.cpp", 225 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;
 return file.Open( tmpFileName.Get(), FileStream::WRITE_ONLY );
}



           void WorkerThread::CreateThreadLocalTmpDir()
{

 AStackString<> tmpFileName;
 CreateTempFilePath( ".tmp", tmpFileName );
 char * lastSlash = tmpFileName.FindLast( ( '/' ) );
 tmpFileName.SetLength( (uint32_t)( lastSlash - tmpFileName.Get() ) );
 FileIO::EnsurePathExists( tmpFileName );
}
# 41 "/home/ffulin/p4/tmp/Unity/Tools/FBuild/FBuildCore/Unity1.cpp" 2


# 1 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/WorkerPool/JobQueue.cpp" 1





# 1 "./Tools/FBuild/FBuildCore/PrecompiledHeader.h" 1
# 7 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/WorkerPool/JobQueue.cpp" 2
# 18 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/WorkerPool/JobQueue.cpp"
# 1 "./Core/Process/Atomic.h" 1


       
# 16 "./Core/Process/Atomic.h"
inline int32_t AtomicInc32( volatile int32_t * i )
{



  return __sync_add_and_fetch( i, 1 );

}
inline uint32_t AtomicIncU32( volatile uint32_t * i )
{



  return __sync_add_and_fetch( i, 1 );

}
inline int32_t AtomicDec32( volatile int32_t * i )
{



  return __sync_sub_and_fetch( i, 1 );

}
inline uint32_t AtomicDecU32( volatile uint32_t * i )
{



  return __sync_sub_and_fetch( i, 1 );

}



inline int64_t AtomicInc64( volatile int64_t * i )
{



  return __sync_add_and_fetch( i, 1 );

}
inline uint64_t AtomicIncU64( volatile uint64_t * i )
{



  return __sync_add_and_fetch( i, 1 );

}
inline int64_t AtomicDec64( volatile int64_t * i )
{



  return __sync_sub_and_fetch( i, 1 );

}
inline uint64_t AtomicDecU64( volatile uint64_t * i )
{



  return __sync_sub_and_fetch( i, 1 );

}
# 19 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/WorkerPool/JobQueue.cpp" 2



JobSubQueue::JobSubQueue()
 : m_Count( 0 )
 , m_Head( (0) )
 , m_Tail( (0) )
{
}



JobSubQueue::~JobSubQueue()
{
 do { if ( !( m_Head == (0) ) ) { if ( AssertHandler::Failure( "m_Head == nullptr", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/WorkerPool/JobQueue.cpp", 33 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;
 do { if ( !( m_Tail == (0) ) ) { if ( AssertHandler::Failure( "m_Tail == nullptr", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/WorkerPool/JobQueue.cpp", 34 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;
 do { if ( !( m_Count == 0 ) ) { if ( AssertHandler::Failure( "m_Count == 0", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/WorkerPool/JobQueue.cpp", 35 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;
}



void JobSubQueue::QueueJob( Job * job )
{

 MutexHolder mh( m_Mutex );

 if ( m_Head == (0) )
 {
  do { if ( !( m_Tail == (0) ) ) { if ( AssertHandler::Failure( "m_Tail == nullptr", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/WorkerPool/JobQueue.cpp", 47 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;
  m_Head = job;
  m_Tail = job;
 }
 else
 {
  do { if ( !( m_Tail ) ) { if ( AssertHandler::Failure( "m_Tail", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/WorkerPool/JobQueue.cpp", 53 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;
  m_Tail->m_Next = job;
  m_Tail = job;
 }

 ++m_Count;
}



Job * JobSubQueue::RemoveJob()
{

 if ( m_Count == 0 )
 {
  return (0);
 }


 MutexHolder mh( m_Mutex );


 if ( !m_Head )
 {
  return (0);
 }


 do { if ( !( m_Count ) ) { if ( AssertHandler::Failure( "m_Count", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/WorkerPool/JobQueue.cpp", 81 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;
 --m_Count;


 do { if ( !( m_Tail ) ) { if ( AssertHandler::Failure( "m_Tail", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/WorkerPool/JobQueue.cpp", 85 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;


 Job * job = m_Head;
 m_Head = job->m_Next;


 if ( m_Tail == job )
 {
  do { if ( !( m_Head == (0) ) ) { if ( AssertHandler::Failure( "m_Head == nullptr", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/WorkerPool/JobQueue.cpp", 94 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;
  m_Tail = (0);
 }

 return job;
}



JobQueue::JobQueue( uint32_t numWorkerThreads ) :
 m_NumLocalJobsActive( 0 ),
 m_DistributableAvailableJobs( 1024, true ),
 m_DistributableJobsMemoryUsage( 0 ),
 m_DistributedJobsRemote( 1204, true ),
 m_DistributedJobsLocal( 128, true ),
 m_DistributedJobsCancelled( 128, true ),
 m_CompletedJobs( 1024, true ),
 m_CompletedJobsFailed( 1024, true ),
 m_CompletedJobs2( 1024, true ),
 m_CompletedJobsFailed2( 1024, true ),
 m_Workers( numWorkerThreads, false )
{
 WorkerThread::InitTmpDir();

 for ( uint32_t i=0; i<numWorkerThreads; ++i )
 {


  uint32_t threadIndex = ( i + 1 );
  WorkerThread * wt = new ( "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/WorkerPool/JobQueue.cpp", 123 ) WorkerThread( threadIndex );
  wt->Init();
  m_Workers.Append( wt );
 }
}



JobQueue::~JobQueue()
{

 SignalStopWorkers();


 for ( size_t i=0; i<Node::NUM_PRIORITY_LEVELS; ++i )
 {
  while( m_LocalAvailableJobs[ i ].GetCount() > 0 )
  {
   Job * job = m_LocalAvailableJobs[ i ].RemoveJob();
   delete job;
  }
 }


 const size_t numWorkerThreads = m_Workers.GetSize();
 for ( size_t i=0; i<numWorkerThreads; ++i )
 {
  m_Workers[ i ]->WaitForStop();
  delete m_Workers[ i ];
 }
}



void JobQueue::SignalStopWorkers()
{
 const size_t numWorkerThreads = m_Workers.GetSize();
 for ( size_t i=0; i<numWorkerThreads; ++i )
 {
  m_Workers[ i ]->Stop();
 }
}



bool JobQueue::HaveWorkersStopped() const
{
 const size_t numWorkerThreads = m_Workers.GetSize();
 for ( size_t i=0; i<numWorkerThreads; ++i )
 {
  if ( m_Workers[ i ]->HasExited() == false )
  {
   return false;
  }
 }
 return true;
}



size_t JobQueue::GetNumDistributableJobsAvailable() const
{
 MutexHolder m( m_DistributableAvailableJobsMutex );
 return m_DistributableAvailableJobs.GetSize();
}



void JobQueue::GetJobStats( uint32_t & numJobs,
          uint32_t & numJobsActive,
       uint32_t & numJobsDist,
       uint32_t & numJobsDistActive ) const
{
 {
  numJobs = 0;
  for ( size_t i=0; i<Node::NUM_PRIORITY_LEVELS; ++i )
  {
   numJobs += m_LocalAvailableJobs[ i ].GetCount();
  }
  MutexHolder m( m_DistributableAvailableJobsMutex );
  numJobsDist = (uint32_t)m_DistributableAvailableJobs.GetSize();
 }
 numJobsActive = m_NumLocalJobsActive;

 MutexHolder m( m_DistributedJobsMutex );
 numJobsDistActive = (uint32_t)( m_DistributedJobsRemote.GetSize() +
         m_DistributedJobsLocal.GetSize() +
         m_DistributedJobsBeingRaced.GetSize() );
}



void JobQueue::QueueJob( Node * node )
{
 do { if ( !( node->GetState() == Node::DYNAMIC_DEPS_DONE ) ) { if ( AssertHandler::Failure( "node->GetState() == Node::DYNAMIC_DEPS_DONE", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/WorkerPool/JobQueue.cpp", 217 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;


 node->SetState( Node::BUILDING );


 if ( node->GetControlFlags() & Node::FLAG_TRIVIAL_BUILD )
 {
  Job localJob( node );
  Node::BuildResult result = DoBuild( &localJob );
  switch( result )
  {
   case Node::NODE_RESULT_FAILED: node->SetState( Node::FAILED ); break;
   case Node::NODE_RESULT_OK: node->SetState( Node::UP_TO_DATE ); break;
   default: do { if ( !( false ) ) { if ( AssertHandler::Failure( "false", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/WorkerPool/JobQueue.cpp", 231 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ; break;
  }
  return;
 }

 Job * job = new ( "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/WorkerPool/JobQueue.cpp", 236 ) Job( node );


 m_LocalAvailableJobs[ node->GetPriority() ].QueueJob( job );
}



void JobQueue::QueueJob2( Job * job )
{
 do { if ( !( job->GetNode()->GetState() == Node::BUILDING ) ) { if ( AssertHandler::Failure( "job->GetNode()->GetState() == Node::BUILDING", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/WorkerPool/JobQueue.cpp", 246 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;

 {
  MutexHolder m( m_DistributableAvailableJobsMutex );
  m_DistributableAvailableJobs.Append( job );


  m_DistributableJobsMemoryUsage += job->GetDataSize();
 }

 do { if ( !( m_NumLocalJobsActive > 0 ) ) { if ( AssertHandler::Failure( "m_NumLocalJobsActive > 0", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/WorkerPool/JobQueue.cpp", 256 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;
 AtomicDecU32( &m_NumLocalJobsActive );
}



Job * JobQueue::GetDistributableJobToProcess( bool remote )
{
 Job * job( (0) );
 {
  MutexHolder m( m_DistributableAvailableJobsMutex );
  if ( m_DistributableAvailableJobs.IsEmpty() )
  {
   return (0);
  }


  job = m_DistributableAvailableJobs[ 0 ];
  m_DistributableAvailableJobs.PopFront();


  m_DistributableJobsMemoryUsage -= job->GetDataSize();
 }

 {
  MutexHolder m( m_DistributedJobsMutex );
  if ( remote )
  {
   m_DistributedJobsRemote.Append( job );
  }
  else
  {
   m_DistributedJobsLocal.Append( job );
  }
 }

 return job;
}



Job * JobQueue::GetDistributableJobToRace()
{
 MutexHolder m( m_DistributedJobsMutex );
 if ( m_DistributedJobsRemote.IsEmpty() )
 {
  return (0);
 }



 Job * job = m_DistributedJobsRemote.Top();
 m_DistributedJobsRemote.Pop();
 m_DistributedJobsBeingRaced.Append( job );



 CancelledJob c( job, job->GetJobId() );
 m_DistributedJobsCancelled.Append( c );

 return job;
}



Job * JobQueue::OnReturnRemoteJob( uint32_t jobId, bool & cancelled )
{
 MutexHolder m( m_DistributedJobsMutex );
 CancelledJob * it = m_DistributedJobsCancelled.Find( jobId );
 if ( it )
 {
  cancelled = true;
  Job * cancelledJob = it->m_Job;
  m_DistributedJobsCancelled.Erase( it );
  return cancelledJob;
 }
 cancelled = false;



 Job ** distIt = m_DistributedJobsRemote.FindDeref( jobId );
 do { if ( !( distIt ) ) { if ( AssertHandler::Failure( "distIt", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/WorkerPool/JobQueue.cpp", 337 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;
 Job * job = *distIt;
 m_DistributedJobsRemote.Erase( distIt );
 return job;
}



void JobQueue::ReturnUnfinishedDistributableJob( Job * job, bool systemError )
{
 if ( !systemError )
 {
  MutexHolder m( m_DistributedJobsMutex );
  Job ** it = m_DistributedJobsRemote.Find( job );
  if ( it == (0) )
  {

   CancelledJob * cIt = m_DistributedJobsCancelled.Find( job );
   if ( cIt )
   {

    m_DistributedJobsCancelled.Erase( cIt );
    return;
   }

   do { if ( !( false ) ) { if ( AssertHandler::Failure( "false", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/WorkerPool/JobQueue.cpp", 362 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;
   return;
  }

  m_DistributedJobsRemote.Erase( it );
 }


 {
  MutexHolder m( m_DistributableAvailableJobsMutex );
  m_DistributableAvailableJobs.Append( job );


  m_DistributableJobsMemoryUsage += job->GetDataSize();
 }
}



void JobQueue::FinalizeCompletedJobs()
{
 {
  MutexHolder m( m_CompletedJobsMutex );
  m_CompletedJobs2.Swap( m_CompletedJobs );
  m_CompletedJobsFailed2.Swap( m_CompletedJobsFailed );
 }


 const Job * const * end = m_CompletedJobs2.End();
 for ( Job ** i = m_CompletedJobs2.Begin();
   i != end;
   i++ )
 {
  Job * job = ( *i );
  Node * n = job->GetNode();
  if ( n->Finalize() )
  {
   n->SetState( Node::UP_TO_DATE );
  }
  else
  {
   n->SetState( Node::FAILED );
  }
  delete job;
 }
 m_CompletedJobs2.Clear();


 end = m_CompletedJobsFailed2.End();
 for ( Job ** i = m_CompletedJobsFailed2.Begin();
   i != end;
   i++ )
 {
  Job * job = ( *i );
  job->GetNode()->SetState( Node::FAILED );
  delete job;
 }
 m_CompletedJobsFailed2.Clear();
}



Job * JobQueue::GetJobToProcess()
{
 for ( size_t i=0; i<Node::NUM_PRIORITY_LEVELS; ++i )
 {
  Job * job = m_LocalAvailableJobs[ i ].RemoveJob();
  if ( job )
  {
   AtomicIncU32( &m_NumLocalJobsActive );
   return job;
  }
 }

 return (0);
}



void JobQueue::FinishedProcessingJob( Job * job, bool success, bool wasARemoteJob, bool localRaceOfRemoteJob )
{
 do { if ( !( job->GetNode()->GetState() == Node::BUILDING ) ) { if ( AssertHandler::Failure( "job->GetNode()->GetState() == Node::BUILDING", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/WorkerPool/JobQueue.cpp", 443 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;

 if ( wasARemoteJob )
 {
  MutexHolder mh( m_DistributedJobsMutex );
  Job ** it = m_DistributedJobsLocal.Find( job );
  if ( it )
  {

   m_DistributedJobsLocal.Erase( it );
  }
  else
  {
   if ( localRaceOfRemoteJob )
   {
    Job ** dIt = m_DistributedJobsBeingRaced.Find( job );
    do { if ( !( dIt ) ) { if ( AssertHandler::Failure( "dIt", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/WorkerPool/JobQueue.cpp", 459 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;
    m_DistributedJobsBeingRaced.Erase( dIt );
   }
   else
   {

    do { if ( !( m_DistributedJobsRemote.Find( job ) == (0) ) ) { if ( AssertHandler::Failure( "m_DistributedJobsRemote.Find( job ) == nullptr", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/WorkerPool/JobQueue.cpp", 465 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;
   }
  }
 }
 else
 {
  do { if ( !( m_NumLocalJobsActive > 0 ) ) { if ( AssertHandler::Failure( "m_NumLocalJobsActive > 0", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/WorkerPool/JobQueue.cpp", 471 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;
  AtomicDecU32( &m_NumLocalJobsActive );
 }

 MutexHolder m( m_CompletedJobsMutex );
 if ( success )
 {
  m_CompletedJobs.Append( job );
 }
 else
 {
  m_CompletedJobsFailed.Append( job );
 }
}



           Node::BuildResult JobQueue::DoBuild( Job * job )
{
 Timer timer;

 Node * node = job->GetNode();



 if ( node->IsAFile() && ( node->GetType() != Node::FILE_NODE ) && ( node->GetType() != Node::COMPILER_NODE ) )
 {
  if ( Node::EnsurePathExistsForFile( node->GetName() ) == false )
  {

   return Node::NODE_RESULT_FAILED;
  }
 }

 Node::BuildResult result = node->DoBuild( job );

 uint32_t timeTakenMS = uint32_t( timer.GetElapsedMS() );

 if ( result == Node::NODE_RESULT_OK )
 {


  node->SetLastBuildTime( timeTakenMS );
  node->SetStatFlag( Node::STATS_BUILT );
  do { if ( FLog::ShowInfo() ) { FLog::Info( "-Build: %u ms\t%s", timeTakenMS, node->GetName().Get() ); } } while ( false ); ;
 }

 if ( result == Node::NODE_RESULT_NEED_SECOND_BUILD_PASS )
 {

 }
 else if ( node->IsAFile() )
 {
  if ( result == Node::NODE_RESULT_FAILED )
  {
   if ( node->GetControlFlags() & Node::FLAG_NO_DELETE_ON_FAIL )
   {

   }
   else
   {

    if ( FileIO::FileExists( node->GetName().Get() ) )
    {

     if ( FileIO::FileDelete( node->GetName().Get() ) == false )
     {

      do { FLog::Error( "Post failure deletion failed for '%s'", node->GetName().Get() ); } while ( false ); ;
     }
    }
   }
  }
  else
  {

   do { if ( !( ( result == Node::NODE_RESULT_OK ) || ( result == Node::NODE_RESULT_OK_CACHE ) ) ) { if ( AssertHandler::Failure( "( result == Node::NODE_RESULT_OK ) || ( result == Node::NODE_RESULT_OK_CACHE )", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/WorkerPool/JobQueue.cpp", 547 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;


   if ( node->GetType() != Node::FILE_NODE )
   {

    if ( !FileIO::FileExists( node->GetName().Get() ) )
    {
     do { FLog::Error( "File missing despite success for '%s'", node->GetName().Get() ); } while ( false ); ;
     result = Node::NODE_RESULT_FAILED;
    }
   }
  }
 }


 node->AddProcessingTime( timeTakenMS );

 return result;
}
# 44 "/home/ffulin/p4/tmp/Unity/Tools/FBuild/FBuildCore/Unity1.cpp" 2


# 1 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/WorkerPool/Job.cpp" 1





# 1 "./Tools/FBuild/FBuildCore/PrecompiledHeader.h" 1
# 7 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/WorkerPool/Job.cpp" 2
# 22 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/WorkerPool/Job.cpp"
static uint32_t s_LastJobId( 0 );



Job::Job( Node * node )
 : m_Next( (0) )
 , m_Node( node )
 , m_Data( (0) )
 , m_DataSize( 0 )
 , m_UserData( (0) )
 , m_DataIsCompressed( false )
 , m_IsLocal( true )
 , m_SystemErrorCount( 0 )
 , m_ToolManifest( (0) )
{
 m_JobId = AtomicIncU32( &s_LastJobId );
}



Job::Job( IOStream & stream )
 : m_Next( (0) )
 , m_Node( (0) )
 , m_Data( (0) )
 , m_DataSize( 0 )
 , m_UserData( (0) )
 , m_IsLocal( false )
 , m_SystemErrorCount( 0 )
 , m_ToolManifest( (0) )
{
 Deserialize( stream );
}



Job::~Job()
{
 ::Free( m_Data );

 if ( m_IsLocal == false )
 {
  delete m_Node;
 }
}



void Job::OwnData( void * data, size_t size, bool compressed )
{
 ::Free( m_Data );

 do { if ( !( size <= 0xFFFFFFFF ) ) { if ( AssertHandler::Failure( "size <= 0xFFFFFFFF", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/WorkerPool/Job.cpp", 73 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;

 m_Data = data;
 m_DataSize = (uint32_t)size;
 m_DataIsCompressed = compressed;
}



void Job::Error( const char * format, ... )
{
 AStackString< 8192 > buffer;

 va_list args;
 __builtin_va_start(args,format);
 buffer.VFormat( format, args );
 __builtin_va_end(args);

 if ( IsLocal() )
 {
  do { FLog::Error( buffer.Get() ); } while ( false ); ;
 }
 else
 {
  m_Messages.Append( buffer );
 }
}



void Job::Serialize( IOStream & stream )
{

 stream.Write( m_JobId );
 stream.Write( m_Node->GetName() );


 Node::SaveRemote( stream, m_Node );

 stream.Write( IsDataCompressed() );

 stream.Write( m_DataSize );
 stream.Write( m_Data, m_DataSize );
}



void Job::Deserialize( IOStream & stream )
{

 stream.Read( m_JobId );
 stream.Read( m_RemoteName );


 m_Node = Node::LoadRemote( stream );

 bool compressed;
 stream.Read( compressed );


 uint32_t dataSize;
 stream.Read( dataSize );
 void * data = ::AllocFileLine( dataSize, "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/WorkerPool/Job.cpp", 135 );
 stream.Read( data, dataSize );

 OwnData( data, dataSize, compressed );
}
# 47 "/home/ffulin/p4/tmp/Unity/Tools/FBuild/FBuildCore/Unity1.cpp" 2


# 1 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Error.cpp" 1





# 1 "./Tools/FBuild/FBuildCore/PrecompiledHeader.h" 1
# 7 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Error.cpp" 2

# 1 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Error.h" 1


       






# 1 "./Tools/FBuild/FBuildCore/BFF/BFFVariable.h" 1


       
# 30 "./Tools/FBuild/FBuildCore/BFF/BFFVariable.h"
class BFFVariable
{
public:
 inline const AString & GetName() const { return m_Name; }

 const AString & GetString() const { return m_StringValue; }
 const Array< AString > & GetArrayOfStrings() const { return m_ArrayValues; }
 int GetInt() const { return m_IntValue; }
 bool GetBool() const { return m_BoolValue; }
 const Array< const BFFVariable * > & GetStructMembers() const { union { const Array< BFFVariable * > * normal; const Array< const BFFVariable * > * constified; }; normal = &m_StructMembers; return *constified;; }
 const Array< const BFFVariable * > & GetArrayOfStructs() const { union { const Array< BFFVariable * > * normal; const Array< const BFFVariable * > * constified; }; normal = &m_ArrayOfStructs; return *constified;; }

 enum VarType
 {
  VAR_ANY = 0,
  VAR_STRING = 1,
  VAR_BOOL = 2,
  VAR_ARRAY_OF_STRINGS = 3,
  VAR_INT = 4,
  VAR_STRUCT = 5,
  VAR_ARRAY_OF_STRUCTS = 6,
  MAX_VAR_TYPES
 };

 inline VarType GetType() const { return m_Type; }
 inline static const char * GetTypeName( VarType t ) { return s_TypeNames[ (uint32_t)t ]; }

 inline bool IsString() const { return m_Type == BFFVariable::VAR_STRING; }
 inline bool IsBool() const { return m_Type == BFFVariable::VAR_BOOL; }
 inline bool IsArrayOfStrings() const { return m_Type == BFFVariable::VAR_ARRAY_OF_STRINGS; }
 inline bool IsInt() const { return m_Type == BFFVariable::VAR_INT; }
 inline bool IsStruct() const { return m_Type == BFFVariable::VAR_STRUCT; }
 inline bool IsArrayOfStructs() const { return m_Type == BFFVariable::VAR_ARRAY_OF_STRUCTS; }

private:
 friend class BFFStackFrame;

 explicit BFFVariable( const BFFVariable & other );

 explicit BFFVariable( const AString & name, const AString & value );
 explicit BFFVariable( const AString & name, bool value );
 explicit BFFVariable( const AString & name, const Array< AString > & values );
 explicit BFFVariable( const AString & name, int i );
 explicit BFFVariable( const AString & name, const Array< const BFFVariable * > & values );
 explicit BFFVariable( const AString & name, const Array< const BFFVariable * > & structs, VarType type );
 ~BFFVariable();

 void SetValueString( const AString & value );
 void SetValueBool( bool value );
 void SetValueArrayOfStrings( const Array< AString > & values );
 void SetValueInt( int i );
 void SetValueStruct( const Array< const BFFVariable * > & members );
 void SetValueArrayOfStructs( const Array< const BFFVariable * > & values );

 AString m_Name;


 VarType m_Type;
 AString m_StringValue;
 bool m_BoolValue;
 Array< AString > m_ArrayValues;
 int m_IntValue;
 Array< BFFVariable * > m_StructMembers;
 Array< BFFVariable * > m_ArrayOfStructs;

 static const char * s_TypeNames[ MAX_VAR_TYPES ];
};
# 11 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Error.h" 2



class AString;
class BFFIterator;
class Function;



class Error
{
public:



 static void Error_1001_MissingStringStartToken( const BFFIterator & iter,
             const Function * function );
 static void Error_1002_MatchingClosingTokenNotFound( const BFFIterator & iter,
               const Function * function,
               char expectedChar );
 static void Error_1003_EmptyStringNotAllowedInHeader( const BFFIterator & iter,
                const Function * function );
 static void Error_1004_EmptyStringPropertyNotAllowed( const BFFIterator & iter,
                const Function * function,
                const char * propertyName );
 static void Error_1005_UnsupportedNodeType( const BFFIterator & iter,
            const Function * function,
            const char * propertyName,
            const AString & nodeName,
            Node::Type nodeType );
 static void Error_1006_NothingToBuild( const BFFIterator & iter,
          const Function * function );
 static void Error_1007_ExpectedVariable( const BFFIterator & iter,
            const Function * function );
 static void Error_1008_VariableOfWrongType( const BFFIterator & iter,
            const Function * function,
            BFFVariable::VarType expectedType,
            BFFVariable::VarType foundType );
 static void Error_1009_UnknownVariable( const BFFIterator & iter,
           const Function * function );
 static void Error_1010_UnknownConstruct( const BFFIterator & iter );
 static void Error_1011_UnnamedConcatMustFollowAssignment( const BFFIterator & iter );
 static void Error_1012_UnexpectedEndOfFile( const BFFIterator & iter );
 static void Error_1013_UnexpectedCharInVariableName( const BFFIterator & iter,
                const Function * function );
 static void Error_1014_VariableNameIsTooLong( const BFFIterator & iter,
            uint32_t length,
            uint32_t maxLength );
 static void Error_1015_UnknownFunction( const BFFIterator & iter );
 static void Error_1016_UnexepectedCharFollowingVariableName( const BFFIterator & iter );
 static void Error_1017_UnexepectedCharInVariableValue( const BFFIterator & iter );
 static void Error_1018_IntegerValueCouldNotBeParsed( const BFFIterator & iter );
 static void Error_1020_FunctionCanOnlyBeInvokedOnce( const BFFIterator & iter,
                const Function * function );
 static void Error_1021_UnexpectedHeaderForFunction( const BFFIterator & iter,
               const Function * function );
 static void Error_1022_MissingFunctionHeaderCloseToken( const BFFIterator & iter,
                const Function * function );
 static void Error_1023_FunctionRequiresAHeader( const BFFIterator & iter,
              const Function * function );
 static void Error_1024_FunctionRequiresABody( const BFFIterator & iter,
            const Function * function );
 static void Error_1025_MissingScopeCloseToken( const BFFIterator & iter,
               const Function * function );
 static void Error_1026_VariableNotFoundForConcatenation( const BFFIterator & iter,
                 const AString & variableName );
 static void Error_1027_CannotConcatenate( const BFFIterator & iter,
           const AString & variableName,
           BFFVariable::VarType dstType,
           BFFVariable::VarType srcType );
 static void Error_1028_MissingVariableSubstitutionEnd( const BFFIterator & iter );
 static void Error_1029_VariableForSubstitutionIsNotAString( const BFFIterator & iter,
                 const AString & variableName,
                 BFFVariable::VarType varType );
 static void Error_1030_UnknownDirective( const BFFIterator & iter,
            const AString & directiveName );
 static void Error_1031_UnexpectedCharFollowingDirectiveName( const BFFIterator & iter,
                 const AString & directive,
                 char expectedChar );
 static void Error_1032_UnableToOpenInclude( const BFFIterator & iter,
            const AString & include );
 static void Error_1033_ErrorReadingInclude( const BFFIterator & iter,
            const AString & include,
            uint32_t errorCode );
 static void Error_1034_OperationNotSupported( const BFFIterator & rhsIter,
              BFFVariable::VarType lhs,
              BFFVariable::VarType rhs,
              const BFFIterator & operatorIter );
 static void Error_1035_ExcessiveDepthComplexity( const BFFIterator & iter );
 static void Error_1036_UnknownTokenInIfDirective( const BFFIterator & iter );
 static void Error_1037_EndIfWithoutIf( const BFFIterator & iter );



 static void Error_1050_PropertyMustBeOfType( const BFFIterator & iter,
              const Function * function,
              const char * propertyName,
              BFFVariable::VarType foundType,
              BFFVariable::VarType requiredType,
              BFFVariable::VarType alternateRequiredType = BFFVariable::VAR_ANY );
 static void Error_1054_IntegerOutOfRange( const BFFIterator & iter,
           const Function * function,
           const char * propertyName,
           int rangeMin,
           int rangeMax );




 static void Error_1100_AlreadyDefined( const BFFIterator & iter,
            const Function * function,
            const AString & name );
 static void Error_1101_MissingProperty( const BFFIterator & iter,
             const Function * function,
             const AString & name );
 static void Error_1102_UnexpectedType( const BFFIterator & iter,
            const Function * function,
            const char * propertyName,
            const AString & name,
            Node::Type foundType,
            Node::Type expectedType );
 static void Error_1103_NotAFile( const BFFIterator & iter,
         const Function * function,
         const char * propertyName,
         const AString & name,
         Node::Type foundType );
 static void Error_1104_TargetNotDefined( const BFFIterator & iter,
           const Function * function,
           const char * propertyName,
           const AString & name );
 static void Error_1105_PathNotAllowed( const BFFIterator & iter,
             const Function * function,
             const char * propertyName,
             const AString & propertyValue );
 static void Error_1106_MissingRequiredToken( const BFFIterator & iter,
             const Function * function,
             const char * propertyName,
             const char * token );



 static void Error_1200_ExpectedVar( const BFFIterator & iter,
            const Function * function );
 static void Error_1201_MissingIn( const BFFIterator & iter,
          const Function * function );
 static void Error_1202_ExpectedVarFollowingIn( const BFFIterator & iter,
              const Function * function );
 static void Error_1204_LoopVariableLengthsDiffer( const BFFIterator & iter,
              const Function * function,
              const char * variableName,
              uint32_t foundSize,
              uint32_t expectedSize );



 static void Error_1300_MissingPCHArgs( const BFFIterator & iter,
            const Function * function );
 static void Error_1301_AlreadyDefinedPCH( const BFFIterator & iter,
            const Function * function,
            const char * pch );
 static void Error_1302_MissingPCHCompilerOption( const BFFIterator & iter,
              const Function * function,
              const char * option,
              const char * property );
 static void Error_1303_PCHCreateOptionOnlyAllowedOnPCH( const BFFIterator & iter,
               const Function * function,
               const char * option,
               const char * property );
private:
 static void FormatError( const BFFIterator & iter,
        uint32_t errNum,
        const Function * function,
        const char * message, ... );
};
# 9 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Error.cpp" 2
# 1 "./Tools/FBuild/FBuildCore/BFF/BFFIterator.h" 1


       
# 18 "./Tools/FBuild/FBuildCore/BFF/BFFIterator.h"
class BFFIterator
{
public:
 inline BFFIterator()
  : m_Pos( (0) )
  , m_MinPos( (0) )
  , m_MaxPos( (0) )

  , m_FileTimeStamp( 0 ) {}
 inline BFFIterator( const char * pos, uint32_t dataSize, const char * fileName, uint64_t fileTimeStamp )
   : m_Pos( pos )
   , m_MinPos( pos )
   , m_MaxPos( pos + dataSize )
   , m_FileName( fileName )
   , m_FileTimeStamp( fileTimeStamp ) {}
 inline ~BFFIterator() {}

 void operator = ( const BFFIterator & iter );

 void operator ++ (int) { do { if ( !( m_Pos < m_MaxPos ) ) { if ( AssertHandler::Failure( "m_Pos < m_MaxPos", "./Tools/FBuild/FBuildCore/BFF/BFFIterator.h", 37 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ; m_Pos++; }
 inline bool operator < ( const BFFIterator & other ) const { return ( m_Pos < other.m_Pos ); }
 inline bool operator > ( const BFFIterator & other ) const { return ( m_Pos > other.m_Pos ); }
 char operator *() const { return *m_Pos; }
 void SkipWhiteSpace();
 void SkipComment();
 void SkipString( char quote );
 void SkipWhiteSpaceAndComments();
 void SkipVariableName();
 void SkipFunctionName();
 void SkipDirectiveName();
 bool ParseToNext( char c );
 bool ParseToMatchingBrace( char openBrace, char closeBrace );

 inline size_t GetDistTo( const BFFIterator & other ) const { do { if ( !( other.m_Pos >= m_Pos ) ) { if ( AssertHandler::Failure( "other.m_Pos >= m_Pos", "./Tools/FBuild/FBuildCore/BFF/BFFIterator.h", 51 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ; return (size_t)( other.m_Pos - m_Pos ); }


 inline const char * GetCurrent() const { return m_Pos; }
 inline void SetMax( const char * max )
 {
  do { if ( !( max >= m_Pos ) ) { if ( AssertHandler::Failure( "max >= m_Pos", "./Tools/FBuild/FBuildCore/BFF/BFFIterator.h", 57 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;
  do { if ( !( max > m_MinPos ) ) { if ( AssertHandler::Failure( "max > m_MinPos", "./Tools/FBuild/FBuildCore/BFF/BFFIterator.h", 58 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;
  m_MaxPos = max;
 }

 bool IsAtComment() const;
 bool IsAtWhitespace() const;
 bool IsAtValidVariableNameCharacter() const;
 bool IsAtValidFunctionNameCharacter() const;
 bool IsAtValidDirectiveNameCharacter() const;
 inline bool IsAtEnd() const { do { if ( !( m_Pos <= m_MaxPos ) ) { if ( AssertHandler::Failure( "m_Pos <= m_MaxPos", "./Tools/FBuild/FBuildCore/BFF/BFFIterator.h", 67 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ; return ( m_Pos == m_MaxPos ); }

 inline const AString & GetFileName() const { return m_FileName; }
 inline uint64_t GetFileTimeStamp() const { return m_FileTimeStamp; }
private:


 friend class Error;
 void GetPosInfo( uint32_t & line,
      uint32_t & column,
      const char * & lineStart ) const;

 const char * m_Pos;
 const char * m_MinPos;
 const char * m_MaxPos;
 AString m_FileName;
 uint64_t m_FileTimeStamp;
};
# 10 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Error.cpp" 2
# 1 "./Tools/FBuild/FBuildCore/BFF/BFFParser.h" 1


       
# 17 "./Tools/FBuild/FBuildCore/BFF/BFFParser.h"
class FileStream;



class BFFParser
{
public:
 explicit BFFParser();
 ~BFFParser();




 bool Parse( const char * dataWithSentinel,
       uint32_t sizeExcludingSentinel,
    const char * fileName,
    uint64_t fileTimeStamp,
    bool pushStackFrame = true );
 bool Parse( BFFIterator & iterator );

 enum { BFF_COMMENT_SEMICOLON = ';' };
 enum { BFF_COMMENT_SLASH = '/' };
 enum { BFF_DECLARE_VAR_INTERNAL = '.' };
 enum { BFF_VARIABLE_ASSIGNMENT = '=' };
 enum { BFF_VARIABLE_CONCATENATION = '+' };
 enum { BFF_START_ARRAY = '{' };
 enum { BFF_END_ARRAY = '}' };
 enum { BFF_FUNCTION_ARGS_OPEN = '(' };
 enum { BFF_FUNCTION_ARGS_CLOSE = ')' };
 enum { BFF_SCOPE_OPEN = '{' };
 enum { BFF_SCOPE_CLOSE = '}' };
 enum { BFF_STRUCT_OPEN = '[' };
 enum { BFF_STRUCT_CLOSE = ']' };
 enum { BFF_PREPROCESSOR_START = '#' };

 enum { MAX_VARIABLE_NAME_LENGTH = 64 };
 enum { MAX_FUNCTION_NAME_LENGTH = 64 };
 enum { MAX_DIRECTIVE_NAME_LENGTH = 64 };

 static bool PerformVariableSubstitutions( const BFFIterator & startIter, const BFFIterator & endIter, AString & value );

private:
 bool ParseUnnamedVariableConcatenation( BFFIterator & iter );
 bool ParseNamedVariableDeclaration( BFFIterator & parseIndex );
 bool ParseVariableDeclaration( BFFIterator & iter, const BFFIterator & varNameStart,
                const BFFIterator & varNameEnd );
 bool ParseFunction( BFFIterator & parseIndex );
 bool ParseUnnamedScope( BFFIterator & iter );
 bool ParsePreprocessorDirective( BFFIterator & iter );
 bool ParseIncludeDirective( BFFIterator & iter );
 bool ParseIfDirective( const BFFIterator & directiveStart, BFFIterator & iter );
 bool ParseEndIfDirective( const BFFIterator & directiveStart );
 bool CheckIfCondition( const BFFIterator & conditionStart, const BFFIterator & conditionEnd, bool & result );

 bool StoreVariableString( const char * varNameStart, const char * varNameEnd, const BFFIterator & valueStart, const BFFIterator & valueEnd, const BFFIterator & operatorIter );
 bool StoreVariableArray( const char * varNameStart, const char * varNameEnd, const BFFIterator & valueStart, const BFFIterator & valueEnd, const BFFIterator & operatorIter );
 bool StoreVariableStruct( const char * varNameStart, const char * varNameEnd, const BFFIterator & valueStart, const BFFIterator & valueEnd, const BFFIterator & operatorIter );
 bool StoreVariableBool( const char * varNameStart, const char * varNameEnd, bool value );
 bool StoreVariableInt( const char * varNameStart, const char * varNameEnd, int value );
 bool StoreVariableToVariable( const char * varNameDstStart, const char * varNameDstEnd,
            const BFFIterator & varNameSrcStart, const BFFIterator & varNameSrcEnd,
          const BFFIterator & operatorIter );

 bool m_SeenAVariable;
 BFFIterator m_LastVarNameStart;
 BFFIterator m_LastVarNameEnd;


 static uint32_t s_Depth;


 static uint32_t s_IfDepth;
};
# 11 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Error.cpp" 2
# 1 "./Tools/FBuild/FBuildCore/BFF/Functions/Function.h" 1


       
# 15 "./Tools/FBuild/FBuildCore/BFF/Functions/Function.h"
class BFFIterator;
class BFFVariable;
class Dependencies;
class DirectoryListNode;
class Node;



class Function
{
public:
 explicit Function( const char * functionName );
 virtual ~Function();


 inline const AString & GetName() const { return m_Name; }


 static const Function * Find( const AString & name );

 static void Create();
 static void Destroy();


 virtual bool AcceptsHeader() const;
 virtual bool NeedsHeader() const;
 virtual bool NeedsBody() const;


 virtual bool IsUnique() const;
 inline bool GetSeen() const { return m_Seen; }
 inline void SetSeen() const { m_Seen = true; }


 virtual bool ParseFunction( const BFFIterator & functionNameStart,
        const BFFIterator * functionBodyStartToken,
        const BFFIterator * functionBodyStopToken,
        const BFFIterator * functionHeaderStartToken,
        const BFFIterator * functionHeaderStopToken ) const;


 virtual bool Commit( const BFFIterator & funcStartIter ) const;

private:
 Function * m_NextFunction;
 static Function * s_FirstFunction;

protected:
 AString m_Name;
 mutable bool m_Seen;



 mutable AString m_AliasForFunction;


 bool GetString( const BFFIterator & iter, const BFFVariable * & var, const char * name, bool required = false ) const;
 bool GetString( const BFFIterator & iter, AString & var, const char * name, bool required = false ) const;
 bool GetStringOrArrayOfStrings( const BFFIterator & iter, const BFFVariable * & var, const char * name, bool required ) const;
 bool GetBool( const BFFIterator & iter, bool & var, const char * name, bool defaultValue, bool required = false ) const;
 bool GetInt( const BFFIterator & iter, int32_t & var, const char * name, int32_t defaultValue, bool required ) const;
 bool GetInt( const BFFIterator & iter, int32_t & var, const char * name, int32_t defaultValue, bool required, int minVal, int maxVal ) const;
 bool GetNodeList( const BFFIterator & iter, const char * name, Dependencies & nodes, bool required = false,
       bool allowCopyDirNodes = false, bool allowUnityNodes = false ) const;
 bool GetDirectoryListNodeList( const BFFIterator & iter,
           const Array< AString > & paths,
           const Array< AString > & excludePaths,
           bool recurse,
           const AString & pattern,
           const char * inputVarName,
           Dependencies & nodes ) const;
 bool GetStrings( const BFFIterator & iter, Array< AString > & strings, const char * name, bool required = false ) const;
 bool GetFolderPaths( const BFFIterator & iter, Array< AString > & strings, const char * name, bool required = false ) const;
 bool GetFileNode( const BFFIterator & iter, Node * & fileNode, const char * name, bool required = false ) const;


 void CleanFolderPaths( Array< AString > & folders ) const;
 void CleanFilePaths( Array< AString > & files ) const;


 bool ProcessAlias( const BFFIterator & iter, Node * nodeToAlias ) const;
 bool ProcessAlias( const BFFIterator & iter, Dependencies & nodesToAlias ) const;
private:
 bool GetNodeListRecurse( const BFFIterator & iter, const char * name, Dependencies & nodes, const AString & nodeName,
        bool allowCopyDirNodes, bool allowUnityNodes ) const;
};
# 12 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Error.cpp" 2
# 23 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Error.cpp"
           void Error::Error_1001_MissingStringStartToken( const BFFIterator & iter,
              const Function * function )
{
 FormatError( iter, 1001u, function, "Missing string start token \" or '." );
}



           void Error::Error_1002_MatchingClosingTokenNotFound( const BFFIterator & iter,
                const Function * function,
                char expectedChar )
{
 FormatError( iter, 1002u, function, "Matching closing token %c not found.",
          expectedChar );
}



           void Error::Error_1003_EmptyStringNotAllowedInHeader( const BFFIterator & iter,
                       const Function * function )
{
 FormatError( iter, 1003u, function, "Empty string not allowed in Function header." );
}



           void Error::Error_1004_EmptyStringPropertyNotAllowed( const BFFIterator & iter,
                 const Function * function,
                 const char * propertyName )
{
 FormatError( iter, 1004u, function, "Empty string not allowed for property '%s'.",
          propertyName );
}



           void Error::Error_1005_UnsupportedNodeType( const BFFIterator & iter,
             const Function * function,
             const char * propertyName,
             const AString & nodeName,
             Node::Type nodeType )
{
 FormatError( iter, 1005u, function, "Unsupported node type in '%s'. (Node: '%s', Type: '%s')",
          propertyName,
          nodeName.Get(),
          Node::GetTypeName( nodeType ) );
}



           void Error::Error_1006_NothingToBuild( const BFFIterator & iter,
              const Function * function )
{
 FormatError( iter, 1006u, function, "Nothing defined to be built." );
}



           void Error::Error_1007_ExpectedVariable( const BFFIterator & iter,
             const Function * function )
{
 FormatError( iter, 1007u, function, "Expected a variable at this location." );
}



           void Error::Error_1008_VariableOfWrongType( const BFFIterator & iter,
                const Function * function,
                BFFVariable::VarType expectedType,
                BFFVariable::VarType foundType )
{
 FormatError( iter, 1008u, function, "Expected a variable of type '%s', but got '%s'.",
          BFFVariable::GetTypeName( expectedType ),
          BFFVariable::GetTypeName( foundType ) );
}



           void Error::Error_1009_UnknownVariable( const BFFIterator & iter,
            const Function * function )
{
 FormatError( iter, 1009u, function, "Unknown variable." );
}



           void Error::Error_1010_UnknownConstruct( const BFFIterator & iter )
{
 FormatError( iter, 1010u, (0), "Unknown construct." );
}



           void Error::Error_1011_UnnamedConcatMustFollowAssignment( const BFFIterator & iter )
{
 FormatError( iter, 1011u, (0), "Unnamed concatenation must follow a variable assignment in the same scope." );
}



           void Error::Error_1012_UnexpectedEndOfFile( const BFFIterator & iter )
{
 FormatError( iter, 1012u, (0), "Unexpected end of file." );
}



           void Error::Error_1013_UnexpectedCharInVariableName( const BFFIterator & iter,
                 const Function * function )
{
 FormatError( iter, 1013u, function, "Unexpected character '%c' in variable name.", *iter );
}



           void Error::Error_1014_VariableNameIsTooLong( const BFFIterator & iter, uint32_t length, uint32_t maxLength )
{
 FormatError( iter, 1014u, (0), "Variable name is too long. (Length: %u, MaxLength: %u)", length, maxLength );
}



           void Error::Error_1015_UnknownFunction( const BFFIterator & iter )
{
 FormatError( iter, 1015u, (0), "Unknown Function." );
}



           void Error::Error_1016_UnexepectedCharFollowingVariableName( const BFFIterator & iter )
{
 FormatError( iter, 1016u, (0), "Unexpected character '%c' following variable name. (Expected operator)", *iter );
}



           void Error::Error_1017_UnexepectedCharInVariableValue( const BFFIterator & iter )
{
 FormatError( iter, 1017u, (0), "Unexpected character '%c' in variable value.", *iter );
}



           void Error::Error_1018_IntegerValueCouldNotBeParsed( const BFFIterator & iter )
{
 FormatError( iter, 1018u, (0), "Integer value could not be parsed." );
}



           void Error::Error_1020_FunctionCanOnlyBeInvokedOnce( const BFFIterator & iter, const Function * function )
{
 FormatError( iter, 1020u, function, "Function can only be invoked once." );
}



           void Error::Error_1021_UnexpectedHeaderForFunction( const BFFIterator & iter, const Function * function )
{
 FormatError( iter, 1021u, function, "Unexpected Function header." );
}



           void Error::Error_1022_MissingFunctionHeaderCloseToken( const BFFIterator & iter, const Function * function )
{
 FormatError( iter, 1022u, function, "Missing Function header close token '%c'.", BFFParser::BFF_FUNCTION_ARGS_CLOSE );
}



           void Error::Error_1023_FunctionRequiresAHeader( const BFFIterator & iter,
               const Function * function )
{
 FormatError( iter, 1023u, function, "Function requires a header." );
}



           void Error::Error_1024_FunctionRequiresABody( const BFFIterator & iter,
                const Function * function )
{
 FormatError( iter, 1024u, function, "Function requires a body." );
}



           void Error::Error_1025_MissingScopeCloseToken( const BFFIterator & iter,
                const Function * function )
{
 FormatError( iter, 1025u, function, "Missing scope close token '%c'.", BFFParser::BFF_SCOPE_CLOSE );
}



           void Error::Error_1026_VariableNotFoundForConcatenation( const BFFIterator & iter,
                  const AString & variableName )
{
 FormatError( iter, 1026u, (0), "Variable '%s' not found for concatention.", variableName.Get() );
}



           void Error::Error_1027_CannotConcatenate( const BFFIterator & iter,
               const AString & variableName,
               BFFVariable::VarType dstType,
               BFFVariable::VarType srcType )
{
 FormatError( iter, 1027u, (0), "Cannot concatenate <%s> to <%s> for Variable '%s'.",
          BFFVariable::GetTypeName( srcType ),
          BFFVariable::GetTypeName( dstType ),
          variableName.Get() );
}



           void Error::Error_1028_MissingVariableSubstitutionEnd( const BFFIterator & iter )
{
 FormatError( iter, 1028u, (0), "Cannot find '$' to end variable substitution." );
}



           void Error::Error_1029_VariableForSubstitutionIsNotAString( const BFFIterator & iter,
                  const AString & variableName,
                  BFFVariable::VarType varType )
{
 FormatError( iter, 1029u, (0), "Variable for substitution '%s' is not a string (Type: <%s>).",
          variableName.Get(),
          BFFVariable::GetTypeName( varType ) );
}



           void Error::Error_1030_UnknownDirective( const BFFIterator & iter,
             const AString & directiveName )
{
 FormatError( iter, 1030u, (0), "Unknown directive '%s'.",
          directiveName.Get() );
}



           void Error::Error_1031_UnexpectedCharFollowingDirectiveName( const BFFIterator & iter,
                  const AString & directive,
                  char expectedChar )
{
 FormatError( iter, 1031u, (0), "Unknown char '%c' following '%s' directive. (Expected '%c').",
          *iter,
          directive.Get(),
          expectedChar );
}



           void Error::Error_1032_UnableToOpenInclude( const BFFIterator & iter,
                const AString & include )
{
 FormatError( iter, 1032u, (0), "Unable to open include '%s'.",
          include.Get() );
}



           void Error::Error_1033_ErrorReadingInclude( const BFFIterator & iter,
                const AString & include,
                uint32_t errorCode )
{
 FormatError( iter, 1033u, (0), "Error reading include '%s' (Error: %u).",
            include.Get(),
            errorCode );
}



           void Error::Error_1034_OperationNotSupported( const BFFIterator & rhsIter,
               BFFVariable::VarType lhs,
               BFFVariable::VarType rhs,
               const BFFIterator & operatorIter )
{
 const char * operation = "???";
 switch ( *operatorIter )
 {
  case BFFParser::BFF_VARIABLE_ASSIGNMENT: operation = "="; break;
  case BFFParser::BFF_VARIABLE_CONCATENATION: operation = "+"; break;
  default: do { if ( !( false ) ) { if ( AssertHandler::Failure( "false", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Error.cpp", 308 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ; break;
 }

 FormatError( rhsIter, 1034u, (0), "Operation not supported: '%s' %s '%s'.",
            BFFVariable::GetTypeName( lhs ),
            operation,
            BFFVariable::GetTypeName( rhs ) );
}



           void Error::Error_1035_ExcessiveDepthComplexity( const BFFIterator & iter )
{
 FormatError( iter, 1035u, (0), "Excessive depth complexity when parsing BFFs. Check for resursive includes or simplify config." );
}



           void Error::Error_1036_UnknownTokenInIfDirective( const BFFIterator & iter )
{
 FormatError( iter, 1036u, (0), "Unknown token in #if directive." );
}



           void Error::Error_1037_EndIfWithoutIf( const BFFIterator & iter )
{
 FormatError( iter, 1037u, (0), "#endif without matching #if." );
}



           void Error::Error_1050_PropertyMustBeOfType( const BFFIterator & iter,
               const Function * function,
               const char * propertyName,
               BFFVariable::VarType foundType,
               BFFVariable::VarType requiredType,
               BFFVariable::VarType alternateRequiredType )
{
 if ( alternateRequiredType == BFFVariable::VAR_ANY )
 {
  FormatError( iter, 1050u, function, "Property '%s' must be of type <%s> (found <%s>).",
            propertyName,
            BFFVariable::GetTypeName( requiredType ),
            BFFVariable::GetTypeName( foundType ) );
 }
 else
 {
  FormatError( iter, 1050u, function, "Property '%s' must be of type <%s> or <%s> (found <%s>).",
            propertyName,
            BFFVariable::GetTypeName( requiredType ),
            BFFVariable::GetTypeName( alternateRequiredType ),
            BFFVariable::GetTypeName( foundType ) );
 }
}



           void Error::Error_1054_IntegerOutOfRange( const BFFIterator & iter,
               const Function * function,
               const char * propertyName,
               int rangeMin,
               int rangeMax )
{
 FormatError( iter, 1054u, function, "Integer '%s' must be in range %i to %i.",
           propertyName,
           rangeMin, rangeMax );
}



           void Error::Error_1100_AlreadyDefined( const BFFIterator & iter,
             const Function * function,
             const AString & name )
{
 FormatError( iter, 1100u, function, "Target '%s' already defined.",
            name.Get() );
}



           void Error::Error_1101_MissingProperty( const BFFIterator & iter,
              const Function * function,
              const AString & name )
{
 FormatError( iter, 1101u, function, "Missing required property '%s'.",
            name.Get() );
}



           void Error::Error_1102_UnexpectedType( const BFFIterator & iter,
             const Function * function,
             const char * propertyName,
             const AString & name,
             Node::Type foundType,
             Node::Type expectedType )
{
 FormatError( iter, 1102u, function, "'%s' ('%s') is of unexpected type '%s'. Expected '%s'.",
            propertyName,
            name.Get(),
            Node::GetTypeName( foundType ),
            Node::GetTypeName( expectedType ) );
}



           void Error::Error_1103_NotAFile( const BFFIterator & iter,
             const Function * function,
             const char * propertyName,
             const AString & name,
             Node::Type foundType )
{
 FormatError( iter, 1103u, function, "'%s' ('%s') is a '%s', which does not describe a file.",
            propertyName,
            name.Get(),
            Node::GetTypeName( foundType ) );
}



           void Error::Error_1104_TargetNotDefined( const BFFIterator & iter,
               const Function * function,
                  const char * propertyName,
               const AString & name )
{
 FormatError( iter, 1104u, function, "'%s' ('%s') is not defined.",
            propertyName,
            name.Get() );
}



           void Error::Error_1105_PathNotAllowed( const BFFIterator & iter,
              const Function * function,
              const char * propertyName,
              const AString & propertyValue )

{
 FormatError( iter, 1105u, function, "Path not allowed for '%s' ('%s').",
            propertyName,
            propertyValue.Get() );
}



           void Error::Error_1106_MissingRequiredToken( const BFFIterator & iter,
              const Function * function,
              const char * propertyName,
              const char * token )
{
 FormatError( iter, 1106u, function, "Property '%s' is missing required token '%s'.",
          propertyName,
             token );
}



           void Error::Error_1200_ExpectedVar( const BFFIterator & iter, const Function * function )
{
 FormatError( iter, 1200u, function, "Expected a variable at this location." );
}



           void Error::Error_1201_MissingIn( const BFFIterator & iter, const Function * function )
{
 FormatError( iter, 1201u, function, "Missing 'in' at this location." );
}



           void Error::Error_1202_ExpectedVarFollowingIn( const BFFIterator & iter, const Function * function )
{
 FormatError( iter, 1202u, function, "Expected a variable following 'in'." );
}



           void Error::Error_1204_LoopVariableLengthsDiffer( const BFFIterator & iter,
               const Function * function,
               const char * variableName,
               uint32_t foundSize,
               uint32_t expectedSize )
{
 FormatError( iter, 1204u, function, "Variable '%s' contains %u elements, but loop is for %u elements.",
            variableName,
            foundSize,
            expectedSize );
}



           void Error::Error_1300_MissingPCHArgs( const BFFIterator & iter,
             const Function * function )
{
 FormatError( iter, 1300u, function, "Precompiled Header use requires 'PCHInputFile', 'PCHOutputFile' and 'PCHOptions' parameters." );
}



           void Error::Error_1301_AlreadyDefinedPCH( const BFFIterator & iter,
             const Function * function,
             const char * pch )
{
 FormatError( iter, 1301u, function, "Precompiled Header target '%s' has already been defined.",
            pch );
}



           void Error::Error_1302_MissingPCHCompilerOption( const BFFIterator & iter,
               const Function * function,
               const char * option,
               const char * property )
{
 FormatError( iter, 1302u, function, "Missing Precompiled Header option '%s' in '%s'.", option, property );
}



           void Error::Error_1303_PCHCreateOptionOnlyAllowedOnPCH( const BFFIterator & iter,
                   const Function * function,
                   const char * option,
                   const char * property )
{
 FormatError( iter, 1303u, function, "Precompiled Header option '%s' in '%s' invalid. Only allowed on Precompiled Header.", option, property );
}



void Error::FormatError( const BFFIterator & iter,
       uint32_t errNum,
       const Function * function,
       const char * message, ... )
{
 do { if ( !( message ) ) { if ( AssertHandler::Failure( "message", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Error.cpp", 544 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;
 AStackString< 4096 > buffer;

 va_list args;
 __builtin_va_start(args,message);
 buffer.VFormat( message, args );
 __builtin_va_end(args);


 uint32_t line = 0;
 uint32_t column = 0;
 const char * lineStart = (0);
 iter.GetPosInfo( line, column, lineStart );


 const AStackString<> fileName( iter.GetFileName() );
 AStackString<> fullPath;
 NodeGraph::CleanPath( fileName, fullPath );


 Tracing::OutputFormat( "%s(%u,%u): FASTBuild Error #%04u - %s%s%s\n", fullPath.Get(), line, column, errNum, function ? function->GetName().Get() : "", function ? "() - " : "", buffer.Get() )






                 ;


 BFFIterator lineEnd( iter );
 while ( !lineEnd.IsAtEnd() )
 {
  if (( *lineEnd != '\r' ) && ( *lineEnd != '\n' ))
  {
   lineEnd++;
   continue;
  }
  break;
 }


 size_t lineLength = lineEnd.GetCurrent() - lineStart;
 if ( lineLength >= 256 )
 {
  return;
 }


 AString::Copy( lineStart, buffer.Get(), lineLength );
 do { FLog::Error( "%s", buffer.Get() ); } while ( false ); ;



 char * c = buffer.Get();
 const char * end = c + column - 1;
 for ( ; c < end; ++c )
 {
  if ( *c != '\t' )
  {
   *c = ' ';
  }
 }

 AString::Copy( "^", c, 1 );
 do { FLog::Error( buffer.Get() ); } while ( false ); ;
 AString::Copy( "\\--here", c, 8 );
 do { FLog::Error( buffer.Get() ); } while ( false ); ;
}
# 50 "/home/ffulin/p4/tmp/Unity/Tools/FBuild/FBuildCore/Unity1.cpp" 2


# 1 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/FBuildOptions.cpp" 1





# 1 "./Tools/FBuild/FBuildCore/PrecompiledHeader.h" 1
# 7 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/FBuildOptions.cpp" 2
# 23 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/FBuildOptions.cpp"
FBuildOptions::FBuildOptions()
: m_ForceCleanBuild( false )
, m_UseCacheRead( false )
, m_UseCacheWrite( false )
, m_ShowInfo( false )
, m_ShowCommandLines( false )
, m_ShowErrors( true )
, m_ShowProgress( false )
, m_AllowDistributed( false )
, m_ShowSummary( false )
, m_ShowBuildTime( true )
, m_SaveDBOnCompletion( false )
, m_GenerateReport( false )
, m_NoLocalConsumptionOfRemoteJobs( false )
, m_AllowLocalRace( true )
, m_WrapperChild( false )
, m_FixupErrorPaths( false )
, m_StopOnFirstError( true )
, m_WorkingDirHash( 0 )
{





 m_NumWorkerThreads = Env::GetNumProcessors();


    AStackString<> workingDir;
    do { if ( !( FileIO::GetCurrentDir( workingDir ) ) ) { if ( AssertHandler::Failure( "FileIO::GetCurrentDir( workingDir )", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/FBuildOptions.cpp", 52 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;
    SetWorkingDir( workingDir );
}



void FBuildOptions::SetWorkingDir( const AString & path )
{
    do { if ( !( !path.IsEmpty() ) ) { if ( AssertHandler::Failure( "!path.IsEmpty()", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/FBuildOptions.cpp", 60 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;
 m_WorkingDir = path;


 PathUtils::FixupFolderPath( m_WorkingDir );


    if ( m_WorkingDir.EndsWith( ( '/' ) ) )
    {
        m_WorkingDir.SetLength( m_WorkingDir.GetLength() - 1 );
    }
# 131 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/FBuildOptions.cpp"
        AStackString<> canonicalPath( m_WorkingDir );


    m_WorkingDirHash = Murmur3::Calc32( canonicalPath );
    m_ProcessMutexName.Format( "Global\\FASTBuild-0x%08x", m_WorkingDirHash );
    m_FinalProcessMutexName.Format( "Global\\FASTBuild_Final-0x%08x", m_WorkingDirHash );
    m_SharedMemoryName.Format( "FASTBuildSharedMemory_%08x", m_WorkingDirHash );
}
# 53 "/home/ffulin/p4/tmp/Unity/Tools/FBuild/FBuildCore/Unity1.cpp" 2


# 1 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Protocol/Server.cpp" 1





# 1 "./Tools/FBuild/FBuildCore/PrecompiledHeader.h" 1
# 7 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Protocol/Server.cpp" 2
# 27 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Protocol/Server.cpp"
Server::Server()
 : m_ShouldExit( false )
 , m_Exited( false )
 , m_RequestJobs( true )
 , m_ClientList( 32, true )
{
 m_Thread = Thread::CreateThread( ThreadFuncStatic,
          "Server",
          ( 64 * (1024) ),
          this );
 do { if ( !( m_Thread ) ) { if ( AssertHandler::Failure( "m_Thread", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Protocol/Server.cpp", 37 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;
}



Server::~Server()
{
 m_ShouldExit = true;
 while ( m_Exited == false )
 {
  Thread::Sleep( 1 );
 }

 ShutdownAllConnections();

 Thread::CloseHandle( m_Thread );

 const ToolManifest * const * end = m_Tools.End();
 for ( ToolManifest ** it = m_Tools.Begin(); it != end; ++it )
 {
  delete *it;
 }
}



           void Server::GetHostForJob( const Job * job, AString & hostName )
{
 const ClientState * cs = (const ClientState *)job->GetUserData();
 if ( cs )
 {
  hostName = cs->m_HostName;
 }
 else
 {
  hostName.Clear();
 }
}



bool Server::IsSynchingTool( AString & statusStr ) const
{
 MutexHolder manifestMH( m_ToolManifestsMutex );

 const ToolManifest * const * end = m_Tools.End();
 ToolManifest ** it = m_Tools.Begin();
 while ( it != end )
 {
  if ( ( *it )->IsSynchronized() == false )
  {
   uint32_t synchDone;
   uint32_t synchTotal;
   bool synching = ( *it )->GetSynchronizationStatus( synchDone, synchTotal );
   if ( synching )
   {
    statusStr.Format( "Synchronizing Compiler %2.1f / %2.1f MiB\n",
         (float)synchDone / (float)(1024 * 1024),
         (float)synchTotal / (float)(1024 * 1024) );
    return true;
   }
  }
  ++it;
 }

 return false;
}



            void Server::OnConnected( const ConnectionInfo * connection )
{
 ClientState * cs = new ( "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Protocol/Server.cpp", 109 ) ClientState( connection );
 connection->SetUserData( cs );

 MutexHolder mh( m_ClientListMutex );
 m_ClientList.Append( cs );
}


            void Server::OnDisconnected( const ConnectionInfo * connection )
{
 do { if ( !( connection ) ) { if ( AssertHandler::Failure( "connection", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Protocol/Server.cpp", 119 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;
 ClientState * cs = (ClientState *)connection->GetUserData();
 do { if ( !( cs ) ) { if ( AssertHandler::Failure( "cs", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Protocol/Server.cpp", 121 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;




 JobQueueRemote & jqr = JobQueueRemote::Get();
 jqr.CancelJobsWithUserData( cs );


 Array< ToolManifest * > cancelledManifests( 0, true );
 {
  MutexHolder manifestMH( m_ToolManifestsMutex );
  const ToolManifest * const * end = m_Tools.End();
  ToolManifest ** it = m_Tools.Begin();
  while ( it != end )
  {

   ToolManifest * tm = *it;
   if ( ( tm->IsSynchronized() == false ) &&
     ( tm->GetUserData() == connection ) )
   {

    tm->CancelSynchronizingFiles();
    tm->SetUserData( (0) );
    cancelledManifests.Append( tm );
   }
   ++it;
  }
 }


 MutexHolder mh( m_ClientListMutex );
 ClientState ** iter = m_ClientList.Find( cs );
 do { if ( !( iter ) ) { if ( AssertHandler::Failure( "iter", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Protocol/Server.cpp", 154 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;
 m_ClientList.Erase( iter );



 {
  ClientState ** it = m_ClientList.Begin();
  const ClientState * const * end = m_ClientList.End();
  for ( ; it != end; ++it )
  {
   ClientState * otherCS = *it;

   MutexHolder mh2( otherCS->m_Mutex );
   const Job * const * jEnd = otherCS->m_WaitingJobs.End();
   for ( Job ** jIt = otherCS->m_WaitingJobs.Begin(); jIt != jEnd; ++jIt )
   {
    Job * j = *jIt;
    ToolManifest * jMan = j->GetToolManifest();
    if ( cancelledManifests.Find( jMan ) )
    {
     RequestMissingFiles( otherCS->m_Connection, jMan );
    }
   }
  }
 }



 ::Free( (void *)( cs->m_CurrentMessage ) );


 const Job * const * end = cs->m_WaitingJobs.End();
 for ( Job ** it=cs->m_WaitingJobs.Begin(); it!=end; ++it )
 {
  delete *it;
 }

 delete cs;
}



            void Server::OnReceive( const ConnectionInfo * connection, void * data, uint32_t size, bool & keepMemory )
{
 keepMemory = true;

 ClientState * cs = (ClientState *)connection->GetUserData();
 do { if ( !( cs ) ) { if ( AssertHandler::Failure( "cs", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Protocol/Server.cpp", 201 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;


 void * payload = (0);
 size_t payloadSize = 0;
 if ( cs->m_CurrentMessage == (0) )
 {

  cs->m_CurrentMessage = reinterpret_cast< const Protocol::IMessage * >( data );
  if ( cs->m_CurrentMessage->HasPayload() )
  {
   return;
  }
 }
 else
 {

  do { if ( !( cs->m_CurrentMessage->HasPayload() ) ) { if ( AssertHandler::Failure( "cs->m_CurrentMessage->HasPayload()", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Protocol/Server.cpp", 218 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;
  payload = data;
  payloadSize = size;
 }



 const Protocol::IMessage * imsg = cs->m_CurrentMessage;
 Protocol::MessageType messageType = imsg->GetType();

 (void)0;

 switch ( messageType )
 {
  case Protocol::MSG_CONNECTION:
  {
   const Protocol::MsgConnection * msg = static_cast< const Protocol::MsgConnection * >( imsg );
   Process( connection, msg );
   break;
  }
  case Protocol::MSG_STATUS:
  {
   const Protocol::MsgStatus * msg = static_cast< const Protocol::MsgStatus * >( imsg );
   Process( connection, msg );
   break;
  }
  case Protocol::MSG_NO_JOB_AVAILABLE:
  {
   const Protocol::MsgNoJobAvailable * msg = static_cast< const Protocol::MsgNoJobAvailable * >( imsg );
   Process( connection, msg );
   break;
  }
  case Protocol::MSG_JOB:
  {
   const Protocol::MsgJob * msg = static_cast< const Protocol::MsgJob * >( imsg );
   Process( connection, msg, payload, payloadSize );
   break;
  }
  case Protocol::MSG_MANIFEST:
  {
   const Protocol::MsgManifest * msg = static_cast< const Protocol::MsgManifest * >( imsg );
   Process( connection, msg, payload, payloadSize );
   break;
  }
  case Protocol::MSG_FILE:
  {
   const Protocol::MsgFile * msg = static_cast< const Protocol::MsgFile * >( imsg );
   Process( connection, msg, payload, payloadSize );
   break;
  }
  default:
  {

   do { if ( !( false ) ) { if ( AssertHandler::Failure( "false", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Protocol/Server.cpp", 271 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;
   Disconnect( connection );
   break;
  }
 }


 ::Free( (void *)( cs->m_CurrentMessage ) );
 ::Free( payload );
 cs->m_CurrentMessage = (0);
}



void Server::Process( const ConnectionInfo * connection, const Protocol::MsgConnection * msg )
{

 if ( msg->GetProtocolVersion() != Protocol::PROTOCOL_VERSION )
 {
  AStackString<> remoteAddr;
  TCPConnectionPool::GetAddressAsString( connection->GetRemoteAddress(), remoteAddr );
  do { FLog::Warning( "Disconnecting '%s' due to bad protocol version\n", remoteAddr.Get() ); } while ( false ); ;
  Disconnect( connection );
  return;
 }


 ClientState * cs = (ClientState *)connection->GetUserData();
 cs->m_NumJobsAvailable = msg->GetNumJobsAvailable();
 cs->m_HostName = msg->GetHostName();
}



void Server::Process( const ConnectionInfo * connection, const Protocol::MsgStatus * msg )
{

 ClientState * cs = (ClientState *)connection->GetUserData();
 cs->m_NumJobsAvailable = msg->GetNumJobsAvailable();
}



void Server::Process( const ConnectionInfo * connection, const Protocol::MsgNoJobAvailable * )
{

 ClientState * cs = (ClientState *)connection->GetUserData();
 MutexHolder mh( cs->m_Mutex );
 do { if ( !( cs->m_NumJobsRequested > 0 ) ) { if ( AssertHandler::Failure( "cs->m_NumJobsRequested > 0", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Protocol/Server.cpp", 319 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;
 cs->m_NumJobsRequested--;
}



void Server::Process( const ConnectionInfo * connection, const Protocol::MsgJob * msg, const void * payload, size_t payloadSize )
{
 ClientState * cs = (ClientState *)connection->GetUserData();
 MutexHolder mh( cs->m_Mutex );
 do { if ( !( cs->m_NumJobsRequested > 0 ) ) { if ( AssertHandler::Failure( "cs->m_NumJobsRequested > 0", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Protocol/Server.cpp", 329 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;
 cs->m_NumJobsRequested--;
 cs->m_NumJobsActive++;


 ConstMemoryStream ms( payload, payloadSize );

 Job * job = new ( "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Protocol/Server.cpp", 336 ) Job( ms );
 job->SetUserData( cs );


 const uint64_t toolId = msg->GetToolId();
 do { if ( !( toolId ) ) { if ( AssertHandler::Failure( "toolId", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Protocol/Server.cpp", 341 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;

 MutexHolder manifestMH( m_ToolManifestsMutex );

 ToolManifest ** found = m_Tools.FindDeref( toolId );
 ToolManifest * manifest = found ? *found : (0);
 if ( manifest )
 {
  job->SetToolManifest( manifest );
  if ( manifest->IsSynchronized() )
  {

   JobQueueRemote::Get().QueueJob( job );
   return;
  }


  RequestMissingFiles( connection, manifest );
 }
 else
 {



  manifest = new ( "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Protocol/Server.cpp", 365 ) ToolManifest( toolId );
  job->SetToolManifest( manifest );
  m_Tools.Append( manifest );


  Protocol::MsgRequestManifest reqMsg( toolId );
  reqMsg.Send( connection );
 }


 cs->m_WaitingJobs.Append( job );
}



void Server::Process( const ConnectionInfo * connection, const Protocol::MsgManifest * msg, const void * payload, size_t payloadSize )
{
 ToolManifest * manifest = (0);
 const uint64_t toolId = msg->GetToolId();
 ConstMemoryStream ms( payload, payloadSize );

 {
  MutexHolder manifestMH( m_ToolManifestsMutex );


  ToolManifest ** found = m_Tools.FindDeref( toolId );
  do { if ( !( found ) ) { if ( AssertHandler::Failure( "found", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Protocol/Server.cpp", 391 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;
  manifest = *found;
  manifest->Deserialize( ms );
 }



 if ( manifest->IsSynchronized() )
 {
  CheckWaitingJobs( manifest );
  return;
 }

 RequestMissingFiles( connection, manifest );
}



void Server::Process( const ConnectionInfo * connection, const Protocol::MsgFile * msg, const void * payload, size_t payloadSize )
{
 const uint64_t toolId = msg->GetToolId();
 const uint32_t fileId = msg->GetFileId();


 ToolManifest * manifest = (0);
 {
  MutexHolder manifestMH( m_ToolManifestsMutex );


  ToolManifest ** found = m_Tools.FindDeref( toolId );
  do { if ( !( found ) ) { if ( AssertHandler::Failure( "found", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Protocol/Server.cpp", 421 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;
  manifest = *found;
  do { if ( !( manifest->GetUserData() == connection ) ) { if ( AssertHandler::Failure( "manifest->GetUserData() == connection", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Protocol/Server.cpp", 423 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ; (void)connection;

  if ( manifest->ReceiveFileData( fileId, payload, payloadSize ) == false )
  {

   do { FLog::Warning( "Failed to store fileId %u for manifest 0x%llx\n", fileId, toolId ); } while ( false ); ;
   Disconnect( connection );
   return;
  }

  if ( manifest->IsSynchronized() == false )
  {

   return;
  }
  manifest->SetUserData( (0) );
 }



 CheckWaitingJobs( manifest );
}



void Server::CheckWaitingJobs( const ToolManifest * manifest )
{


        bool atLeastOneJobStarted = false;


 MutexHolder mhC( m_ClientListMutex );
 const ClientState * const * end = m_ClientList.End();
 for ( ClientState ** it = m_ClientList.Begin(); it!=end; ++it )
 {

  ClientState * cs = *it;
  MutexHolder mh2( cs->m_Mutex );


  int32_t numJobs = (int32_t)cs->m_WaitingJobs.GetSize();
  for ( int32_t i=( numJobs -1 ); i >= 0; --i )
  {
   Job * job = cs->m_WaitingJobs[ i ];
   ToolManifest * manifestForThisJob = job->GetToolManifest();
   do { if ( !( manifestForThisJob ) ) { if ( AssertHandler::Failure( "manifestForThisJob", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Protocol/Server.cpp", 469 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;
   if ( manifestForThisJob == manifest )
   {
    cs->m_WaitingJobs.EraseIndex( i );
    JobQueueRemote::Get().QueueJob( job );
    (void)0;

                    atLeastOneJobStarted = true;

   }
  }
 }



 do { if ( !( atLeastOneJobStarted ) ) { if ( AssertHandler::Failure( "atLeastOneJobStarted", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Protocol/Server.cpp", 484 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;
}




           uint32_t Server::ThreadFuncStatic( void * param )
{
 Server * s = (Server *)param;
 s->ThreadFunc();
 return 0;
}



void Server::ThreadFunc()
{
 while ( m_ShouldExit == false )
 {
  FindNeedyClients();

  FinalizeCompletedJobs();

  SendServerStatus();

  Thread::Sleep( 16 );
 }

 m_Exited = true;
}



void Server::FindNeedyClients()
{
 if ( m_RequestJobs == false )
 {
  return;
 }

 MutexHolder mh( m_ClientListMutex );


 int availableJobs = (int)WorkerThreadRemote::GetNumCPUsToUse();

 ClientState ** iter = m_ClientList.Begin();
 const ClientState * const * end = m_ClientList.End();
 for ( ; iter != end; ++iter )
 {
  ClientState * cs = *iter;

  MutexHolder mh2( cs->m_Mutex );


  int reservedJobs = cs->m_NumJobsRequested +
         cs->m_NumJobsActive;
  availableJobs -= reservedJobs;
  if ( availableJobs <= 0 )
  {
   return;
  }
 }




 m_ClientList.SortDeref();

 iter = m_ClientList.Begin();
 for ( ; iter != end; ++iter )
 {
  ClientState * cs = *iter;

  MutexHolder mh2( cs->m_Mutex );

  size_t reservedJobs = cs->m_NumJobsRequested +
         cs->m_NumJobsActive;
  if ( reservedJobs >= cs->m_NumJobsAvailable )
  {
   continue;
  }


  Protocol::MsgRequestJob msg;
  msg.Send( cs->m_Connection );
  cs->m_NumJobsRequested++;
  availableJobs--;
  if ( availableJobs == 0 )
  {
   return;
  }
 }
}



void Server::FinalizeCompletedJobs()
{
 JobQueueRemote & jcr = JobQueueRemote::Get();
 while ( Job * job = jcr.GetCompletedJob() )
 {

  ClientState * cs = (ClientState *)job->GetUserData();

  MutexHolder mh( m_ClientListMutex );

  bool connectionStillActive = ( m_ClientList.Find( cs ) != (0) );
  if ( connectionStillActive )
  {
   Node::State result = job->GetNode()->GetState();
   do { if ( !( ( result == Node::UP_TO_DATE ) || ( result == Node::FAILED ) ) ) { if ( AssertHandler::Failure( "( result == Node::UP_TO_DATE ) || ( result == Node::FAILED )", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Protocol/Server.cpp", 594 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;

   MemoryStream ms;
   ms.Write( job->GetJobId() );
   ms.Write( job->GetNode()->GetName() );
   ms.Write( result == Node::UP_TO_DATE );
   ms.Write( job->GetSystemErrorCount() > 0 );
   ms.Write( job->GetMessages() );
   ms.Write( job->GetNode()->GetLastBuildTime() );


   ms.Write( (uint32_t)job->GetDataSize() );
   ms.WriteBuffer( job->GetData(), job->GetDataSize() );

   MutexHolder mh2( cs->m_Mutex );
   do { if ( !( cs->m_NumJobsActive ) ) { if ( AssertHandler::Failure( "cs->m_NumJobsActive", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Protocol/Server.cpp", 609 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;
   cs->m_NumJobsActive--;

   Protocol::MsgJobResult msg;
   msg.Send( cs->m_Connection, ms );
  }
  else
  {


  }

  delete job;
 }
}



void Server::SendServerStatus()
{
 MutexHolder mh( m_ClientListMutex );

 const ClientState * const * end = m_ClientList.End();
 for ( ClientState ** it = m_ClientList.Begin(); it != end; ++it )
 {
  ClientState * cs = *it;
  MutexHolder mh2( cs->m_Mutex );
  if ( cs->m_StatusTimer.GetElapsedMS() < Protocol::SERVER_STATUS_FREQUENCY_MS )
  {
   continue;
  }
  cs->m_StatusTimer.Start();

  Protocol::MsgServerStatus msg;
  msg.Send( cs->m_Connection );
 }
}



void Server::RequestMissingFiles( const ConnectionInfo * connection, ToolManifest * manifest ) const
{
 MutexHolder manifestMH( m_ToolManifestsMutex );

 const Array< ToolManifest::File > & files = manifest->GetFiles();
 const size_t numFiles = files.GetSize();
 for ( size_t i=0; i<numFiles; ++i )
 {
  const ToolManifest::File & f = files[ i ];
  if ( f.m_SyncState == ToolManifest::File::NOT_SYNCHRONIZED )
  {

   Protocol::MsgRequestFile reqFileMsg( manifest->GetToolId(), (uint32_t)i );
   reqFileMsg.Send( connection );


   manifest->MarkFileAsSynchronizing( i );




   do { if ( !( ( manifest->GetUserData() == (0) ) || ( manifest->GetUserData() == connection ) ) ) { if ( AssertHandler::Failure( "( manifest->GetUserData() == nullptr ) || ( manifest->GetUserData() == connection )", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Protocol/Server.cpp", 670 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;
   manifest->SetUserData( (void *)connection );
  }
 }
}
# 56 "/home/ffulin/p4/tmp/Unity/Tools/FBuild/FBuildCore/Unity1.cpp" 2


# 1 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Protocol/Protocol.cpp" 1





# 1 "./Tools/FBuild/FBuildCore/PrecompiledHeader.h" 1
# 7 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Protocol/Protocol.cpp" 2
# 15 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Protocol/Protocol.cpp"
# 1 "/usr/include/unistd.h" 1 3 4
# 27 "/usr/include/unistd.h" 3 4
extern "C" {
# 202 "/usr/include/unistd.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/posix_opt.h" 1 3 4
# 203 "/usr/include/unistd.h" 2 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/environments.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/environments.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/environments.h" 2 3 4
# 207 "/usr/include/unistd.h" 2 3 4
# 226 "/usr/include/unistd.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.9/include/stddef.h" 1 3 4
# 227 "/usr/include/unistd.h" 2 3 4
# 267 "/usr/include/unistd.h" 3 4
typedef __intptr_t intptr_t;






typedef __socklen_t socklen_t;
# 287 "/usr/include/unistd.h" 3 4
extern int access (const char *__name, int __type) throw () __attribute__ ((__nonnull__ (1)));




extern int euidaccess (const char *__name, int __type)
     throw () __attribute__ ((__nonnull__ (1)));


extern int eaccess (const char *__name, int __type)
     throw () __attribute__ ((__nonnull__ (1)));






extern int faccessat (int __fd, const char *__file, int __type, int __flag)
     throw () __attribute__ ((__nonnull__ (2))) ;
# 334 "/usr/include/unistd.h" 3 4
extern __off_t lseek (int __fd, __off_t __offset, int __whence) throw ();
# 345 "/usr/include/unistd.h" 3 4
extern __off64_t lseek64 (int __fd, __off64_t __offset, int __whence)
     throw ();






extern int close (int __fd);






extern ssize_t read (int __fd, void *__buf, size_t __nbytes) ;





extern ssize_t write (int __fd, const void *__buf, size_t __n) ;
# 376 "/usr/include/unistd.h" 3 4
extern ssize_t pread (int __fd, void *__buf, size_t __nbytes,
        __off_t __offset) ;






extern ssize_t pwrite (int __fd, const void *__buf, size_t __n,
         __off_t __offset) ;
# 404 "/usr/include/unistd.h" 3 4
extern ssize_t pread64 (int __fd, void *__buf, size_t __nbytes,
   __off64_t __offset) ;


extern ssize_t pwrite64 (int __fd, const void *__buf, size_t __n,
    __off64_t __offset) ;







extern int pipe (int __pipedes[2]) throw () ;




extern int pipe2 (int __pipedes[2], int __flags) throw () ;
# 432 "/usr/include/unistd.h" 3 4
extern unsigned int alarm (unsigned int __seconds) throw ();
# 444 "/usr/include/unistd.h" 3 4
extern unsigned int sleep (unsigned int __seconds);







extern __useconds_t ualarm (__useconds_t __value, __useconds_t __interval)
     throw ();






extern int usleep (__useconds_t __useconds);
# 469 "/usr/include/unistd.h" 3 4
extern int pause (void);



extern int chown (const char *__file, __uid_t __owner, __gid_t __group)
     throw () __attribute__ ((__nonnull__ (1))) ;



extern int fchown (int __fd, __uid_t __owner, __gid_t __group) throw () ;




extern int lchown (const char *__file, __uid_t __owner, __gid_t __group)
     throw () __attribute__ ((__nonnull__ (1))) ;






extern int fchownat (int __fd, const char *__file, __uid_t __owner,
       __gid_t __group, int __flag)
     throw () __attribute__ ((__nonnull__ (2))) ;



extern int chdir (const char *__path) throw () __attribute__ ((__nonnull__ (1))) ;



extern int fchdir (int __fd) throw () ;
# 511 "/usr/include/unistd.h" 3 4
extern char *getcwd (char *__buf, size_t __size) throw () ;





extern char *get_current_dir_name (void) throw ();







extern char *getwd (char *__buf)
     throw () __attribute__ ((__nonnull__ (1))) __attribute__ ((__deprecated__)) ;




extern int dup (int __fd) throw () ;


extern int dup2 (int __fd, int __fd2) throw ();




extern int dup3 (int __fd, int __fd2, int __flags) throw ();



extern char **__environ;

extern char **environ;





extern int execve (const char *__path, char *const __argv[],
     char *const __envp[]) throw () __attribute__ ((__nonnull__ (1, 2)));




extern int fexecve (int __fd, char *const __argv[], char *const __envp[])
     throw () __attribute__ ((__nonnull__ (2)));




extern int execv (const char *__path, char *const __argv[])
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern int execle (const char *__path, const char *__arg, ...)
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern int execl (const char *__path, const char *__arg, ...)
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern int execvp (const char *__file, char *const __argv[])
     throw () __attribute__ ((__nonnull__ (1, 2)));




extern int execlp (const char *__file, const char *__arg, ...)
     throw () __attribute__ ((__nonnull__ (1, 2)));




extern int execvpe (const char *__file, char *const __argv[],
      char *const __envp[])
     throw () __attribute__ ((__nonnull__ (1, 2)));





extern int nice (int __inc) throw () ;




extern void _exit (int __status) __attribute__ ((__noreturn__));





# 1 "/usr/include/x86_64-linux-gnu/bits/confname.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/confname.h" 3 4
enum
  {
    _PC_LINK_MAX,

    _PC_MAX_CANON,

    _PC_MAX_INPUT,

    _PC_NAME_MAX,

    _PC_PATH_MAX,

    _PC_PIPE_BUF,

    _PC_CHOWN_RESTRICTED,

    _PC_NO_TRUNC,

    _PC_VDISABLE,

    _PC_SYNC_IO,

    _PC_ASYNC_IO,

    _PC_PRIO_IO,

    _PC_SOCK_MAXBUF,

    _PC_FILESIZEBITS,

    _PC_REC_INCR_XFER_SIZE,

    _PC_REC_MAX_XFER_SIZE,

    _PC_REC_MIN_XFER_SIZE,

    _PC_REC_XFER_ALIGN,

    _PC_ALLOC_SIZE_MIN,

    _PC_SYMLINK_MAX,

    _PC_2_SYMLINKS

  };


enum
  {
    _SC_ARG_MAX,

    _SC_CHILD_MAX,

    _SC_CLK_TCK,

    _SC_NGROUPS_MAX,

    _SC_OPEN_MAX,

    _SC_STREAM_MAX,

    _SC_TZNAME_MAX,

    _SC_JOB_CONTROL,

    _SC_SAVED_IDS,

    _SC_REALTIME_SIGNALS,

    _SC_PRIORITY_SCHEDULING,

    _SC_TIMERS,

    _SC_ASYNCHRONOUS_IO,

    _SC_PRIORITIZED_IO,

    _SC_SYNCHRONIZED_IO,

    _SC_FSYNC,

    _SC_MAPPED_FILES,

    _SC_MEMLOCK,

    _SC_MEMLOCK_RANGE,

    _SC_MEMORY_PROTECTION,

    _SC_MESSAGE_PASSING,

    _SC_SEMAPHORES,

    _SC_SHARED_MEMORY_OBJECTS,

    _SC_AIO_LISTIO_MAX,

    _SC_AIO_MAX,

    _SC_AIO_PRIO_DELTA_MAX,

    _SC_DELAYTIMER_MAX,

    _SC_MQ_OPEN_MAX,

    _SC_MQ_PRIO_MAX,

    _SC_VERSION,

    _SC_PAGESIZE,


    _SC_RTSIG_MAX,

    _SC_SEM_NSEMS_MAX,

    _SC_SEM_VALUE_MAX,

    _SC_SIGQUEUE_MAX,

    _SC_TIMER_MAX,




    _SC_BC_BASE_MAX,

    _SC_BC_DIM_MAX,

    _SC_BC_SCALE_MAX,

    _SC_BC_STRING_MAX,

    _SC_COLL_WEIGHTS_MAX,

    _SC_EQUIV_CLASS_MAX,

    _SC_EXPR_NEST_MAX,

    _SC_LINE_MAX,

    _SC_RE_DUP_MAX,

    _SC_CHARCLASS_NAME_MAX,


    _SC_2_VERSION,

    _SC_2_C_BIND,

    _SC_2_C_DEV,

    _SC_2_FORT_DEV,

    _SC_2_FORT_RUN,

    _SC_2_SW_DEV,

    _SC_2_LOCALEDEF,


    _SC_PII,

    _SC_PII_XTI,

    _SC_PII_SOCKET,

    _SC_PII_INTERNET,

    _SC_PII_OSI,

    _SC_POLL,

    _SC_SELECT,

    _SC_UIO_MAXIOV,

    _SC_IOV_MAX = _SC_UIO_MAXIOV,

    _SC_PII_INTERNET_STREAM,

    _SC_PII_INTERNET_DGRAM,

    _SC_PII_OSI_COTS,

    _SC_PII_OSI_CLTS,

    _SC_PII_OSI_M,

    _SC_T_IOV_MAX,



    _SC_THREADS,

    _SC_THREAD_SAFE_FUNCTIONS,

    _SC_GETGR_R_SIZE_MAX,

    _SC_GETPW_R_SIZE_MAX,

    _SC_LOGIN_NAME_MAX,

    _SC_TTY_NAME_MAX,

    _SC_THREAD_DESTRUCTOR_ITERATIONS,

    _SC_THREAD_KEYS_MAX,

    _SC_THREAD_STACK_MIN,

    _SC_THREAD_THREADS_MAX,

    _SC_THREAD_ATTR_STACKADDR,

    _SC_THREAD_ATTR_STACKSIZE,

    _SC_THREAD_PRIORITY_SCHEDULING,

    _SC_THREAD_PRIO_INHERIT,

    _SC_THREAD_PRIO_PROTECT,

    _SC_THREAD_PROCESS_SHARED,


    _SC_NPROCESSORS_CONF,

    _SC_NPROCESSORS_ONLN,

    _SC_PHYS_PAGES,

    _SC_AVPHYS_PAGES,

    _SC_ATEXIT_MAX,

    _SC_PASS_MAX,


    _SC_XOPEN_VERSION,

    _SC_XOPEN_XCU_VERSION,

    _SC_XOPEN_UNIX,

    _SC_XOPEN_CRYPT,

    _SC_XOPEN_ENH_I18N,

    _SC_XOPEN_SHM,


    _SC_2_CHAR_TERM,

    _SC_2_C_VERSION,

    _SC_2_UPE,


    _SC_XOPEN_XPG2,

    _SC_XOPEN_XPG3,

    _SC_XOPEN_XPG4,


    _SC_CHAR_BIT,

    _SC_CHAR_MAX,

    _SC_CHAR_MIN,

    _SC_INT_MAX,

    _SC_INT_MIN,

    _SC_LONG_BIT,

    _SC_WORD_BIT,

    _SC_MB_LEN_MAX,

    _SC_NZERO,

    _SC_SSIZE_MAX,

    _SC_SCHAR_MAX,

    _SC_SCHAR_MIN,

    _SC_SHRT_MAX,

    _SC_SHRT_MIN,

    _SC_UCHAR_MAX,

    _SC_UINT_MAX,

    _SC_ULONG_MAX,

    _SC_USHRT_MAX,


    _SC_NL_ARGMAX,

    _SC_NL_LANGMAX,

    _SC_NL_MSGMAX,

    _SC_NL_NMAX,

    _SC_NL_SETMAX,

    _SC_NL_TEXTMAX,


    _SC_XBS5_ILP32_OFF32,

    _SC_XBS5_ILP32_OFFBIG,

    _SC_XBS5_LP64_OFF64,

    _SC_XBS5_LPBIG_OFFBIG,


    _SC_XOPEN_LEGACY,

    _SC_XOPEN_REALTIME,

    _SC_XOPEN_REALTIME_THREADS,


    _SC_ADVISORY_INFO,

    _SC_BARRIERS,

    _SC_BASE,

    _SC_C_LANG_SUPPORT,

    _SC_C_LANG_SUPPORT_R,

    _SC_CLOCK_SELECTION,

    _SC_CPUTIME,

    _SC_THREAD_CPUTIME,

    _SC_DEVICE_IO,

    _SC_DEVICE_SPECIFIC,

    _SC_DEVICE_SPECIFIC_R,

    _SC_FD_MGMT,

    _SC_FIFO,

    _SC_PIPE,

    _SC_FILE_ATTRIBUTES,

    _SC_FILE_LOCKING,

    _SC_FILE_SYSTEM,

    _SC_MONOTONIC_CLOCK,

    _SC_MULTI_PROCESS,

    _SC_SINGLE_PROCESS,

    _SC_NETWORKING,

    _SC_READER_WRITER_LOCKS,

    _SC_SPIN_LOCKS,

    _SC_REGEXP,

    _SC_REGEX_VERSION,

    _SC_SHELL,

    _SC_SIGNALS,

    _SC_SPAWN,

    _SC_SPORADIC_SERVER,

    _SC_THREAD_SPORADIC_SERVER,

    _SC_SYSTEM_DATABASE,

    _SC_SYSTEM_DATABASE_R,

    _SC_TIMEOUTS,

    _SC_TYPED_MEMORY_OBJECTS,

    _SC_USER_GROUPS,

    _SC_USER_GROUPS_R,

    _SC_2_PBS,

    _SC_2_PBS_ACCOUNTING,

    _SC_2_PBS_LOCATE,

    _SC_2_PBS_MESSAGE,

    _SC_2_PBS_TRACK,

    _SC_SYMLOOP_MAX,

    _SC_STREAMS,

    _SC_2_PBS_CHECKPOINT,


    _SC_V6_ILP32_OFF32,

    _SC_V6_ILP32_OFFBIG,

    _SC_V6_LP64_OFF64,

    _SC_V6_LPBIG_OFFBIG,


    _SC_HOST_NAME_MAX,

    _SC_TRACE,

    _SC_TRACE_EVENT_FILTER,

    _SC_TRACE_INHERIT,

    _SC_TRACE_LOG,


    _SC_LEVEL1_ICACHE_SIZE,

    _SC_LEVEL1_ICACHE_ASSOC,

    _SC_LEVEL1_ICACHE_LINESIZE,

    _SC_LEVEL1_DCACHE_SIZE,

    _SC_LEVEL1_DCACHE_ASSOC,

    _SC_LEVEL1_DCACHE_LINESIZE,

    _SC_LEVEL2_CACHE_SIZE,

    _SC_LEVEL2_CACHE_ASSOC,

    _SC_LEVEL2_CACHE_LINESIZE,

    _SC_LEVEL3_CACHE_SIZE,

    _SC_LEVEL3_CACHE_ASSOC,

    _SC_LEVEL3_CACHE_LINESIZE,

    _SC_LEVEL4_CACHE_SIZE,

    _SC_LEVEL4_CACHE_ASSOC,

    _SC_LEVEL4_CACHE_LINESIZE,



    _SC_IPV6 = _SC_LEVEL1_ICACHE_SIZE + 50,

    _SC_RAW_SOCKETS,


    _SC_V7_ILP32_OFF32,

    _SC_V7_ILP32_OFFBIG,

    _SC_V7_LP64_OFF64,

    _SC_V7_LPBIG_OFFBIG,


    _SC_SS_REPL_MAX,


    _SC_TRACE_EVENT_NAME_MAX,

    _SC_TRACE_NAME_MAX,

    _SC_TRACE_SYS_MAX,

    _SC_TRACE_USER_EVENT_MAX,


    _SC_XOPEN_STREAMS,


    _SC_THREAD_ROBUST_PRIO_INHERIT,

    _SC_THREAD_ROBUST_PRIO_PROTECT

  };


enum
  {
    _CS_PATH,


    _CS_V6_WIDTH_RESTRICTED_ENVS,



    _CS_GNU_LIBC_VERSION,

    _CS_GNU_LIBPTHREAD_VERSION,


    _CS_V5_WIDTH_RESTRICTED_ENVS,



    _CS_V7_WIDTH_RESTRICTED_ENVS,



    _CS_LFS_CFLAGS = 1000,

    _CS_LFS_LDFLAGS,

    _CS_LFS_LIBS,

    _CS_LFS_LINTFLAGS,

    _CS_LFS64_CFLAGS,

    _CS_LFS64_LDFLAGS,

    _CS_LFS64_LIBS,

    _CS_LFS64_LINTFLAGS,


    _CS_XBS5_ILP32_OFF32_CFLAGS = 1100,

    _CS_XBS5_ILP32_OFF32_LDFLAGS,

    _CS_XBS5_ILP32_OFF32_LIBS,

    _CS_XBS5_ILP32_OFF32_LINTFLAGS,

    _CS_XBS5_ILP32_OFFBIG_CFLAGS,

    _CS_XBS5_ILP32_OFFBIG_LDFLAGS,

    _CS_XBS5_ILP32_OFFBIG_LIBS,

    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS,

    _CS_XBS5_LP64_OFF64_CFLAGS,

    _CS_XBS5_LP64_OFF64_LDFLAGS,

    _CS_XBS5_LP64_OFF64_LIBS,

    _CS_XBS5_LP64_OFF64_LINTFLAGS,

    _CS_XBS5_LPBIG_OFFBIG_CFLAGS,

    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS,

    _CS_XBS5_LPBIG_OFFBIG_LIBS,

    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS,


    _CS_POSIX_V6_ILP32_OFF32_CFLAGS,

    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS,

    _CS_POSIX_V6_ILP32_OFF32_LIBS,

    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS,

    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS,

    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS,

    _CS_POSIX_V6_ILP32_OFFBIG_LIBS,

    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS,

    _CS_POSIX_V6_LP64_OFF64_CFLAGS,

    _CS_POSIX_V6_LP64_OFF64_LDFLAGS,

    _CS_POSIX_V6_LP64_OFF64_LIBS,

    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS,

    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS,

    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS,

    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS,

    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS,


    _CS_POSIX_V7_ILP32_OFF32_CFLAGS,

    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS,

    _CS_POSIX_V7_ILP32_OFF32_LIBS,

    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS,

    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS,

    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS,

    _CS_POSIX_V7_ILP32_OFFBIG_LIBS,

    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS,

    _CS_POSIX_V7_LP64_OFF64_CFLAGS,

    _CS_POSIX_V7_LP64_OFF64_LDFLAGS,

    _CS_POSIX_V7_LP64_OFF64_LIBS,

    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS,

    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS,

    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS,

    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS,

    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS,


    _CS_V6_ENV,

    _CS_V7_ENV

  };
# 610 "/usr/include/unistd.h" 2 3 4


extern long int pathconf (const char *__path, int __name)
     throw () __attribute__ ((__nonnull__ (1)));


extern long int fpathconf (int __fd, int __name) throw ();


extern long int sysconf (int __name) throw ();



extern size_t confstr (int __name, char *__buf, size_t __len) throw ();




extern __pid_t getpid (void) throw ();


extern __pid_t getppid (void) throw ();


extern __pid_t getpgrp (void) throw ();


extern __pid_t __getpgid (__pid_t __pid) throw ();

extern __pid_t getpgid (__pid_t __pid) throw ();






extern int setpgid (__pid_t __pid, __pid_t __pgid) throw ();
# 660 "/usr/include/unistd.h" 3 4
extern int setpgrp (void) throw ();






extern __pid_t setsid (void) throw ();



extern __pid_t getsid (__pid_t __pid) throw ();



extern __uid_t getuid (void) throw ();


extern __uid_t geteuid (void) throw ();


extern __gid_t getgid (void) throw ();


extern __gid_t getegid (void) throw ();




extern int getgroups (int __size, __gid_t __list[]) throw () ;



extern int group_member (__gid_t __gid) throw ();






extern int setuid (__uid_t __uid) throw () ;




extern int setreuid (__uid_t __ruid, __uid_t __euid) throw () ;




extern int seteuid (__uid_t __uid) throw () ;






extern int setgid (__gid_t __gid) throw () ;




extern int setregid (__gid_t __rgid, __gid_t __egid) throw () ;




extern int setegid (__gid_t __gid) throw () ;





extern int getresuid (__uid_t *__ruid, __uid_t *__euid, __uid_t *__suid)
     throw ();



extern int getresgid (__gid_t *__rgid, __gid_t *__egid, __gid_t *__sgid)
     throw ();



extern int setresuid (__uid_t __ruid, __uid_t __euid, __uid_t __suid)
     throw () ;



extern int setresgid (__gid_t __rgid, __gid_t __egid, __gid_t __sgid)
     throw () ;






extern __pid_t fork (void) throw ();







extern __pid_t vfork (void) throw ();





extern char *ttyname (int __fd) throw ();



extern int ttyname_r (int __fd, char *__buf, size_t __buflen)
     throw () __attribute__ ((__nonnull__ (2))) ;



extern int isatty (int __fd) throw ();





extern int ttyslot (void) throw ();




extern int link (const char *__from, const char *__to)
     throw () __attribute__ ((__nonnull__ (1, 2))) ;




extern int linkat (int __fromfd, const char *__from, int __tofd,
     const char *__to, int __flags)
     throw () __attribute__ ((__nonnull__ (2, 4))) ;




extern int symlink (const char *__from, const char *__to)
     throw () __attribute__ ((__nonnull__ (1, 2))) ;




extern ssize_t readlink (const char *__restrict __path,
    char *__restrict __buf, size_t __len)
     throw () __attribute__ ((__nonnull__ (1, 2))) ;




extern int symlinkat (const char *__from, int __tofd,
        const char *__to) throw () __attribute__ ((__nonnull__ (1, 3))) ;


extern ssize_t readlinkat (int __fd, const char *__restrict __path,
      char *__restrict __buf, size_t __len)
     throw () __attribute__ ((__nonnull__ (2, 3))) ;



extern int unlink (const char *__name) throw () __attribute__ ((__nonnull__ (1)));



extern int unlinkat (int __fd, const char *__name, int __flag)
     throw () __attribute__ ((__nonnull__ (2)));



extern int rmdir (const char *__path) throw () __attribute__ ((__nonnull__ (1)));



extern __pid_t tcgetpgrp (int __fd) throw ();


extern int tcsetpgrp (int __fd, __pid_t __pgrp_id) throw ();






extern char *getlogin (void);







extern int getlogin_r (char *__name, size_t __name_len) __attribute__ ((__nonnull__ (1)));




extern int setlogin (const char *__name) throw () __attribute__ ((__nonnull__ (1)));
# 871 "/usr/include/unistd.h" 3 4
# 1 "/usr/include/getopt.h" 1 3 4
# 48 "/usr/include/getopt.h" 3 4
extern "C" {
# 57 "/usr/include/getopt.h" 3 4
extern char *optarg;
# 71 "/usr/include/getopt.h" 3 4
extern int optind;




extern int opterr;



extern int optopt;
# 150 "/usr/include/getopt.h" 3 4
extern int getopt (int ___argc, char *const *___argv, const char *__shortopts)
       throw ();
# 185 "/usr/include/getopt.h" 3 4
}
# 872 "/usr/include/unistd.h" 2 3 4







extern int gethostname (char *__name, size_t __len) throw () __attribute__ ((__nonnull__ (1)));






extern int sethostname (const char *__name, size_t __len)
     throw () __attribute__ ((__nonnull__ (1))) ;



extern int sethostid (long int __id) throw () ;





extern int getdomainname (char *__name, size_t __len)
     throw () __attribute__ ((__nonnull__ (1))) ;
extern int setdomainname (const char *__name, size_t __len)
     throw () __attribute__ ((__nonnull__ (1))) ;





extern int vhangup (void) throw ();


extern int revoke (const char *__file) throw () __attribute__ ((__nonnull__ (1))) ;







extern int profil (unsigned short int *__sample_buffer, size_t __size,
     size_t __offset, unsigned int __scale)
     throw () __attribute__ ((__nonnull__ (1)));





extern int acct (const char *__name) throw ();



extern char *getusershell (void) throw ();
extern void endusershell (void) throw ();
extern void setusershell (void) throw ();





extern int daemon (int __nochdir, int __noclose) throw () ;






extern int chroot (const char *__path) throw () __attribute__ ((__nonnull__ (1))) ;



extern char *getpass (const char *__prompt) __attribute__ ((__nonnull__ (1)));







extern int fsync (int __fd);





extern int syncfs (int __fd) throw ();






extern long int gethostid (void);


extern void sync (void) throw ();





extern int getpagesize (void) throw () __attribute__ ((__const__));




extern int getdtablesize (void) throw ();
# 993 "/usr/include/unistd.h" 3 4
extern int truncate (const char *__file, __off_t __length)
     throw () __attribute__ ((__nonnull__ (1))) ;
# 1005 "/usr/include/unistd.h" 3 4
extern int truncate64 (const char *__file, __off64_t __length)
     throw () __attribute__ ((__nonnull__ (1))) ;
# 1016 "/usr/include/unistd.h" 3 4
extern int ftruncate (int __fd, __off_t __length) throw () ;
# 1026 "/usr/include/unistd.h" 3 4
extern int ftruncate64 (int __fd, __off64_t __length) throw () ;
# 1037 "/usr/include/unistd.h" 3 4
extern int brk (void *__addr) throw () ;





extern void *sbrk (intptr_t __delta) throw ();
# 1058 "/usr/include/unistd.h" 3 4
extern long int syscall (long int __sysno, ...) throw ();
# 1081 "/usr/include/unistd.h" 3 4
extern int lockf (int __fd, int __cmd, __off_t __len) ;
# 1091 "/usr/include/unistd.h" 3 4
extern int lockf64 (int __fd, int __cmd, __off64_t __len) ;
# 1112 "/usr/include/unistd.h" 3 4
extern int fdatasync (int __fildes);







extern char *crypt (const char *__key, const char *__salt)
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern void encrypt (char *__glibc_block, int __edflag)
     throw () __attribute__ ((__nonnull__ (1)));






extern void swab (const void *__restrict __from, void *__restrict __to,
    ssize_t __n) throw () __attribute__ ((__nonnull__ (1, 2)));
# 1151 "/usr/include/unistd.h" 3 4
}
# 16 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Protocol/Protocol.cpp" 2
# 47 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Protocol/Protocol.cpp"
Protocol::IMessage::IMessage( Protocol::MessageType msgType, uint32_t msgSize, bool hasPayload )
 : m_MsgType( msgType )
 , m_MsgSize( msgSize )
 , m_HasPayload( hasPayload )
{
}



void Protocol::IMessage::Send( const ConnectionInfo * connection ) const
{
 do { if ( !( connection ) ) { if ( AssertHandler::Failure( "connection", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Protocol/Protocol.cpp", 58 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;
 do { if ( !( m_HasPayload == false ) ) { if ( AssertHandler::Failure( "m_HasPayload == false", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Protocol/Protocol.cpp", 59 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;


 TCPConnectionPool & pool = connection->GetTCPConnectionPool();
 pool.Send( connection, this, m_MsgSize );
}



void Protocol::IMessage::Send( const ConnectionInfo * connection, const MemoryStream & payload ) const
{
 do { if ( !( connection ) ) { if ( AssertHandler::Failure( "connection", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Protocol/Protocol.cpp", 70 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;
 do { if ( !( m_HasPayload == true ) ) { if ( AssertHandler::Failure( "m_HasPayload == true", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Protocol/Protocol.cpp", 71 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;

 TCPConnectionPool & pool = connection->GetTCPConnectionPool();
 pool.Send( connection, this, m_MsgSize );
 pool.Send( connection, payload.GetData(), payload.GetSize() );
}



void Protocol::IMessage::Send( const ConnectionInfo * connection, const ConstMemoryStream & payload ) const
{
 do { if ( !( connection ) ) { if ( AssertHandler::Failure( "connection", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Protocol/Protocol.cpp", 82 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;
 do { if ( !( m_HasPayload == true ) ) { if ( AssertHandler::Failure( "m_HasPayload == true", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Protocol/Protocol.cpp", 83 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;

 TCPConnectionPool & pool = connection->GetTCPConnectionPool();
 pool.Send( connection, this, m_MsgSize );
 pool.Send( connection, payload.GetData(), payload.GetSize() );
}



void Protocol::IMessage::Broadcast( TCPConnectionPool * pool ) const
{
 do { if ( !( pool ) ) { if ( AssertHandler::Failure( "pool", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Protocol/Protocol.cpp", 94 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;
 do { if ( !( m_HasPayload == false ) ) { if ( AssertHandler::Failure( "m_HasPayload == false", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Protocol/Protocol.cpp", 95 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;


 pool->Broadcast( this, m_MsgSize );
}



Protocol::MsgConnection::MsgConnection( uint32_t numJobsAvailable )
 : Protocol::IMessage( Protocol::MSG_CONNECTION, sizeof( MsgConnection ), false )
 , m_ProtocolVersion( PROTOCOL_VERSION )
 , m_NumJobsAvailable( numJobsAvailable )
{
 if ( ::gethostname( m_HostName, 64 ) != 0 )
 {
  AString::Copy( "Unavailable", m_HostName, 12 );
 }
}



Protocol::MsgStatus::MsgStatus( uint32_t numJobsAvailable )
 : Protocol::IMessage( Protocol::MSG_STATUS, sizeof( MsgStatus ), false )
 , m_NumJobsAvailable( numJobsAvailable )
{
}



Protocol::MsgRequestJob::MsgRequestJob()
 : Protocol::IMessage( Protocol::MSG_REQUEST_JOB, sizeof( MsgRequestJob ), false )
{
}



Protocol::MsgNoJobAvailable::MsgNoJobAvailable()
 : Protocol::IMessage( Protocol::MSG_NO_JOB_AVAILABLE, sizeof( MsgNoJobAvailable ), false )
{
}



Protocol::MsgJob::MsgJob( uint64_t toolId )
 : Protocol::IMessage( Protocol::MSG_JOB, sizeof( MsgJob ), true )
 , m_ToolId( toolId )
{
 do { if ( !( toolId ) ) { if ( AssertHandler::Failure( "toolId", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Protocol/Protocol.cpp", 142 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;
}



Protocol::MsgJobResult::MsgJobResult()
 : Protocol::IMessage( Protocol::MSG_JOB_RESULT, sizeof( MsgJobResult ), true )
{
}



Protocol::MsgRequestManifest::MsgRequestManifest( uint64_t toolId )
 : Protocol::IMessage( Protocol::MSG_REQUEST_MANIFEST, sizeof( MsgRequestManifest ), false )
 , m_ToolId( toolId )
{
}



Protocol::MsgManifest::MsgManifest( uint64_t toolId )
 : Protocol::IMessage( Protocol::MSG_MANIFEST, sizeof( MsgManifest ), true )
 , m_ToolId( toolId )
{
}



Protocol::MsgRequestFile::MsgRequestFile( uint64_t toolId, uint32_t fileId )
 : Protocol::IMessage( Protocol::MSG_REQUEST_FILE, sizeof( MsgRequestFile ), false )
 , m_ToolId( toolId )
 , m_FileId( fileId )
{
}



Protocol::MsgFile::MsgFile( uint64_t toolId, uint32_t fileId )
 : Protocol::IMessage( Protocol::MSG_FILE, sizeof( MsgFile ), true )
 , m_ToolId( toolId )
 , m_FileId( fileId )
{
}



Protocol::MsgServerStatus::MsgServerStatus()
 : Protocol::IMessage( Protocol::MSG_SERVER_STATUS, sizeof( MsgServerStatus ), false )
{}
# 59 "/home/ffulin/p4/tmp/Unity/Tools/FBuild/FBuildCore/Unity1.cpp" 2


# 1 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Protocol/Client.cpp" 1





# 1 "./Tools/FBuild/FBuildCore/PrecompiledHeader.h" 1
# 7 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Protocol/Client.cpp" 2

# 1 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Protocol/Client.h" 1


       
# 17 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Protocol/Client.h"
class Job;
namespace Protocol
{
 class IMessage;
 class MsgJobResult;
 class MsgRequestJob;
 class MsgRequestManifest;
 class MsgRequestFile;
 class MsgServerStatus;
}
class ToolManifest;



class Client : public TCPConnectionPool
{
public:
 Client( const Array< AString > & workerList );
 ~Client();

private:
 virtual void OnDisconnected( const ConnectionInfo * connection );
 virtual void OnReceive( const ConnectionInfo * connection, void * data, uint32_t size, bool & keepMemory );

 void Process( const ConnectionInfo * connection, const Protocol::MsgRequestJob * msg );
 void Process( const ConnectionInfo * connection, const Protocol::MsgJobResult *, const void * payload, size_t payloadSize );
 void Process( const ConnectionInfo * connection, const Protocol::MsgRequestManifest * msg );
 void Process( const ConnectionInfo * connection, const Protocol::MsgRequestFile * msg );
 void Process( const ConnectionInfo * connection, const Protocol::MsgServerStatus * msg );

 const ToolManifest * FindManifest( const ConnectionInfo * connection, uint64_t toolId ) const;

 static uint32_t ThreadFuncStatic( void * param );
 void ThreadFunc();

 void LookForWorkers();
 void CommunicateJobAvailability();
 void CheckForTimeouts();

 Array< AString > m_WorkerList;
 volatile bool m_ShouldExit;
 volatile bool m_Exited;
 Thread::ThreadHandle m_Thread;


 Timer m_StatusUpdateTimer;

 struct ServerState
 {
  explicit ServerState();

  const ConnectionInfo * m_Connection;

  Mutex m_Mutex;
  const Protocol::IMessage * m_CurrentMessage;
  Timer m_DelayTimer;
  uint32_t m_NumJobsAvailable;
  Array< Job * > m_Jobs;

  Timer m_StatusTimer;

  bool m_Denylisted;
 };
 Mutex m_ServerListMutex;
 Array< ServerState > m_ServerList;
};
# 9 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Protocol/Client.cpp" 2




# 1 "./Tools/FBuild/FBuildCore/Graph/CompilerNode.h" 1


       
# 17 "./Tools/FBuild/FBuildCore/Graph/CompilerNode.h"
class CompilerNode : public FileNode
{
public:
 explicit CompilerNode( const AString & exe,
         const Dependencies & extraFiles,
         bool allowDistribution );
 virtual ~CompilerNode();

 static inline Node::Type GetType() { return Node::COMPILER_NODE; }

 static Node * Load( IOStream & stream );
 virtual void Save( IOStream & stream ) const;

 inline const ToolManifest & GetManifest() const { return m_Manifest; }

 inline bool CanBeDistributed() const { return m_AllowDistribution; }
private:
 virtual BuildResult DoBuild( Job * job );

 bool m_AllowDistribution;
 ToolManifest m_Manifest;
};
# 14 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Protocol/Client.cpp" 2
# 24 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Protocol/Client.cpp"
# 1 "./Core/Math/Random.h" 1


       
# 13 "./Core/Math/Random.h"
class Random
{
public:
 static const uint32_t CORE_RAND_MAX = 32767;


 Random();


 inline Random( uint32_t seed ) : m_Seed( seed ) {}


    uint32_t GetRand();


    float GetRandFloat()
    {
        return ( (float) GetRand() ) / ( (float)CORE_RAND_MAX );
    }


    uint32_t GetRandIndex( uint32_t size )
    {
        return ( (uint32_t)( (float) size * ( GetRand() / (CORE_RAND_MAX + 1.0) ) ) );
    }


 inline void SetSeed( uint32_t seed ) { m_Seed = seed; }
    inline uint32_t GetSeed() const { return m_Seed; }
private:
 uint32_t m_Seed;
};
# 25 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Protocol/Client.cpp" 2
# 35 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Protocol/Client.cpp"
Client::Client( const Array< AString > & workerList )
 : m_WorkerList( workerList )
 , m_ShouldExit( false )
 , m_Exited( false )
{

 m_ServerList.SetSize( workerList.GetSize() );

 m_Thread = Thread::CreateThread( ThreadFuncStatic,
          "Client",
          ( 64 * (1024) ),
          this );
 do { if ( !( m_Thread ) ) { if ( AssertHandler::Failure( "m_Thread", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Protocol/Client.cpp", 47 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;
}



Client::~Client()
{
 SetShuttingDown();

 m_ShouldExit = true;
 while ( m_Exited == false )
 {
  Thread::Sleep( 1 );
 }

 ShutdownAllConnections();

 Thread::CloseHandle( m_Thread );
}


            void Client::OnDisconnected( const ConnectionInfo * connection )
{
 do { if ( !( connection ) ) { if ( AssertHandler::Failure( "connection", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Protocol/Client.cpp", 70 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;
 ServerState * ss = (ServerState *)connection->GetUserData();
 do { if ( !( ss ) ) { if ( AssertHandler::Failure( "ss", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Protocol/Client.cpp", 72 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;

 MutexHolder mh( m_ServerListMutex );
 if ( ss->m_Jobs.IsEmpty() == false )
 {
  Job ** it = ss->m_Jobs.Begin();
  const Job * const * end = ss->m_Jobs.End();
  while ( it != end )
  {
   JobQueue::Get().ReturnUnfinishedDistributableJob( *it );
   ++it;
  }
  ss->m_Jobs.Clear();
 }



 ::Free( (void *)( ss->m_CurrentMessage ) );

 ss->m_Connection = (0);
 ss->m_CurrentMessage = (0);
}



           uint32_t Client::ThreadFuncStatic( void * param )
{
 Client * c = (Client *)param;
 c->ThreadFunc();
 return 0;
}



void Client::ThreadFunc()
{

 m_StatusUpdateTimer.Start( ( 1.0f ) * 0.5f );

 for ( ;; )
 {
  LookForWorkers();
  if ( m_ShouldExit )
  {
   break;
  }

  CommunicateJobAvailability();
  if ( m_ShouldExit )
  {
   break;
  }

  CheckForTimeouts();
  if ( m_ShouldExit )
  {
   break;
  }

  Thread::Sleep( 1 );
 }

 m_Exited = true;
}



void Client::LookForWorkers()
{
 MutexHolder mh( m_ServerListMutex );

 const size_t numWorkers( m_ServerList.GetSize() );


 size_t numConnections = 0;
 for ( size_t i=0; i<numWorkers; i++ )
 {
  if ( m_ServerList[ i ].m_Connection )
  {
   numConnections++;
  }
 }


 if ( numConnections >= ( 15 ) )
 {
  return;
 }


 if ( numConnections == numWorkers )
 {
  return;
 }




 Random r;
 size_t startIndex = r.GetRandIndex( (uint32_t)numWorkers );


 for ( size_t j=0; j<numWorkers; j++ )
 {
  const size_t i( ( j + startIndex ) % numWorkers );

  ServerState & ss = m_ServerList[ i ];
  if ( ss.m_Connection )
  {
   continue;
  }


  if ( ss.m_Denylisted )
  {
   continue;
  }


  MutexHolder mhSS( ss.m_Mutex );

  do { if ( !( ss.m_Jobs.IsEmpty() ) ) { if ( AssertHandler::Failure( "ss.m_Jobs.IsEmpty()", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Protocol/Client.cpp", 193 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;

  if ( ss.m_DelayTimer.GetElapsed() < ( 10.0f ) )
  {
   continue;
  }

  const ConnectionInfo * ci = Connect( m_WorkerList[ i ], Protocol::PROTOCOL_PORT );
  if ( ci == (0) )
  {
   ss.m_DelayTimer.Start();
  }
  else
  {
   const uint32_t numJobsAvailable( JobQueue::IsValid() ? (uint32_t)JobQueue::Get().GetNumDistributableJobsAvailable() : 0 );

   ci->SetUserData( &ss );
   ss.m_Connection = ci;
   ss.m_NumJobsAvailable = numJobsAvailable;
   ss.m_StatusTimer.Start();


   Protocol::MsgConnection msg( numJobsAvailable );
   MutexHolder mh2( ss.m_Mutex );
   msg.Send( ci );
  }


  return;
 }
}



void Client::CommunicateJobAvailability()
{

 if ( m_StatusUpdateTimer.GetElapsed() < ( 1.0f ) )
 {
  return;
 }

 m_StatusUpdateTimer.Start();


 if ( !JobQueue::IsValid() )
 {
  return;
 }


 uint32_t numJobsAvailable = (uint32_t)JobQueue::Get().GetNumDistributableJobsAvailable();
 Protocol::MsgStatus msg( numJobsAvailable );

 MutexHolder mh( m_ServerListMutex );
 if ( m_ServerList.IsEmpty() )
 {
  return;
 }


 ServerState * it = m_ServerList.Begin();
 const ServerState * const end = m_ServerList.End();
 while ( it != end )
 {
  if ( it->m_Connection )
  {
   MutexHolder ssMH( it->m_Mutex );
   if ( it->m_NumJobsAvailable != numJobsAvailable )
   {
    msg.Send( it->m_Connection );
    it->m_NumJobsAvailable = numJobsAvailable;
   }
  }
  ++it;
 }
}



void Client::CheckForTimeouts()
{
 MutexHolder mh( m_ServerListMutex );


 const ServerState * const end = m_ServerList.End();
 for ( ServerState * it = m_ServerList.Begin(); it != end; ++it )
 {
  ServerState & ss = *it;
  if ( ss.m_Connection )
  {
   MutexHolder ssMH( it->m_Mutex );
   if ( ss.m_StatusTimer.GetElapsedMS() >= Protocol::SERVER_STATUS_TIMEOUT )
   {
    Disconnect( ss.m_Connection );
   }
  }
  else
  {
   do { if ( !( ss.m_Jobs.IsEmpty() ) ) { if ( AssertHandler::Failure( "ss.m_Jobs.IsEmpty()", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Protocol/Client.cpp", 292 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;
  }
 }
}



            void Client::OnReceive( const ConnectionInfo * connection, void * data, uint32_t size, bool & keepMemory )
{
 keepMemory = true;

 MutexHolder mh( m_ServerListMutex );

 ServerState * ss = (ServerState *)connection->GetUserData();
 do { if ( !( ss ) ) { if ( AssertHandler::Failure( "ss", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Protocol/Client.cpp", 306 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;


 void * payload = (0);
 size_t payloadSize = 0;
 if ( ss->m_CurrentMessage == (0) )
 {

  ss->m_CurrentMessage = reinterpret_cast< const Protocol::IMessage * >( data );
  if ( ss->m_CurrentMessage->HasPayload() )
  {
   return;
  }
 }
 else
 {

  do { if ( !( ss->m_CurrentMessage->HasPayload() ) ) { if ( AssertHandler::Failure( "ss->m_CurrentMessage->HasPayload()", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Protocol/Client.cpp", 323 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;
  payload = data;
  payloadSize = size;
 }


 const Protocol::IMessage * imsg = ss->m_CurrentMessage;
 Protocol::MessageType messageType = imsg->GetType();

 (void)0;

 switch ( messageType )
 {
  case Protocol::MSG_REQUEST_JOB:
  {
   const Protocol::MsgRequestJob * msg = static_cast< const Protocol::MsgRequestJob * >( imsg );
   Process( connection, msg );
   break;
  }
  case Protocol::MSG_JOB_RESULT:
  {
   const Protocol::MsgJobResult * msg = static_cast< const Protocol::MsgJobResult * >( imsg );
   Process( connection, msg, payload, payloadSize );
   break;
  }
  case Protocol::MSG_REQUEST_MANIFEST:
  {
   const Protocol::MsgRequestManifest * msg = static_cast< const Protocol::MsgRequestManifest * >( imsg );
   Process( connection, msg );
   break;
  }
  case Protocol::MSG_REQUEST_FILE:
  {
   const Protocol::MsgRequestFile * msg = static_cast< const Protocol::MsgRequestFile * >( imsg );
   Process( connection, msg );
   break;
  }
  case Protocol::MSG_SERVER_STATUS:
  {
   const Protocol::MsgServerStatus * msg = static_cast< const Protocol::MsgServerStatus * >( imsg );
   Process( connection, msg );
   break;
  }
  default:
  {

   do { if ( !( false ) ) { if ( AssertHandler::Failure( "false", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Protocol/Client.cpp", 369 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;
   Disconnect( connection );
   break;
  }
 }


 ::Free( (void *)( ss->m_CurrentMessage ) );
 ::Free( payload );
 ss->m_CurrentMessage = (0);
}



void Client::Process( const ConnectionInfo * connection, const Protocol::MsgRequestJob * )
{
 if ( JobQueue::IsValid() == false )
 {
  return;
 }

 ServerState * ss = (ServerState *)connection->GetUserData();
 do { if ( !( ss ) ) { if ( AssertHandler::Failure( "ss", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Protocol/Client.cpp", 391 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;


 if ( ss->m_Denylisted )
 {
  MutexHolder mh( ss->m_Mutex );
  Protocol::MsgNoJobAvailable msg;
  msg.Send( connection );
  return;
 }

 Job * job = JobQueue::Get().GetDistributableJobToProcess( true );
 if ( job == (0) )
 {


  MutexHolder mh( ss->m_Mutex );
  Protocol::MsgNoJobAvailable msg;
  msg.Send( connection );
  return;
 }


 MemoryStream stream;
 job->Serialize( stream );

 MutexHolder mh( ss->m_Mutex );

 ss->m_Jobs.Append( job );


 Node * n = job->GetNode()->CastTo< ObjectNode >()->GetCompiler();
 const ToolManifest & manifest = n->CastTo< CompilerNode >()->GetManifest();
 uint64_t toolId = manifest.GetToolId();
 do { if ( !( toolId ) ) { if ( AssertHandler::Failure( "toolId", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Protocol/Client.cpp", 425 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;


 AStackString<> address;
 TCPConnectionPool::GetAddressAsString( connection->GetRemoteAddress(), address );
 do { FLog::Build( "-> Obj: %s <REMOTE: %s>\n", job->GetNode()->GetName().Get(), address.Get() ); } while ( false ); ;

 Protocol::MsgJob msg( toolId );
 msg.Send( connection, stream );
}



void Client::Process( const ConnectionInfo * connection, const Protocol::MsgJobResult *, const void * payload, size_t payloadSize )
{

 ServerState * ss = (ServerState *)connection->GetUserData();
 do { if ( !( ss ) ) { if ( AssertHandler::Failure( "ss", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Protocol/Client.cpp", 442 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;

 ConstMemoryStream ms( payload, payloadSize );

 uint32_t jobId = 0;
 ms.Read( jobId );

 AStackString<> name;
 ms.Read( name );

 bool result = false;
 ms.Read( result );

 bool systemError = false;
 ms.Read( systemError );

 Array< AString > messages;
 ms.Read( messages );

 uint32_t buildTime;
 ms.Read( buildTime );


 uint32_t size = 0;
 ms.Read( size );
 const void * data = (const char *)ms.GetData() + ms.Tell();


 bool cancelled( false );
 Job * job = JobQueue::Get().OnReturnRemoteJob( jobId, cancelled );

 {
  MutexHolder mh( ss->m_Mutex );
  Job ** iter = ss->m_Jobs.Find( job );
  do { if ( !( iter ) ) { if ( AssertHandler::Failure( "iter", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Protocol/Client.cpp", 476 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;
  ss->m_Jobs.Erase( iter );
 }


 if ( cancelled )
 {

  return;
 }

 if ( result == true )
 {


  ObjectNode * objectNode = job->GetNode()->CastTo< ObjectNode >();
  const AString & nodeName = objectNode->GetName();
  if ( Node::EnsurePathExistsForFile( nodeName ) == false )
  {
   do { FLog::Error( "Failed to create path for '%s'", nodeName.Get() ); } while ( false ); ;
   result = false;
  }
  else
  {
   const ObjectNode * on = job->GetNode()->CastTo< ObjectNode >();
   const uint32_t firstFileSize = *(uint32_t *)data;
   const uint32_t secondFileSize = on->IsUsingPDB() ? *(uint32_t *)( (const char *)data + sizeof( uint32_t ) + firstFileSize ) : 0;

   FileStream fs;
   if ( fs.Open( nodeName.Get(), FileStream::WRITE_ONLY ) == false )
   {
    do { FLog::Error( "Failed to create file '%s'", nodeName.Get() ); } while ( false ); ;
    result = false;
   }
   else if ( fs.WriteBuffer( (const char *)data + sizeof( uint32_t ), firstFileSize ) != firstFileSize )
   {
    do { FLog::Error( "Failed to write file '%s'", nodeName.Get() ); } while ( false ); ;
    result = false;
   }
   else if ( on->IsUsingPDB() )
   {
    data = (const void *)( (const char *)data + sizeof( uint32_t ) + firstFileSize );
    do { if ( !( ( firstFileSize + secondFileSize + ( sizeof( uint32_t ) * 2 ) ) == size ) ) { if ( AssertHandler::Failure( "( firstFileSize + secondFileSize + ( sizeof( uint32_t ) * 2 ) ) == size", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Protocol/Client.cpp", 518 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;

    AStackString<> pdbName;
    on->GetPDBName( pdbName );
    FileStream fs2;
    if ( fs2.Open( pdbName.Get(), FileStream::WRITE_ONLY ) == false )
    {
     do { FLog::Error( "Failed to create file '%s'", pdbName.Get() ); } while ( false ); ;
     result = false;
    }
    else if ( fs2.WriteBuffer( (const char *)data + sizeof( uint32_t ), secondFileSize ) != secondFileSize )
    {
     do { FLog::Error( "Failed to write file '%s'", pdbName.Get() ); } while ( false ); ;
     result = false;
    }
   }

   if ( result == true )
   {

    fs.Close();
    FileNode * f = (FileNode *)job->GetNode();
    f->m_Stamp = FileIO::GetFileLastWriteTime( nodeName );


    f->SetLastBuildTime( buildTime );
    f->SetStatFlag(Node::STATS_BUILT);
    f->SetStatFlag(Node::STATS_BUILT_REMOTE);


    if ( FBuild::Get().GetOptions().m_UseCacheWrite &&
      objectNode->ShouldUseCache() )
    {
     objectNode->WriteToCache( job );
    }
   }
  }
 }
 else
 {

  const AString & nodeName = job->GetNode()->GetName();
  AStackString< 8192 > failureOutput;
  failureOutput.Format( "PROBLEM: %s\n", nodeName.Get() );
  for ( const AString * it = messages.Begin(); it != messages.End(); ++it )
  {
   failureOutput += *it;
  }


  if ( systemError )
  {

   ss->m_Denylisted = true;


   job->OnSystemError();


   const size_t workerIndex = ( ss - m_ServerList.Begin() );
   const AString & workerName = m_WorkerList[ workerIndex ];
   do { if ( FLog::ShowInfo() ) { FLog::Info( "Remote System Failure!\n" " - Deny listed Worker: %s\n" " - Node		         : %s\n" " - Job Error Count   : %u / %u\n", workerName.Get(), job->GetNode()->GetName().Get(), job->GetSystemErrorCount(), ( 3 ) ); } } while ( false );






        ;


   if ( job->GetSystemErrorCount() < ( 3 ) )
   {

    JobQueue::Get().ReturnUnfinishedDistributableJob( job, systemError );
    return;
   }



   AStackString<> tmp;
   tmp.Format( "FBuild: Error: Task failed on %u different workers\n", (uint32_t)( 3 ) );
   if ( failureOutput.EndsWith( '\n' ) == false )
   {
    failureOutput += '\n';
   }
   failureOutput += tmp;
  }

  Node::DumpOutput( (0), failureOutput.Get(), failureOutput.GetLength(), (0) );
 }

 JobQueue::Get().FinishedProcessingJob( job, result, true, false );
}



void Client::Process( const ConnectionInfo * connection, const Protocol::MsgRequestManifest * msg )
{

 const uint64_t toolId = msg->GetToolId();
 do { if ( !( toolId ) ) { if ( AssertHandler::Failure( "toolId", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Protocol/Client.cpp", 619 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;
 const ToolManifest * manifest = FindManifest( connection, toolId );

 if ( manifest == (0) )
 {

  do { if ( !( false ) ) { if ( AssertHandler::Failure( "false", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Protocol/Client.cpp", 625 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;
  Disconnect( connection );
  return;
 }

 MemoryStream ms;
 manifest->Serialize( ms );


 Protocol::MsgManifest resultMsg( toolId );
 resultMsg.Send( connection, ms );
}



void Client::Process( const ConnectionInfo * connection, const Protocol::MsgRequestFile * msg )
{

 const uint64_t toolId = msg->GetToolId();
 do { if ( !( toolId != 0 ) ) { if ( AssertHandler::Failure( "toolId != 0", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Protocol/Client.cpp", 644 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;
 const ToolManifest * manifest = FindManifest( connection, toolId );

 if ( manifest == (0) )
 {

  do { if ( !( false ) ) { if ( AssertHandler::Failure( "false", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Protocol/Client.cpp", 650 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;
  Disconnect( connection );
  return;
 }

 const uint32_t fileId = msg->GetFileId();
 size_t dataSize( 0 );
 const void * data = manifest->GetFileData( fileId, dataSize );
 if ( !data )
 {
  do { if ( !( false ) ) { if ( AssertHandler::Failure( "false", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Protocol/Client.cpp", 660 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;
  Disconnect( connection );
  return;
 }

 ConstMemoryStream ms( data, dataSize );


 Protocol::MsgFile resultMsg( toolId, fileId );
 resultMsg.Send( connection, ms );
}



void Client::Process( const ConnectionInfo * connection, const Protocol::MsgServerStatus * msg )
{
 (void)msg;


 ServerState * ss = (ServerState *)connection->GetUserData();
 do { if ( !( ss ) ) { if ( AssertHandler::Failure( "ss", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Protocol/Client.cpp", 680 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;

 MutexHolder mh( ss->m_Mutex );
 ss->m_StatusTimer.Start();
}



const ToolManifest * Client::FindManifest( const ConnectionInfo * connection, uint64_t toolId ) const
{
 ServerState * ss = (ServerState *)connection->GetUserData();
 do { if ( !( ss ) ) { if ( AssertHandler::Failure( "ss", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Protocol/Client.cpp", 691 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;

 MutexHolder mh( ss->m_Mutex );

 for ( Job ** it = ss->m_Jobs.Begin();
    it != ss->m_Jobs.End();
    ++it )
 {
  Node * n = ( *it )->GetNode()->CastTo< ObjectNode >()->GetCompiler();
  const ToolManifest & m = n->CastTo< CompilerNode >()->GetManifest();
  if ( m.GetToolId() == toolId )
  {

   return &m;
  }
 }

 return (0);
}



Client::ServerState::ServerState()
 : m_Connection( (0) )
 , m_CurrentMessage( (0) )
 , m_Jobs( 16, true )
 , m_Denylisted( false )
{
 m_DelayTimer.Start( 999.0f );
}
# 62 "/home/ffulin/p4/tmp/Unity/Tools/FBuild/FBuildCore/Unity1.cpp" 2


# 1 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/BFF/BFFParser.cpp" 1





# 1 "./Tools/FBuild/FBuildCore/PrecompiledHeader.h" 1
# 7 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/BFF/BFFParser.cpp" 2



# 1 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/BFF/BFFStackFrame.h" 1


       
# 14 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/BFF/BFFStackFrame.h"
class AString;



class BFFStackFrame
{
public:
 explicit BFFStackFrame();
 ~BFFStackFrame();


 static void SetVarString( const AString & name,
         const AString & value,
         BFFStackFrame * frame = (0) );
 static void SetVarArrayOfStrings( const AString & name,
           const Array< AString > & values,
           BFFStackFrame * frame = (0) );
 static void SetVarBool( const AString & name,
       bool value,
       BFFStackFrame * frame = (0) );
 static void SetVarInt( const AString & name,
         int value,
         BFFStackFrame * frame = (0) );
 static void SetVarStruct( const AString & name,
         const Array< const BFFVariable * > & members,
         BFFStackFrame * frame = (0) );
 static void SetVarArrayOfStructs( const AString & name,
           const Array< const BFFVariable * > & structs,
           BFFStackFrame * frame = (0) );


 static void SetVar( const BFFVariable * var, BFFStackFrame * frame = (0) );


 static const BFFVariable * GetVar( const char * name );
 static const BFFVariable * GetVar( const AString & name );


 static const BFFVariable * GetVarAny( const AString & name );


 const Array< const BFFVariable * > & GetLocalVariables() const { union { const Array< BFFVariable * > * normal; const Array< const BFFVariable * > * constified; }; normal = &m_Variables; return *constified;; }

 static BFFStackFrame * GetCurrent() { return s_StackHead; }

 BFFStackFrame * GetParent() const { return m_Next; }

private:

 const BFFVariable * GetVariableRecurse( const AString & name ) const;

 const BFFVariable * GetVariableRecurse( const AString & nameOnly,
           BFFVariable::VarType type ) const;
 BFFVariable * GetVarMutableNoRecurse( const AString & name );


 Array< BFFVariable * > m_Variables;


 BFFStackFrame * m_Next;


 static BFFStackFrame * s_StackHead;
};
# 11 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/BFF/BFFParser.cpp" 2
# 31 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/BFF/BFFParser.cpp"
           uint32_t BFFParser::s_Depth( 0 );
           uint32_t BFFParser::s_IfDepth( 0 );



BFFParser::BFFParser()
: m_SeenAVariable( false )
{
 ++s_Depth;
}



BFFParser::~BFFParser()
{
 do { if ( !( s_Depth > 0 ) ) { if ( AssertHandler::Failure( "s_Depth > 0", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/BFF/BFFParser.cpp", 46 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;
 --s_Depth;
}



bool BFFParser::Parse( const char * dataWithSentinel,
        uint32_t sizeExcludingSentinel,
        const char * fileName,
        uint64_t fileTimeStamp,
        bool pushStackFrame )
{

 do { if ( !( dataWithSentinel[ sizeExcludingSentinel ] == '\000' ) ) { if ( AssertHandler::Failure( "dataWithSentinel[ sizeExcludingSentinel ] == '\\000'", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/BFF/BFFParser.cpp", 59 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;

 if ( FBuild::IsValid() )
 {

  AStackString<> fileNameClean;
  NodeGraph::CleanPath( AStackString<>( fileName ), fileNameClean );
  FBuild::Get().GetDependencyGraph().AddUsedFile( fileNameClean, fileTimeStamp );
 }


 BFFIterator iter( dataWithSentinel, sizeExcludingSentinel, fileName, fileTimeStamp );
 if ( pushStackFrame )
 {
  BFFStackFrame stackFrame;
  return Parse( iter );
 }
 else
 {
  return Parse( iter );
 }
}



bool BFFParser::Parse( BFFIterator & iter )
{
 for (;;)
 {
  iter.SkipWhiteSpace();


  if ( iter.IsAtComment() )
  {
   iter.SkipComment();
   continue;
  }

  const char c = *iter;
  switch ( c )
  {
   case BFF_DECLARE_VAR_INTERNAL:
   {
    if ( ParseNamedVariableDeclaration( iter ) == false )
    {
     return false;
    }
    continue;
   }
   case BFF_VARIABLE_CONCATENATION:
   {

    if ( ParseUnnamedVariableConcatenation( iter ) == false )
    {
     return false;
    }
    continue;
   }
   case BFF_SCOPE_OPEN:
   {

    if ( ParseUnnamedScope( iter ) == false )
    {
     return false;
    }
    continue;
   }
   case BFF_PREPROCESSOR_START:
   {
    if ( ParsePreprocessorDirective( iter ) == false )
    {
     return false;
    }
    continue;
   }
   default:
   {
    if ( iter.IsAtValidFunctionNameCharacter() )
    {
     if ( ParseFunction( iter ) == false )
     {
      return false;
     }
     continue;
    }
   }
  }

  iter.SkipWhiteSpace();
  if ( iter.IsAtEnd() == false )
  {
   Error::Error_1010_UnknownConstruct( iter );
   return false;
  }

  break;
 }

 return true;
}



bool BFFParser::ParseUnnamedVariableConcatenation( BFFIterator & iter )
{
 do { if ( !( *iter == BFF_VARIABLE_CONCATENATION ) ) { if ( AssertHandler::Failure( "*iter == BFF_VARIABLE_CONCATENATION", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/BFF/BFFParser.cpp", 164 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;


 if ( m_SeenAVariable == false )
 {
  Error::Error_1011_UnnamedConcatMustFollowAssignment( iter );
  return false;
 }

 return ParseVariableDeclaration( iter, m_LastVarNameStart, m_LastVarNameEnd );
}



bool BFFParser::ParseNamedVariableDeclaration( BFFIterator & iter )
{

 do { if ( !( *iter == BFF_DECLARE_VAR_INTERNAL ) ) { if ( AssertHandler::Failure( "*iter == BFF_DECLARE_VAR_INTERNAL", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/BFF/BFFParser.cpp", 181 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;
 m_LastVarNameStart = iter;
 iter++;


 if ( iter.IsAtEnd() )
 {
  Error::Error_1012_UnexpectedEndOfFile( iter );
  return false;
 }


 if ( iter.IsAtValidVariableNameCharacter() == false )
 {
  Error::Error_1013_UnexpectedCharInVariableName( iter, (0) );
  return false;
 }


 iter.SkipVariableName();
 if ( iter.IsAtEnd() )
 {
  Error::Error_1012_UnexpectedEndOfFile( iter );
  return false;
 }
 m_LastVarNameEnd = iter;


 size_t varNameLen = m_LastVarNameStart.GetDistTo( m_LastVarNameEnd );
 if ( varNameLen > MAX_VARIABLE_NAME_LENGTH )
 {
  Error::Error_1014_VariableNameIsTooLong( iter, (uint32_t)varNameLen, (uint32_t)MAX_VARIABLE_NAME_LENGTH );
  return false;
 }


 iter.SkipWhiteSpaceAndComments();
 if ( iter.IsAtEnd() )
 {
  Error::Error_1012_UnexpectedEndOfFile( iter );
  return false;
 }

 return ParseVariableDeclaration( iter, m_LastVarNameStart, m_LastVarNameEnd );
}



bool BFFParser::ParseVariableDeclaration( BFFIterator & iter, const BFFIterator & varNameStart,
                 const BFFIterator & varNameEnd )
{
 m_SeenAVariable = true;


 BFFIterator operatorIter( iter );
 bool concatenation = false;
 if ( *iter == BFF_VARIABLE_ASSIGNMENT )
 {

 }
 else if ( *iter == BFF_VARIABLE_CONCATENATION )
 {

  concatenation = true;
 }
 else
 {
  Error::Error_1016_UnexepectedCharFollowingVariableName( iter );
  return false;
 }


 iter++;
 iter.SkipWhiteSpaceAndComments();
 if ( iter.IsAtEnd() )
 {
  Error::Error_1012_UnexpectedEndOfFile( iter );
  return false;
 }

 AStackString< 64 > varName( varNameStart.GetCurrent(), varNameEnd.GetCurrent() );

 char openToken = *iter;
 char closeToken = 0;
 bool ok = false;
 if ( ( openToken == '"' ) || ( openToken == '\'' ) )
 {
  closeToken = openToken;
  ok = true;
 }
 else if ( openToken == BFF_SCOPE_OPEN )
 {
  closeToken = BFF_SCOPE_CLOSE;
  ok = true;
 }
 else if ( openToken == BFF_STRUCT_OPEN )
 {
  closeToken = BFF_STRUCT_CLOSE;
  ok = true;
 }
 else if ( ( openToken >= '0' ) && ( openToken <= '9' ) )
 {
  if ( concatenation )
  {
   Error::Error_1027_CannotConcatenate( operatorIter, varName, BFFVariable::VAR_ANY, BFFVariable::VAR_INT );
   return false;
  }


  BFFIterator startIntValue( iter );
  while ( iter.IsAtEnd() == false )
  {
   iter++;
   if ( ( *iter < '0' ) || ( *iter > '9' ) )
   {
    break;
   }
  }
  if ( startIntValue.GetDistTo( iter ) > 10 )
  {
   Error::Error_1018_IntegerValueCouldNotBeParsed( startIntValue );
   return false;
  }
  AStackString<> intAsString( startIntValue.GetCurrent(), iter.GetCurrent() );
  int i = 0;
  if ( sscanf( intAsString.Get(), "%i", &i ) != 1 )
  {
   Error::Error_1018_IntegerValueCouldNotBeParsed( startIntValue );
   return false;
  }
  return StoreVariableInt( varNameStart.GetCurrent(), varNameEnd.GetCurrent(), i );
 }
 else if ( ( *iter == 't' ) || ( *iter == 'f' ) )
 {

  BFFIterator startBoolValue( iter );
  if ( iter.ParseToNext( 'e' ) == true )
  {
   iter++;
   if ( ( startBoolValue.GetDistTo( iter ) <= 5 ) )
   {
    AStackString<8> value( startBoolValue.GetCurrent(), iter.GetCurrent() );
    if ( value == "true" )
    {
     if ( concatenation )
     {
      Error::Error_1027_CannotConcatenate( operatorIter, varName, BFFVariable::VAR_ANY, BFFVariable::VAR_BOOL );
      return false;
     }
     return StoreVariableBool( varNameStart.GetCurrent(), varNameEnd.GetCurrent(), true );
    }
    else if ( value == "false" )
    {
     if ( concatenation )
     {
      Error::Error_1027_CannotConcatenate( operatorIter, varName, BFFVariable::VAR_ANY, BFFVariable::VAR_BOOL );
      return false;
     }
     return StoreVariableBool( m_LastVarNameStart.GetCurrent(), m_LastVarNameEnd.GetCurrent(), false );
    }
   }
  }


 }
 else if ( *iter == '.' )
 {

  BFFIterator varNameStartSrc( iter );
  iter++;
  if ( iter.IsAtValidVariableNameCharacter() == false )
  {
   Error::Error_1013_UnexpectedCharInVariableName( iter, (0) );
   return false;
  }
  iter.SkipVariableName();
  return StoreVariableToVariable( varNameStart.GetCurrent(), varNameEnd.GetCurrent(),
          varNameStartSrc, iter, operatorIter );
 }

 if ( !ok )
 {
  Error::Error_1017_UnexepectedCharInVariableValue( iter );
  return false;
 }

 bool result = false;


 BFFIterator openTokenPos( iter );
 BFFIterator openTokenForError( iter );
 openTokenPos++;
 if ( openToken == BFF_SCOPE_OPEN )
 {
  if ( iter.ParseToMatchingBrace( openToken, closeToken ) )
  {
   result = StoreVariableArray( varNameStart.GetCurrent(), varNameEnd.GetCurrent(),
           openTokenPos, iter, operatorIter );
  }
  else
  {
   Error::Error_1002_MatchingClosingTokenNotFound( openTokenForError, (0), closeToken );
  }
 }
 else if ( openToken == BFF_STRUCT_OPEN )
 {
  if ( iter.ParseToMatchingBrace( openToken, closeToken ) )
  {
   result = StoreVariableStruct( varNameStart.GetCurrent(), varNameEnd.GetCurrent(),
            openTokenPos, iter, operatorIter );
  }
  else
  {
   Error::Error_1002_MatchingClosingTokenNotFound( openTokenForError, (0), closeToken );
  }
 }
 else
 {
  do { if ( !( ( openToken == '\'' ) || ( openToken == '"' ) ) ) { if ( AssertHandler::Failure( "( openToken == '\\'' ) || ( openToken == '\"' )", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/BFF/BFFParser.cpp", 399 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;
  iter.SkipString( closeToken );
  if ( *iter == closeToken )
  {
   result = StoreVariableString( varNameStart.GetCurrent(), varNameEnd.GetCurrent(),
            openTokenPos, iter, operatorIter );
  }
  else
  {
   Error::Error_1002_MatchingClosingTokenNotFound( openTokenForError, (0), closeToken );
  }
 }

 if ( result )
 {
  iter++;
 }


 return result;
}



bool BFFParser::ParseFunction( BFFIterator & iter )
{
 do { if ( !( iter.IsAtValidFunctionNameCharacter() ) ) { if ( AssertHandler::Failure( "iter.IsAtValidFunctionNameCharacter()", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/BFF/BFFParser.cpp", 425 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;


 BFFStackFrame stackFrame;

 BFFIterator functionNameStart( iter );
 iter.SkipFunctionName();
 if ( iter.IsAtEnd() )
 {
  Error::Error_1012_UnexpectedEndOfFile( iter );
  return false;
 }


 if ( functionNameStart.GetDistTo( iter ) > MAX_FUNCTION_NAME_LENGTH )
 {

  Error::Error_1015_UnknownFunction( functionNameStart );
  return false;
 }


 AStackString<MAX_FUNCTION_NAME_LENGTH> functionName( functionNameStart.GetCurrent(), iter.GetCurrent() );
 const Function * func = Function::Find( functionName );
 if ( func == (0) )
 {
  Error::Error_1015_UnknownFunction( functionNameStart );
  return false;
 }
 iter.SkipWhiteSpace();

 if ( func->IsUnique() && func->GetSeen() )
 {
  Error::Error_1020_FunctionCanOnlyBeInvokedOnce( functionNameStart, func );
  return false;
 }
 func->SetSeen();

 do { if ( FLog::ShowInfo() ) { FLog::Info( "Function call '%s'", functionName.Get() ); } } while ( false ); ;


 bool hasHeader = false;
 BFFIterator functionArgsStartToken( iter );
 BFFIterator functionArgsStopToken( iter );
 if ( *iter == BFF_FUNCTION_ARGS_OPEN )
 {

  if ( func->AcceptsHeader() == false )
  {
   Error::Error_1021_UnexpectedHeaderForFunction( iter, func );
   return false;
  }


  if ( iter.ParseToMatchingBrace( BFF_FUNCTION_ARGS_OPEN, BFF_FUNCTION_ARGS_CLOSE ) == false )
  {
   Error::Error_1022_MissingFunctionHeaderCloseToken( functionArgsStartToken, func );
   return false;
  }
  functionArgsStopToken = iter;
  hasHeader = true;
  iter++;
  iter.SkipWhiteSpaceAndComments();
 }

 if ( func->NeedsHeader() && ( hasHeader == false ) )
 {
  Error::Error_1023_FunctionRequiresAHeader( iter, func );
  return false;
 }


 bool hasBody = false;

 BFFIterator functionBodyStartToken( iter );
 BFFIterator functionBodyStopToken( iter );
 if ( func->NeedsBody() )
 {

  if ( *iter != BFF_SCOPE_OPEN )
  {
   Error::Error_1024_FunctionRequiresABody( functionNameStart, func );
   return false;
  }

  if ( iter.ParseToMatchingBrace( BFF_SCOPE_OPEN, BFF_SCOPE_CLOSE ) == false )
  {
   Error::Error_1025_MissingScopeCloseToken( functionBodyStartToken, func );
   return false;
  }

  functionBodyStopToken = iter;
  iter++;
  hasBody = true;
 }

 return func->ParseFunction( functionNameStart,
        hasBody ? &functionBodyStartToken : (0),
        hasBody ? &functionBodyStopToken : (0),
        hasHeader ? &functionArgsStartToken : (0),
        hasHeader ? &functionArgsStopToken : (0) );}



bool BFFParser::ParseUnnamedScope( BFFIterator & iter )
{

 BFFIterator scopeStart( iter );
 if ( iter.ParseToMatchingBrace( BFF_SCOPE_OPEN, BFF_SCOPE_CLOSE ) == false )
 {
  Error::Error_1025_MissingScopeCloseToken( scopeStart, (0) );
  return false;
 }


 BFFStackFrame stackFrame;


 BFFParser subParser;
 BFFIterator subIter( scopeStart );
 subIter++;
 subIter.SetMax( iter.GetCurrent() );
 if ( subParser.Parse( subIter ) == false )
 {
  return false;
 }

 iter++;

 return true;
}



bool BFFParser::ParsePreprocessorDirective( BFFIterator & iter )
{
 const BFFIterator directiveStart( iter );


 do { if ( !( *iter == BFF_PREPROCESSOR_START ) ) { if ( AssertHandler::Failure( "*iter == BFF_PREPROCESSOR_START", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/BFF/BFFParser.cpp", 564 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;
 iter++;


 iter.SkipWhiteSpace();


 BFFIterator directiveStartIter( iter );


 while ( iter.IsAtValidDirectiveNameCharacter() )
 {
  iter++;
 }
 BFFIterator directiveEndIter( iter );

 iter.SkipWhiteSpace();


 AStackString< MAX_DIRECTIVE_NAME_LENGTH > directive( directiveStartIter.GetCurrent(), directiveEndIter.GetCurrent() );
 if ( directive == "include" )
 {
  return ParseIncludeDirective( iter );
 }
 else if ( directive == "once" )
 {
  FBuild::Get().GetDependencyGraph().SetCurrentFileAsOneUse();
  return true;
 }
 else if ( directive == "if" )
 {
  return ParseIfDirective( directiveStart, iter );
 }
 else if ( directive == "endif" )
 {
  return ParseEndIfDirective( directiveStartIter );
 }


 Error::Error_1030_UnknownDirective( directiveStartIter, directive );
 return false;
}



bool BFFParser::ParseIncludeDirective( BFFIterator & iter )
{

 if ( s_Depth >= 128 )
 {
  Error::Error_1035_ExcessiveDepthComplexity( iter );
  return false;
 }


 if ( *iter != '"' )
 {
  Error::Error_1031_UnexpectedCharFollowingDirectiveName( iter, AStackString<>( "include" ), '"' );
  return false;
 }

 BFFIterator stringStart( iter );
 stringStart++;


 if ( iter.ParseToNext( '"' ) == false )
 {
  Error::Error_1012_UnexpectedEndOfFile( iter );
  return false;
 }

 AStackString<> include( stringStart.GetCurrent(), iter.GetCurrent() );
 iter++;

 do { if ( FLog::ShowInfo() ) { FLog::Info( "Including: %s\n", include.Get() ); } } while ( false ); ;




 const char * lastSlash = iter.GetFileName().FindLast( ( '/' ) );
 lastSlash = lastSlash ? lastSlash : iter.GetFileName().FindLast( ( '\\' ) );
 lastSlash = lastSlash ? ( lastSlash + 1 ): iter.GetFileName().Get();
 AStackString<> includeToUse( iter.GetFileName().Get(), lastSlash );
 includeToUse += include;
 AStackString<> includeToUseClean;
 NodeGraph::CleanPath( includeToUse, includeToUseClean );
 FileStream f;
 if ( f.Open( includeToUseClean.Get(), FileStream::READ_ONLY ) == false )
 {
  Error::Error_1032_UnableToOpenInclude( stringStart, includeToUseClean );
  return false;
 }


 if ( FBuild::Get().GetDependencyGraph().IsOneUseFile( includeToUseClean ) )
 {

  return true;
 }

 uint64_t includeTimeStamp = FileIO::GetFileLastWriteTime( includeToUseClean );


 const uint32_t fileSize = (uint32_t)f.GetFileSize();
 AutoPtr< char > mem( (char *)::AllocFileLine( fileSize + 1, "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/BFF/BFFParser.cpp", 668 ) );
 if ( f.Read( mem.Get(), fileSize ) != fileSize )
 {
  Error::Error_1033_ErrorReadingInclude( stringStart, include, Env::GetLastErr() );
  return false;
 }
 mem.Get()[ fileSize ] = '\000';
 BFFParser parser;
 const bool pushStackFrame = false;
 return parser.Parse( mem.Get(), fileSize, includeToUseClean.Get(), includeTimeStamp, pushStackFrame );
}



bool BFFParser::ParseIfDirective( const BFFIterator & directiveStart, BFFIterator & iter )
{

 const BFFIterator conditionStart( iter );
 while ( ( iter.IsAtEnd() == false ) &&
   ( *iter != '\r' ) &&
   ( *iter != '\n' ) )
 {
  iter++;
 }
 const BFFIterator conditionEnd( iter );


 bool result;
 if ( CheckIfCondition( conditionStart, conditionEnd, result ) == false )
 {
  return false;
 }

 if ( result )
 {
  ++s_IfDepth;
  return true;
 }


 size_t depth = 1;
 while ( depth > 0 )
 {

  if ( iter.IsAtEnd() )
  {
   (void)directiveStart;
   Error::Error_1012_UnexpectedEndOfFile( iter );
   return false;
  }


  iter.SkipWhiteSpace();
  if ( *iter == BFF_PREPROCESSOR_START )
  {
   iter++;
   iter.SkipWhiteSpace();
   const BFFIterator directiveNameStart( iter );
   while ( iter.IsAtValidDirectiveNameCharacter() )
   {
    iter++;
   }
   const BFFIterator directiveNameEnd( iter );
   AStackString<> directiveName( directiveNameStart.GetCurrent(), directiveNameEnd.GetCurrent() );
   if ( directiveName == "endif" )
   {
    --depth;
   }
   else if ( directiveName == "if" )
   {
    ++depth;
   }


  }


  while ( ( iter.IsAtEnd() == false ) &&
    ( *iter != '\r' ) &&
    ( *iter != '\n' ) )
  {
   iter++;
  }
 }

 return true;
}



bool BFFParser::ParseEndIfDirective( const BFFIterator & directiveStart )
{
 if ( s_IfDepth == 0 )
 {

  Error::Error_1037_EndIfWithoutIf( directiveStart );
  return false;
 }

 s_IfDepth--;
 return true;
}



bool BFFParser::CheckIfCondition( const BFFIterator & conditionStart, const BFFIterator & conditionEnd, bool & result )
{

 AStackString<> condition( conditionStart.GetCurrent(), conditionEnd.GetCurrent() );
 condition.Replace( '\t', ' ' );
 condition.Replace( " ", "" );

 result = false;


 if ( condition == "__WINDOWS__" )
 {



  return true;
 }
 if ( condition == "__LINUX__" )
 {

   result = true;

  return true;
 }
 if ( condition == "__OSX__" )
 {



  return true;
 }


 Error::Error_1036_UnknownTokenInIfDirective( conditionStart );
 return false;
}



bool BFFParser::StoreVariableString( const char * varNameStart, const char * varNameEnd,
          const BFFIterator & valueStart, const BFFIterator & valueEnd,
          const BFFIterator & operatorIter )
{

 AStackString< 2048 > value;
 if ( PerformVariableSubstitutions( valueStart, valueEnd, value ) == false )
 {
  return false;
 }

 do { if ( !( varNameStart ) ) { if ( AssertHandler::Failure( "varNameStart", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/BFF/BFFParser.cpp", 823 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;
 do { if ( !( varNameEnd ) ) { if ( AssertHandler::Failure( "varNameEnd", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/BFF/BFFParser.cpp", 824 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;
 AStackString< MAX_VARIABLE_NAME_LENGTH > name( varNameStart, varNameEnd );


 const BFFVariable * varToConcat = (0);
 if ( *operatorIter == BFF_VARIABLE_CONCATENATION )
 {

  varToConcat = BFFStackFrame::GetVar( name );
  if ( varToConcat == (0) )
  {
   Error::Error_1026_VariableNotFoundForConcatenation( operatorIter, name );
   return false;
  }


  if ( varToConcat->IsString() )
  {

   AStackString< 1024 > finalValue( varToConcat->GetString() );
   finalValue += value;

   BFFStackFrame::SetVarString( name, finalValue );
   do { if ( FLog::ShowInfo() ) { FLog::Info( "Appended '%s' to <String> variable '%s' with result '%s'", value.Get(), name.Get(), finalValue.Get() ); } } while ( false ); ;
   return true;
  }
  else if ( varToConcat->IsArrayOfStrings() )
  {

   Array< AString > finalValues( varToConcat->GetArrayOfStrings().GetSize() + 1, false );
   finalValues = varToConcat->GetArrayOfStrings();
   finalValues.Append( value );

   BFFStackFrame::SetVarArrayOfStrings( name, finalValues );
   do { if ( FLog::ShowInfo() ) { FLog::Info( "Appended '%s' to <ArrayOfStrings> variable '%s' with result of %i items", value.Get(), name.Get(), finalValues.GetSize() ); } } while ( false ); ;
   return true;
  }
  else
  {
   Error::Error_1027_CannotConcatenate( operatorIter, name, varToConcat->GetType(), BFFVariable::VAR_STRING );
   return false;
  }
 }


 BFFStackFrame::SetVarString( name, value );
 do { if ( FLog::ShowInfo() ) { FLog::Info( "Registered <string> variable '%s' with value '%s'", name.Get(), value.Get() ); } } while ( false ); ;
 return true;
}



bool BFFParser::StoreVariableArray( const char * varNameStart, const char * varNameEnd,
         const BFFIterator & valueStart, const BFFIterator & valueEnd,
         const BFFIterator & operatorIter )
{
 do { if ( !( varNameStart ) ) { if ( AssertHandler::Failure( "varNameStart", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/BFF/BFFParser.cpp", 880 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;
 do { if ( !( varNameEnd ) ) { if ( AssertHandler::Failure( "varNameEnd", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/BFF/BFFParser.cpp", 881 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;
 AStackString< MAX_VARIABLE_NAME_LENGTH > name( varNameStart, varNameEnd );

 Array< AString > values( 32, true );
 Array< const BFFVariable * > structValues( 32, true );


 if ( *operatorIter == BFF_VARIABLE_CONCATENATION )
 {

  const BFFVariable * var = BFFStackFrame::GetVar( name );
  if ( var == (0) )
  {
   Error::Error_1026_VariableNotFoundForConcatenation( operatorIter, name );
   return false;
  }


  if ( var->IsArrayOfStrings() )
  {

   values = var->GetArrayOfStrings();
  }
  else if ( var->IsArrayOfStructs() )
  {

   structValues = var->GetArrayOfStructs();
  }
  else
  {

   Error::Error_1027_CannotConcatenate( operatorIter, name, var->GetType(), BFFVariable::VAR_ARRAY_OF_STRINGS );
   return false;
  }
 }


 BFFIterator iter( valueStart );
 for (;;)
 {
  iter.SkipWhiteSpaceAndComments();


  if ( iter.GetCurrent() == valueEnd.GetCurrent() )
  {
   break;
  }

  const char c = *iter;
  if ( ( c == '"' ) || ( c == '\'' ) )
  {



   if ( structValues.IsEmpty() == false )
   {

    Error::Error_1034_OperationNotSupported( iter,
               BFFVariable::VAR_ARRAY_OF_STRUCTS,
               BFFVariable::VAR_STRING,
               operatorIter );
    return false;
   }


   BFFIterator elementValueStart( iter );
   iter.SkipString( c );
   do { if ( !( iter.GetCurrent() <= valueEnd.GetCurrent() ) ) { if ( AssertHandler::Failure( "iter.GetCurrent() <= valueEnd.GetCurrent()", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/BFF/BFFParser.cpp", 948 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;
   elementValueStart++;
   AStackString< 2048 > elementValue;


   if ( PerformVariableSubstitutions( elementValueStart, iter, elementValue ) == false )
   {
    return false;
   }

   values.Append( elementValue );

   iter++;
  }
  else if ( c == '.' )
  {

   BFFIterator elementStartValue( iter );
   iter++;
   iter.SkipVariableName();


   AStackString<> varName( elementStartValue.GetCurrent(), iter.GetCurrent() );
   const BFFVariable * var = BFFStackFrame::GetVar( varName );
   if ( var == (0) )
   {
    Error::Error_1026_VariableNotFoundForConcatenation( operatorIter, varName );
    return false;
   }

   if ( var->IsString() || var->IsArrayOfStrings() )
   {

    if ( structValues.IsEmpty() == false )
    {

     Error::Error_1034_OperationNotSupported( elementStartValue,
                BFFVariable::VAR_ARRAY_OF_STRUCTS,
                var->GetType(),
                operatorIter );
     return false;
    }

    if ( var->IsString() )
    {
     values.Append( var->GetString() );
    }
    else
    {
     values.Append( var->GetArrayOfStrings() );
    }
   }
   else if ( var->IsStruct() || var->IsArrayOfStructs() )
   {

    if ( values.IsEmpty() == false )
    {

     Error::Error_1034_OperationNotSupported( elementStartValue,
                BFFVariable::VAR_ARRAY_OF_STRINGS,
                var->GetType(),
                operatorIter );
     return false;
    }

    if ( var->IsStruct() )
    {
     structValues.Append( var );
    }
    else
    {
     structValues.Append( var->GetArrayOfStructs() );
    }
   }
   else
   {
    Error::Error_1050_PropertyMustBeOfType( iter, (0), name.Get(),
              var->GetType(),
              BFFVariable::VAR_STRING,
              BFFVariable::VAR_STRUCT );
    return false;
   }
  }
  else
  {
   Error::Error_1001_MissingStringStartToken( iter, (0) );
   return false;
  }

  iter.SkipWhiteSpaceAndComments();
  if ( *iter == ',' )
  {
   iter++;
  }


 }


 do { if ( !( values.IsEmpty() || structValues.IsEmpty() ) ) { if ( AssertHandler::Failure( "values.IsEmpty() || structValues.IsEmpty()", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/BFF/BFFParser.cpp", 1047 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;


 if ( structValues.IsEmpty() == false )
 {

  BFFStackFrame::SetVarArrayOfStructs( name, structValues );
  do { if ( FLog::ShowInfo() ) { FLog::Info( "Registered <ArrayOfStructs> variable '%s' with %u elements", name.Get(), structValues.GetSize() ); } } while ( false ); ;
 }
 else
 {

  BFFStackFrame::SetVarArrayOfStrings( name, values );
  do { if ( FLog::ShowInfo() ) { FLog::Info( "Registered <ArrayOfStrings> variable '%s' with %u elements", name.Get(), values.GetSize() ); } } while ( false ); ;
 }

 return true;
}



bool BFFParser::StoreVariableStruct( const char * varNameStart, const char * varNameEnd,
          const BFFIterator & valueStart, const BFFIterator & valueEnd,
          const BFFIterator & operatorIter )
{
 do { if ( !( varNameStart ) ) { if ( AssertHandler::Failure( "varNameStart", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/BFF/BFFParser.cpp", 1072 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;
 do { if ( !( varNameEnd ) ) { if ( AssertHandler::Failure( "varNameEnd", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/BFF/BFFParser.cpp", 1073 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;
 AStackString< MAX_VARIABLE_NAME_LENGTH > name( varNameStart, varNameEnd );


 if ( *operatorIter == BFF_VARIABLE_CONCATENATION )
 {

  Error::Error_1027_CannotConcatenate( operatorIter, name, BFFVariable::VAR_STRUCT, BFFVariable::VAR_ANY );
  return false;
 }


 BFFStackFrame stackFrame;


 BFFParser subParser;
 BFFIterator subIter( valueStart );
 subIter.SetMax( valueEnd.GetCurrent() );
 if ( subParser.Parse( subIter ) == false )
 {
  return false;
 }


 const Array< const BFFVariable * > & structMembers = stackFrame.GetLocalVariables();


 BFFStackFrame::SetVarStruct( name, structMembers, stackFrame.GetParent() );
 do { if ( FLog::ShowInfo() ) { FLog::Info( "Registered <struct> variable '%s' with %u members", name.Get(), structMembers.GetSize() ); } } while ( false ); ;

 return true;
}




bool BFFParser::StoreVariableBool( const char * varNameStart, const char * varNameEnd, bool value )
{

 AStackString< MAX_VARIABLE_NAME_LENGTH > name( varNameStart, varNameEnd );
 BFFStackFrame::SetVarBool( name, value );

 do { if ( FLog::ShowInfo() ) { FLog::Info( "Registered <bool> variable '%s' with value '%s'", name.Get(), value ? "true" : "false" ); } } while ( false ); ;

 return true;
}



bool BFFParser::StoreVariableInt( const char * varNameStart, const char * varNameEnd, int value )
{
 AStackString< MAX_VARIABLE_NAME_LENGTH > name( varNameStart, varNameEnd );
 BFFStackFrame::SetVarInt( name, value );

 do { if ( FLog::ShowInfo() ) { FLog::Info( "Registered <int> variable '%s' with value '%i'", name.Get(), value ); } } while ( false ); ;

 return true;
}



bool BFFParser::StoreVariableToVariable( const char * varNameDstStart, const char * varNameDstEnd,
             const BFFIterator & varNameSrcStart, const BFFIterator & varNameSrcEnd,
           const BFFIterator & operatorIter )
{

 AStackString<> dstName( varNameDstStart, varNameDstEnd );
 AStackString<> srcName( varNameSrcStart.GetCurrent(), varNameSrcEnd.GetCurrent() );
 const BFFVariable * varDst = BFFStackFrame::GetVar( dstName );
 const BFFVariable * varSrc = BFFStackFrame::GetVar( srcName );


 if ( varSrc == (0) )
 {
  Error::Error_1009_UnknownVariable( varNameSrcStart, (0) );
  return false;
 }

 const bool concat = ( *operatorIter == BFF_VARIABLE_CONCATENATION );


 if ( concat )
 {

  if ( varDst == (0) )
  {
   Error::Error_1026_VariableNotFoundForConcatenation( operatorIter, dstName );
   return false;
  }
 }


 BFFVariable::VarType srcType = varSrc->GetType();
 BFFVariable::VarType dstType = BFFVariable::VAR_ANY;
 if ( varDst )
 {
  dstType = varDst->GetType();
 }
 else
 {
  do { if ( !( concat == false ) ) { if ( AssertHandler::Failure( "concat == false", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/BFF/BFFParser.cpp", 1173 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;
  dstType = srcType;
 }



 if ( srcType != dstType )
 {



  if ( ( dstType == BFFVariable::VAR_ARRAY_OF_STRINGS ) &&
    ( srcType == BFFVariable::VAR_STRING ) )
  {
   uint32_t num = (uint32_t)( 1 + ( concat ? varDst->GetArrayOfStrings().GetSize() : 0 ) );
   Array< AString > values( num, false );
   if ( concat )
   {
    values.Append( varDst->GetArrayOfStrings() );
   }
   values.Append( varSrc->GetString() );

   BFFStackFrame::SetVarArrayOfStrings( dstName, values );
   do { if ( FLog::ShowInfo() ) { FLog::Info( "Registered <ArrayOfStrings> variable '%s' with %u elements", dstName.Get(), num ); } } while ( false ); ;
   return true;
  }


  if ( ( dstType == BFFVariable::VAR_ARRAY_OF_STRUCTS ) &&
    ( srcType == BFFVariable::VAR_STRUCT ) )
  {
   uint32_t num = (uint32_t)( 1 + ( concat ? varDst->GetArrayOfStructs().GetSize() : 0 ) );
   Array< const BFFVariable * > values( num, false );
   if ( concat )
   {
    values.Append( varDst->GetArrayOfStructs() );
   }
   values.Append( varSrc );

   BFFStackFrame::SetVarArrayOfStructs( dstName, values );
   do { if ( FLog::ShowInfo() ) { FLog::Info( "Registered <ArrayOfStructs> variable '%s' with %u elements", dstName.Get(), num ); } } while ( false ); ;
   return true;
  }

 }
 else
 {


  if ( srcType == BFFVariable::VAR_STRING )
  {
   AStackString< 2048 > finalValue;
   if ( concat )
   {
    finalValue = varDst->GetString();
   }
   finalValue += varSrc->GetString();

   BFFStackFrame::SetVarString( dstName, finalValue );
   do { if ( FLog::ShowInfo() ) { FLog::Info( "Registered <string> variable '%s' with value '%s'", dstName.Get(), finalValue.Get() ); } } while ( false ); ;
   return true;
  }

  if ( srcType == BFFVariable::VAR_ARRAY_OF_STRINGS )
  {
   if ( concat )
   {
    const unsigned int num = (unsigned int)( varSrc->GetArrayOfStrings().GetSize() + varDst->GetArrayOfStrings().GetSize() );
    Array< AString > values( num, false );
    values.Append( varDst->GetArrayOfStrings() );
    values.Append( varSrc->GetArrayOfStrings() );
    BFFStackFrame::SetVarArrayOfStrings( dstName, values );
    do { if ( FLog::ShowInfo() ) { FLog::Info( "Registered <ArrayOfStrings> variable '%s' with %u elements", dstName.Get(), num ); } } while ( false ); ;
   }
   else
   {
    BFFStackFrame::SetVarArrayOfStrings( dstName, varSrc->GetArrayOfStrings() );
    do { if ( FLog::ShowInfo() ) { FLog::Info( "Registered <ArrayOfStrings> variable '%s' with %u elements", dstName.Get(), (unsigned int)varSrc->GetArrayOfStrings().GetSize() ); } } while ( false ); ;
   }
   return true;
  }

  if ( srcType == BFFVariable::VAR_ARRAY_OF_STRUCTS )
  {
   if ( concat )
   {
    const unsigned int num = (unsigned int)( varSrc->GetArrayOfStructs().GetSize() + varDst->GetArrayOfStructs().GetSize() );
    Array< const BFFVariable * > values( num, false );
    values.Append( varDst->GetArrayOfStructs() );
    values.Append( varSrc->GetArrayOfStructs() );
    BFFStackFrame::SetVarArrayOfStructs( dstName, values );
    do { if ( FLog::ShowInfo() ) { FLog::Info( "Registered <ArrayOfStructs> variable '%s' with %u elements", dstName.Get(), num ); } } while ( false ); ;
   }
   else
   {
    BFFStackFrame::SetVarArrayOfStructs( dstName, varSrc->GetArrayOfStructs() );
    do { if ( FLog::ShowInfo() ) { FLog::Info( "Registered <ArrayOfStructs> variable '%s' with %u elements", dstName.Get(), (unsigned int)varSrc->GetArrayOfStructs().GetSize() ); } } while ( false ); ;
   }
   return true;
  }

  if ( srcType == BFFVariable::VAR_INT )
  {
   int newVal( varSrc->GetInt() );
   if ( concat )
   {
    newVal += varDst->GetInt();
   }
   return StoreVariableInt( varNameDstStart, varNameDstEnd, newVal );
  }

  if ( srcType == BFFVariable::VAR_BOOL )
  {

   if ( concat == false )
   {
    return StoreVariableBool( varNameDstStart, varNameDstEnd, varSrc->GetBool() );
   }
  }

  if ( srcType == BFFVariable::VAR_STRUCT )
  {
   const Array< const BFFVariable * > & srcMembers = varSrc->GetStructMembers();
   if ( concat )
   {

    do { if ( !( varDst ) ) { if ( AssertHandler::Failure( "varDst", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/BFF/BFFParser.cpp", 1299 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;
    const Array< const BFFVariable * > & dstMembers = varDst->GetStructMembers();


    Array< const BFFVariable * > allMembers( srcMembers.GetSize() + dstMembers.GetSize(), false );
    allMembers = srcMembers;


    for ( const BFFVariable ** it = dstMembers.Begin(); it != dstMembers.End(); ++it )
    {

     bool exists = false;
     for ( const BFFVariable ** it2 = srcMembers.Begin(); it2 != srcMembers.End(); ++it2 )
     {
      if ( ( *it2 )->GetName() == ( *it )->GetName() )
      {

       exists = true;
       break;
      }
     }
     if ( exists == false )
     {

      allMembers.Append( *it );
     }
    }

    BFFStackFrame::SetVarStruct( dstName, allMembers );
    do { if ( FLog::ShowInfo() ) { FLog::Info( "Registered <struct> variable '%s' with %u members", dstName.Get(), allMembers.GetSize() ); } } while ( false ); ;
   }
   else
   {

    BFFStackFrame::SetVarStruct( dstName, srcMembers );
    do { if ( FLog::ShowInfo() ) { FLog::Info( "Registered <struct> variable '%s' with %u members", dstName.Get(), srcMembers.GetSize() ); } } while ( false ); ;
   }
   return true;
  }
 }

 Error::Error_1034_OperationNotSupported( varNameSrcStart,
            varDst ? varDst->GetType() : varSrc->GetType(),
            varSrc->GetType(),
            operatorIter );
 return false;
}



           bool BFFParser::PerformVariableSubstitutions( const BFFIterator & startIter,
             const BFFIterator & endIter,
             AString & value )
{
 AStackString< 4096 > output;

 BFFIterator src( startIter );
 BFFIterator end( endIter );

 while ( src < end )
 {
  switch ( *src )
  {
   case '^':
   {
    src++;
    if ( src < end )
    {
     output += *src;
    }
    break;
   }
   case '$':
   {
    BFFIterator firstToken( src );
    src++;


    BFFIterator startName( src );
    const char * endName = (0);
    while ( src < end )
    {
     if ( *src == '$' )
     {
      endName = src.GetCurrent();
      break;
     }
     src++;
    }
    if ( ( endName == (0) ) ||
      ( ( endName - startName.GetCurrent() ) < 1 ) )
    {
     Error::Error_1028_MissingVariableSubstitutionEnd( firstToken );
     return false;
    }
    AStackString< MAX_VARIABLE_NAME_LENGTH > varName( startName.GetCurrent(), endName );
    const BFFVariable * var = BFFStackFrame::GetVarAny( varName );
    if ( var == (0) )
    {
     Error::Error_1009_UnknownVariable( startName, (0) );
     return false;
    }
    if ( var->IsString() == false )
    {
     Error::Error_1029_VariableForSubstitutionIsNotAString( startName, varName, var->GetType() );
     return false;
    }
    output += var->GetString();
    break;
   }
   default:
   {
    output += *src;
    break;
   }
  }
  src++;
 }

 value = output;
 return true;
}
# 65 "/home/ffulin/p4/tmp/Unity/Tools/FBuild/FBuildCore/Unity1.cpp" 2


# 1 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/BFF/BFFIterator.cpp" 1





# 1 "./Tools/FBuild/FBuildCore/PrecompiledHeader.h" 1
# 7 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/BFF/BFFIterator.cpp" 2






void BFFIterator::operator = ( const BFFIterator & iter )
{
 m_Pos = iter.m_Pos;
 m_MinPos = iter.m_MinPos;
 m_MaxPos = iter.m_MaxPos;
 m_FileName = iter.m_FileName;
 m_FileTimeStamp = iter.m_FileTimeStamp;
}



void BFFIterator::SkipWhiteSpace()
{
 while ( !IsAtEnd() )
 {
  if ( IsAtWhitespace() )
  {
   (*this)++;
  }
  else
  {
   break;
  }
 }
}



void BFFIterator::SkipComment()
{

 while ( !IsAtEnd() )
 {
  bool atLineEnd = (*m_Pos == '\n' );
  (*this)++;
  if ( atLineEnd )
  {
   break;
  }
 }
}



void BFFIterator::SkipString( char quote )
{

 do { if ( !( *m_Pos == quote ) ) { if ( AssertHandler::Failure( "*m_Pos == quote", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/BFF/BFFIterator.cpp", 60 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;

 while ( !IsAtEnd() )
 {
  m_Pos++;

  const char c = *m_Pos;


  if ( c == '^' )
  {
   m_Pos++;
   continue;
  }


  if ( *m_Pos == quote )
  {
   return;
  }
 }
}



void BFFIterator::SkipWhiteSpaceAndComments()
{
 SkipWhiteSpace();
 while ( IsAtComment() )
 {
  SkipComment();
  SkipWhiteSpace();
 }
}



void BFFIterator::SkipVariableName()
{
 while ( !IsAtEnd() )
 {
  if ( !IsAtValidVariableNameCharacter() )
  {
   return;
  }


  (*this)++;
 }
}



void BFFIterator::SkipFunctionName()
{
 while ( !IsAtEnd() )
 {
  if ( IsAtValidFunctionNameCharacter() )
  {

   (*this)++;
   continue;
  }

  break;
 }
}




void BFFIterator::SkipDirectiveName()
{
 while ( !IsAtEnd() )
 {
  if ( IsAtValidDirectiveNameCharacter() )
  {

   (*this)++;
   continue;
  }

  break;
 }
}



bool BFFIterator::ParseToNext( char c )
{
 if ( IsAtEnd() )
 {
  return false;
 }

 char prev = '\000';
 do
 {
  (*this)++;
  if ( *m_Pos == c )
  {
   if ( prev != '^' )
   {
    return true;
   }
  }
  prev = *m_Pos;
 } while ( !IsAtEnd() );

 return false;
}



bool BFFIterator::ParseToMatchingBrace( char openBrace, char closeBrace )
{
 do { if ( !( *m_Pos == openBrace ) ) { if ( AssertHandler::Failure( "*m_Pos == openBrace", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/BFF/BFFIterator.cpp", 176 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;

 do
 {
  m_Pos++;
  SkipWhiteSpaceAndComments();


  if ( *m_Pos == openBrace )
  {
   if ( ParseToMatchingBrace( openBrace, closeBrace ) == false )
   {
    return false;
   }
   continue;
  }


  if ( ( *m_Pos == '\'' ) || ( *m_Pos == '"' ) )
  {
   SkipString( *m_Pos );
  }


  if ( *m_Pos == closeBrace )
  {
   return true;
  }



 } while ( !IsAtEnd() );

 return false;
}



bool BFFIterator::IsAtValidVariableNameCharacter() const
{
 const char c = *m_Pos;
 return ( ( ( c >= 'a' ) && ( c <= 'z' ) ) ||
    ( ( c >= 'A' ) && ( c <= 'Z' ) ) ||
    ( ( c >= '0' ) && ( c <= '9' ) ) ||
    ( c == '_' ) );
}



bool BFFIterator::IsAtValidFunctionNameCharacter() const
{
 const char c = *m_Pos;
 return ( ( ( c >= 'a' ) && ( c <= 'z' ) ) ||
    ( ( c >= 'A' ) && ( c <= 'Z' ) ) ||
    ( ( c >= '0' ) && ( c <= '9' ) ) ||
    ( c == '_' ) );
}



bool BFFIterator::IsAtValidDirectiveNameCharacter() const
{
 const char c = *m_Pos;
 return ( ( c >= 'a' ) && ( c <= 'z' ) );
}



bool BFFIterator::IsAtWhitespace() const
{
 char c = *m_Pos;
 return ( ( c == '\n' ) ||
    ( c == '\r' ) ||
    ( c == '\t' ) ||
    ( c == ' ' ) );
}



bool BFFIterator::IsAtComment() const
{
 const char c = *m_Pos;
 if ( c == BFFParser::BFF_COMMENT_SEMICOLON )
 {
  return true;
 }
 if ( ( c == BFFParser::BFF_COMMENT_SLASH ) && ( *( m_Pos + 1 ) == BFFParser::BFF_COMMENT_SLASH ) )
 {
  return true;
 }
 return false;
}



void BFFIterator::GetPosInfo( uint32_t & line,
         uint32_t & column,
         const char * & lineStart ) const
{


 const char * p = m_MinPos;
 lineStart = m_MinPos;
 line = 1;
 while ( p < m_Pos )
 {
  bool atLineEnd = ( *p == '\n' );
  p++;
  if ( atLineEnd )
  {
   lineStart = p;
   line++;
  }
 }
 column = (uint32_t)( ( p - lineStart ) + 1 );
}
# 68 "/home/ffulin/p4/tmp/Unity/Tools/FBuild/FBuildCore/Unity1.cpp" 2


# 1 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/BFF/BFFStackFrame.cpp" 1





# 1 "./Tools/FBuild/FBuildCore/PrecompiledHeader.h" 1
# 7 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/BFF/BFFStackFrame.cpp" 2







           BFFStackFrame * BFFStackFrame::s_StackHead = (0);



BFFStackFrame::BFFStackFrame()
: m_Variables( 32, true )
{

 m_Next = s_StackHead;
 s_StackHead = this;
}



BFFStackFrame::~BFFStackFrame()
{

 do { if ( !( s_StackHead == this ) ) { if ( AssertHandler::Failure( "s_StackHead == this", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/BFF/BFFStackFrame.cpp", 31 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;
 s_StackHead = m_Next;


 Array< BFFVariable * >::Iter i = m_Variables.Begin();
 Array< BFFVariable * >::Iter end = m_Variables.End();
 for( ; i < end ; ++i )
 {
  delete *i;
 }
}



           void BFFStackFrame::SetVarString( const AString & name,
               const AString & value,
               BFFStackFrame * frame )
{
 frame = frame ? frame : s_StackHead;

 BFFVariable * var = frame->GetVarMutableNoRecurse( name );
 if ( var )
 {
  var->SetValueString( value );
  return;
 }


 BFFVariable * v = new ( "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/BFF/BFFStackFrame.cpp", 59 ) BFFVariable( name, value );
 frame->m_Variables.Append( v );
}



           void BFFStackFrame::SetVarArrayOfStrings( const AString & name,
              const Array< AString > & values,
              BFFStackFrame * frame )
{
 frame = frame ? frame : s_StackHead;

 BFFVariable * var = frame->GetVarMutableNoRecurse( name );
 if ( var )
 {
  var->SetValueArrayOfStrings( values );
  return;
 }


 BFFVariable * v = new ( "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/BFF/BFFStackFrame.cpp", 79 ) BFFVariable( name, values );
 frame->m_Variables.Append( v );
}



           void BFFStackFrame::SetVarBool( const AString & name, bool value, BFFStackFrame * frame )
{
 frame = frame ? frame : s_StackHead;

 BFFVariable * var = frame->GetVarMutableNoRecurse( name );
 if ( var )
 {
  var->SetValueBool( value );
  return;
 }


 BFFVariable * v = new ( "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/BFF/BFFStackFrame.cpp", 97 ) BFFVariable( name, value );
 frame->m_Variables.Append( v );
}



           void BFFStackFrame::SetVarInt( const AString & name, int value, BFFStackFrame * frame )
{
 frame = frame ? frame : s_StackHead;

 BFFVariable * var = frame->GetVarMutableNoRecurse( name );
 if ( var )
 {
  var->SetValueInt( value );
  return;
 }


 BFFVariable * v = new ( "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/BFF/BFFStackFrame.cpp", 115 ) BFFVariable( name, value );
 frame->m_Variables.Append( v );
}



           void BFFStackFrame::SetVarStruct( const AString & name,
            const Array< const BFFVariable * > & members,
            BFFStackFrame * frame )
{
 frame = frame ? frame : s_StackHead;

 BFFVariable * var = frame->GetVarMutableNoRecurse( name );
 if ( var )
 {
  var->SetValueStruct( members );
  return;
 }


 BFFVariable * v = new ( "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/BFF/BFFStackFrame.cpp", 135 ) BFFVariable( name, members );
 frame->m_Variables.Append( v );
}



           void BFFStackFrame::SetVarArrayOfStructs( const AString & name,
              const Array< const BFFVariable * > & structs,
              BFFStackFrame * frame )
{
 frame = frame ? frame : s_StackHead;

 BFFVariable * var = frame->GetVarMutableNoRecurse( name );
 if ( var )
 {
  var->SetValueArrayOfStructs( structs );
  return;
 }


 BFFVariable * v = new ( "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/BFF/BFFStackFrame.cpp", 155 ) BFFVariable( name, structs, BFFVariable::VAR_ARRAY_OF_STRUCTS );
 frame->m_Variables.Append( v );
}




           void BFFStackFrame::SetVar( const BFFVariable * var, BFFStackFrame * frame )
{
 frame = frame ? frame : s_StackHead;

 do { if ( !( var ) ) { if ( AssertHandler::Failure( "var", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/BFF/BFFStackFrame.cpp", 166 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;

 switch ( var->GetType() )
 {
  case BFFVariable::VAR_ANY: do { if ( !( false ) ) { if ( AssertHandler::Failure( "false", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/BFF/BFFStackFrame.cpp", 170 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ; break;
  case BFFVariable::VAR_STRING: SetVarString( var->GetName(), var->GetString(), frame ); break;
  case BFFVariable::VAR_BOOL: SetVarBool( var->GetName(), var->GetBool(), frame ); break;
  case BFFVariable::VAR_ARRAY_OF_STRINGS: SetVarArrayOfStrings( var->GetName(), var->GetArrayOfStrings(), frame ); break;
  case BFFVariable::VAR_INT: SetVarInt( var->GetName(), var->GetInt(), frame ); break;
  case BFFVariable::VAR_STRUCT: SetVarStruct( var->GetName(), var->GetStructMembers(), frame ); break;
  case BFFVariable::VAR_ARRAY_OF_STRUCTS: SetVarArrayOfStructs( var->GetName(), var->GetArrayOfStructs(), frame ); break;
  case BFFVariable::MAX_VAR_TYPES: do { if ( !( false ) ) { if ( AssertHandler::Failure( "false", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/BFF/BFFStackFrame.cpp", 177 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ; break;
 }
}



           const BFFVariable * BFFStackFrame::GetVar( const char * name )
{
 AStackString<> strName( name );
 return GetVar( strName );
}



           const BFFVariable * BFFStackFrame::GetVar( const AString & name )
{

 do { if ( !( s_StackHead ) ) { if ( AssertHandler::Failure( "s_StackHead", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/BFF/BFFStackFrame.cpp", 194 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;


 return s_StackHead->GetVariableRecurse( name );
}



const BFFVariable * BFFStackFrame::GetVariableRecurse( const AString & name ) const
{

 Array< BFFVariable * >::Iter i = m_Variables.Begin();
 Array< BFFVariable * >::Iter end = m_Variables.End();
 for( ; i < end ; ++i )
 {
  if ( ( *i )->GetName() == name )
  {
   return *i;
  }
 }


 if ( m_Next )
 {
  return m_Next->GetVariableRecurse( name );
 }


 return (0);
}



           const BFFVariable * BFFStackFrame::GetVarAny( const AString & name )
{

 do { if ( !( s_StackHead ) ) { if ( AssertHandler::Failure( "s_StackHead", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/BFF/BFFStackFrame.cpp", 230 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;


 return s_StackHead->GetVariableRecurse( name, BFFVariable::VAR_ANY );
}



const BFFVariable * BFFStackFrame::GetVariableRecurse( const AString & nameOnly,
             BFFVariable::VarType type ) const
{

 Array< BFFVariable * >::Iter i = m_Variables.Begin();
 Array< BFFVariable * >::Iter end = m_Variables.End();
 for( ; i < end ; ++i )
 {

  if ( ( *i )->GetName().GetLength() == ( nameOnly.GetLength() + 1 ) )
  {

   if ( ( type == BFFVariable::VAR_ANY ) ||
     ( type == ( *i )->GetType() ) )
   {

    if ( nameOnly == ( ( *i )->GetName().Get() + 1 ) )
    {
     return *i;
    }
   }
  }
 }


 if ( m_Next )
 {
  return m_Next->GetVariableRecurse( nameOnly, type );
 }


 return (0);
}



BFFVariable * BFFStackFrame::GetVarMutableNoRecurse( const AString & name )
{
 do { if ( !( s_StackHead ) ) { if ( AssertHandler::Failure( "s_StackHead", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/BFF/BFFStackFrame.cpp", 276 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;


 Array< BFFVariable * >::Iter i = m_Variables.Begin();
 Array< BFFVariable * >::Iter end = m_Variables.End();
 for( ; i < end ; ++i )
 {
  if ( ( *i )->GetName() == name )
  {
   return *i;
  }
 }

 return (0);
}
# 71 "/home/ffulin/p4/tmp/Unity/Tools/FBuild/FBuildCore/Unity1.cpp" 2


# 1 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/BFF/BFFVariable.cpp" 1





# 1 "./Tools/FBuild/FBuildCore/PrecompiledHeader.h" 1
# 7 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/BFF/BFFVariable.cpp" 2







           const char * BFFVariable::s_TypeNames[] =
{
 "Any",
 "String",
 "Bool",
 "ArrayOfStrings",
 "Int",
 "Struct",
 "ArrayOfStructs"
};



BFFVariable::BFFVariable( const BFFVariable & other )
: m_Name( other.m_Name )
, m_Type( other.m_Type )

, m_BoolValue( false )
, m_ArrayValues( 0, true )
, m_IntValue( 0 )
, m_StructMembers( 0, true )
, m_ArrayOfStructs( 0, true )
{
 switch( m_Type )
 {
  case VAR_ANY: do { if ( !( false ) ) { if ( AssertHandler::Failure( "false", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/BFF/BFFVariable.cpp", 39 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ; break;
  case VAR_STRING: SetValueString( other.GetString() ); break;
  case VAR_BOOL: SetValueBool( other.GetBool() ); break;
  case VAR_ARRAY_OF_STRINGS: SetValueArrayOfStrings( other.GetArrayOfStrings() ); break;
  case VAR_INT: SetValueInt( other.GetInt() ); break;
  case VAR_STRUCT: SetValueStruct( other.GetStructMembers() ); break;
  case VAR_ARRAY_OF_STRUCTS: SetValueArrayOfStructs( other.GetArrayOfStructs() ); break;
  case MAX_VAR_TYPES: do { if ( !( false ) ) { if ( AssertHandler::Failure( "false", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/BFF/BFFVariable.cpp", 46 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ; break;
 }
}



BFFVariable::BFFVariable( const AString & name, const AString & value )
: m_Name( name )
, m_Type( VAR_STRING )
, m_StringValue( value )
, m_BoolValue( false )
, m_ArrayValues( 0, false )
, m_IntValue( 0 )
, m_StructMembers( 0, true )
, m_ArrayOfStructs( 0, false )
{
}



BFFVariable::BFFVariable( const AString & name, bool value )
: m_Name( name )
, m_Type( VAR_BOOL )

, m_BoolValue( value )
, m_ArrayValues( 0, false )
, m_IntValue( 0 )
, m_StructMembers( 0, false )
, m_ArrayOfStructs( 0, false )
{
}



BFFVariable::BFFVariable( const AString & name, const Array< AString > & values )
: m_Name( name )
, m_Type( VAR_ARRAY_OF_STRINGS )

, m_BoolValue( false )
, m_ArrayValues( 0, true )
, m_IntValue( 0 )
, m_StructMembers( 0, false )
, m_ArrayOfStructs( 0, false )
{
 m_ArrayValues = values;
}



BFFVariable::BFFVariable( const AString & name, int i )
: m_Name( name )
, m_Type( VAR_INT )

, m_BoolValue( false )
, m_ArrayValues( 0, true )
, m_IntValue( i )
, m_StructMembers( 0, true )
, m_ArrayOfStructs( 0, false )
{
}



BFFVariable::BFFVariable( const AString & name, const Array< const BFFVariable * > & values )
: m_Name( name )
, m_Type( VAR_STRUCT )

, m_BoolValue( false )
, m_ArrayValues( 0, false )
, m_IntValue( 0 )
, m_StructMembers( values.GetSize(), true )
, m_ArrayOfStructs( 0, false )
{
 SetValueStruct( values );
}



BFFVariable::BFFVariable( const AString & name,
        const Array< const BFFVariable * > & structs,
        VarType type )
: m_Name( name )
, m_Type( VAR_ARRAY_OF_STRUCTS )

, m_BoolValue( false )
, m_ArrayValues( 0, false )
, m_IntValue( 0 )
, m_StructMembers( 0, false )
, m_ArrayOfStructs( structs.GetSize(), true )
{

 do { if ( !( type == VAR_ARRAY_OF_STRUCTS ) ) { if ( AssertHandler::Failure( "type == VAR_ARRAY_OF_STRUCTS", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/BFF/BFFVariable.cpp", 137 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ; (void)type;

 SetValueArrayOfStructs( structs );
}



BFFVariable::~BFFVariable()
{

 for ( BFFVariable ** it = m_StructMembers.Begin();
    it != m_StructMembers.End();
    ++it )
 {
  delete *it;
 }


 for ( BFFVariable ** it = m_ArrayOfStructs.Begin();
    it != m_ArrayOfStructs.End();
    ++it )
 {
  delete *it;
 }
}



void BFFVariable::SetValueString( const AString & value )
{
 m_Type = VAR_STRING;
 m_StringValue = value;
}



void BFFVariable::SetValueBool( bool value )
{
 m_Type = VAR_BOOL;
 m_BoolValue = value;
}



void BFFVariable::SetValueArrayOfStrings( const Array< AString > & values )
{
 m_Type = VAR_ARRAY_OF_STRINGS;
 m_ArrayValues = values;
}



void BFFVariable::SetValueInt( int i )
{
 m_Type = VAR_INT;
 m_IntValue = i;
}



void BFFVariable::SetValueStruct( const Array< const BFFVariable * > & values )
{


 Array< BFFVariable * > newVars( values.GetSize(), false );

 m_Type = VAR_STRUCT;
 for ( const BFFVariable ** it = values.Begin();
    it != values.End();
    ++it )
 {
  const BFFVariable * var = *it;
  BFFVariable * newV = new ( "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/BFF/BFFVariable.cpp", 209 ) BFFVariable( *var );
  newVars.Append( newV );
 }


 for ( BFFVariable ** it = m_StructMembers.Begin();
    it != m_StructMembers.End();
    ++it )
 {
  delete *it;
 }


 m_StructMembers.Swap( newVars );
}



void BFFVariable::SetValueArrayOfStructs( const Array< const BFFVariable * > & values )
{


 Array< BFFVariable * > newVars( values.GetSize(), false );

 m_Type = VAR_ARRAY_OF_STRUCTS;
 for ( const BFFVariable ** it = values.Begin();
    it != values.End();
    ++it )
 {
  const BFFVariable * var = *it;
  BFFVariable * newV = new ( "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/BFF/BFFVariable.cpp", 239 ) BFFVariable( *var );
  newVars.Append( newV );
 }


 for ( BFFVariable ** it = m_ArrayOfStructs.Begin();
    it != m_ArrayOfStructs.End();
    ++it )
 {
  delete *it;
 }

 m_ArrayOfStructs.Swap( newVars );
}
# 74 "/home/ffulin/p4/tmp/Unity/Tools/FBuild/FBuildCore/Unity1.cpp" 2


# 1 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/BFF/Functions/FunctionCompiler.cpp" 1





# 1 "./Tools/FBuild/FBuildCore/PrecompiledHeader.h" 1
# 7 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/BFF/Functions/FunctionCompiler.cpp" 2

# 1 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/BFF/Functions/FunctionCompiler.h" 1


       
# 13 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/BFF/Functions/FunctionCompiler.h"
class FunctionCompiler : public Function
{
public:
 explicit FunctionCompiler();
 inline virtual ~FunctionCompiler() {}

protected:
 virtual bool AcceptsHeader() const;
 virtual bool NeedsHeader() const;
 virtual bool Commit( const BFFIterator & funcStartIter ) const;
};
# 9 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/BFF/Functions/FunctionCompiler.cpp" 2
# 21 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/BFF/Functions/FunctionCompiler.cpp"
FunctionCompiler::FunctionCompiler()
: Function( "Compiler" )
{
}



            bool FunctionCompiler::AcceptsHeader() const
{
 return true;
}



            bool FunctionCompiler::NeedsHeader() const
{
 return true;
}



            bool FunctionCompiler::Commit( const BFFIterator & funcStartIter ) const
{
 const BFFVariable * executableV;
 if ( !GetString( funcStartIter, executableV, ".Executable", true ) )
 {
  return false;
 }


 AStackString<> exe;
 NodeGraph::CleanPath( executableV->GetString(), exe );


 if ( PathUtils::IsFolderPath( exe ) )
 {
  Error::Error_1105_PathNotAllowed( funcStartIter, this, ".Executable", exe );
  return false;
 }


 Dependencies extraFiles( 32, true );
 if ( !GetNodeList( funcStartIter, ".ExtraFiles", extraFiles, false ) )
 {
  return false;
 }


 NodeGraph & ng = FBuild::Get().GetDependencyGraph();
 if ( ng.FindNode( exe ) )
 {
  Error::Error_1100_AlreadyDefined( funcStartIter, this, exe );
  return false;
 }


 const bool allowDistribution = true;
 Node * compilerNode = ng.CreateCompilerNode( exe, extraFiles, allowDistribution );


 return ProcessAlias( funcStartIter, compilerNode );
}
# 77 "/home/ffulin/p4/tmp/Unity/Tools/FBuild/FBuildCore/Unity1.cpp" 2


# 1 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/BFF/Functions/FunctionTest.cpp" 1





# 1 "./Tools/FBuild/FBuildCore/PrecompiledHeader.h" 1
# 7 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/BFF/Functions/FunctionTest.cpp" 2

# 1 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/BFF/Functions/FunctionTest.h" 1


       
# 13 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/BFF/Functions/FunctionTest.h"
class FunctionTest : public Function
{
public:
 explicit FunctionTest();
 inline virtual ~FunctionTest() {}

protected:
 virtual bool AcceptsHeader() const;
 virtual bool Commit( const BFFIterator & funcStartIter ) const;
};
# 9 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/BFF/Functions/FunctionTest.cpp" 2


# 1 "./Tools/FBuild/FBuildCore/Graph/AliasNode.h" 1


       
# 17 "./Tools/FBuild/FBuildCore/Graph/AliasNode.h"
class AliasNode : public Node
{
public:
 explicit AliasNode( const AString & groupName,
      const Dependencies & targets );
 virtual ~AliasNode();

 static inline Node::Type GetType() { return Node::ALIAS_NODE; }

 virtual bool IsAFile() const { return false; }

 inline const Dependencies & GetAliasedNodes() const { return m_StaticDependencies; }

 static Node * Load( IOStream & stream );
 virtual void Save( IOStream & stream ) const;
private:
 virtual bool DetermineNeedToBuild( bool forceClean ) const;
 virtual BuildResult DoBuild( Job * job );
};
# 12 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/BFF/Functions/FunctionTest.cpp" 2

# 1 "./Tools/FBuild/FBuildCore/Graph/TestNode.h" 1


       





# 1 "./Tools/FBuild/FBuildCore/Graph/ExecNode.h" 1


       
# 17 "./Tools/FBuild/FBuildCore/Graph/ExecNode.h"
class ExecNode : public FileNode
{
public:
 explicit ExecNode( const AString & dstFileName,
         FileNode * sourceFile,
      FileNode * executable,
      const AString & arguments,
      const AString & workingDir,
      int32_t expectedReturnCode,
      const Dependencies & preBuildDependencies );
 virtual ~ExecNode();

 static inline Node::Type GetType() { return Node::EXEC_NODE; }

 static Node * Load( IOStream & stream );
 virtual void Save( IOStream & stream ) const;
private:
 virtual BuildResult DoBuild( Job * job );

 void EmitCompilationMessage( const AString & args ) const;

 FileNode * m_SourceFile;
 FileNode * m_Executable;
 AString m_Arguments;
 AString m_WorkingDir;
 int32_t m_ExpectedReturnCode;
};
# 10 "./Tools/FBuild/FBuildCore/Graph/TestNode.h" 2







class TestNode : public FileNode
{
public:
 explicit TestNode( const AString & testOutput,
        FileNode * testExecutable,
        const AString & m_Arguments,
        const AString & m_WorkingDir );
 virtual ~TestNode();

 static inline Node::Type GetType() { return Node::TEST_NODE; }

 virtual void Save( IOStream & stream ) const;
 static Node * Load( IOStream & stream );
private:
 virtual BuildResult DoBuild( Job * job );

 void EmitCompilationMessage( const char * workingDir ) const;

 FileNode * m_Executable;
 AString m_Arguments;
 AString m_WorkingDir;
};
# 14 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/BFF/Functions/FunctionTest.cpp" 2



FunctionTest::FunctionTest()
: Function( "Test" )
{
}



            bool FunctionTest::AcceptsHeader() const
{
 return true;
}



            bool FunctionTest::Commit( const BFFIterator & funcStartIter ) const
{

 const BFFVariable * outputV;
 const BFFVariable * executableV;
 const BFFVariable * argsV;
 const BFFVariable * workingDirV;
 if ( !GetString( funcStartIter, outputV, ".TestOutput", true ) ||
   !GetString( funcStartIter, executableV, ".TestExecutable", true ) ||
   !GetString( funcStartIter, argsV, ".TestArguments" ) ||
   !GetString( funcStartIter, workingDirV, ".TestWorkingDir" ) )
 {
  return false;
 }


 NodeGraph & ng = FBuild::Get().GetDependencyGraph();
 if ( ng.FindNode( outputV->GetString() ) != (0) )
 {
  Error::Error_1100_AlreadyDefined( funcStartIter, this, outputV->GetString() );
  return false;
 }

 Node * testExeNode = ng.FindNode( executableV->GetString() );
 if ( testExeNode == (0) )
 {
  testExeNode = ng.CreateFileNode( executableV->GetString() );
 }
 if ( testExeNode->GetType() == Node::ALIAS_NODE )
 {
  AliasNode * an = testExeNode->CastTo< AliasNode >();
  testExeNode = an->GetAliasedNodes()[ 0 ].GetNode();
 }
 if ( testExeNode->IsAFile() == false )
 {
  Error::Error_1103_NotAFile( funcStartIter, this, "TestExecutable", testExeNode->GetName(), testExeNode->GetType() );
  return false;
 }


 const AString & arguments( argsV ? argsV->GetString() : AString::GetEmpty() );
 const AString & workingDir( workingDirV ? workingDirV->GetString(): AString::GetEmpty() );


 Node * outputNode = ng.CreateTestNode( outputV->GetString(),
             (FileNode *)testExeNode,
             arguments,
             workingDir );

 return ProcessAlias( funcStartIter, outputNode );
}
# 80 "/home/ffulin/p4/tmp/Unity/Tools/FBuild/FBuildCore/Unity1.cpp" 2


# 1 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/BFF/Functions/FunctionAlias.cpp" 1





# 1 "./Tools/FBuild/FBuildCore/PrecompiledHeader.h" 1
# 7 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/BFF/Functions/FunctionAlias.cpp" 2

# 1 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/BFF/Functions/FunctionAlias.h" 1


       
# 13 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/BFF/Functions/FunctionAlias.h"
class FunctionAlias : public Function
{
public:
 explicit FunctionAlias();
 inline virtual ~FunctionAlias() {}

protected:
 virtual bool AcceptsHeader() const;
 virtual bool NeedsHeader() const;
 virtual bool Commit( const BFFIterator & funcStartIter ) const;
};
# 9 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/BFF/Functions/FunctionAlias.cpp" 2





FunctionAlias::FunctionAlias()
: Function( "Alias" )
{
}



            bool FunctionAlias::AcceptsHeader() const
{
 return true;
}



            bool FunctionAlias::NeedsHeader() const
{
 return true;
}



            bool FunctionAlias::Commit( const BFFIterator & funcStartIter ) const
{

 Dependencies targetNodes( 16, true );
 const bool required = true;
 const bool allowCopyDirNodes = true;
 const bool allowUnityNodes = true;
 if ( !GetNodeList( funcStartIter, ".Targets", targetNodes, required, allowCopyDirNodes, allowUnityNodes ) )
 {
  return false;
 }

 if ( targetNodes.IsEmpty() )
 {
  Error::Error_1006_NothingToBuild( funcStartIter, this );
  return false;
 }

 NodeGraph & ng = FBuild::Get().GetDependencyGraph();
 if ( ng.FindNode( m_AliasForFunction ) != (0) )
 {
  Error::Error_1100_AlreadyDefined( funcStartIter, this, m_AliasForFunction );
  return false;
 }

 ng.CreateAliasNode( m_AliasForFunction, targetNodes );

 return true;
}
# 83 "/home/ffulin/p4/tmp/Unity/Tools/FBuild/FBuildCore/Unity1.cpp" 2


# 1 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/BFF/Functions/FunctionCSAssembly.cpp" 1





# 1 "./Tools/FBuild/FBuildCore/PrecompiledHeader.h" 1
# 7 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/BFF/Functions/FunctionCSAssembly.cpp" 2

# 1 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/BFF/Functions/FunctionCSAssembly.h" 1


       
# 13 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/BFF/Functions/FunctionCSAssembly.h"
class FunctionCSAssembly : public Function
{
public:
 explicit FunctionCSAssembly();
 inline virtual ~FunctionCSAssembly() {}

protected:
 virtual bool AcceptsHeader() const;

 virtual bool Commit( const BFFIterator & funcStartIter ) const;
};
# 9 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/BFF/Functions/FunctionCSAssembly.cpp" 2







# 1 "./Tools/FBuild/FBuildCore/Graph/DirectoryListNode.h" 1


       
# 16 "./Tools/FBuild/FBuildCore/Graph/DirectoryListNode.h"
class DirectoryListNode : public Node
{
public:
 explicit DirectoryListNode( const AString & name,
        const AString & path,
        const AString & wildcard,
        bool recursive,
        const Array< AString > & excludePaths );
 virtual ~DirectoryListNode();

 const AString & GetPath() const { return m_Path; }
 const Array< FileIO::FileInfo > & GetFiles() const { return m_Files; }

 static inline Node::Type GetType() { return Node::DIRECTORY_LIST_NODE; }

 virtual bool IsAFile() const { return false; }

 static void FormatName( const AString & path,
       const AString & pattern,
       bool recursive,
       const Array< AString > & excludePaths,
       AString & result );

 static Node * Load( IOStream & stream );
 virtual void Save( IOStream & stream ) const;

private:
 virtual BuildResult DoBuild( Job * job );

 AString m_Path;
 AString m_WildCard;
 Array< AString > m_ExcludePaths;
 bool m_Recursive;

 Array< FileIO::FileInfo > m_Files;
};
# 17 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/BFF/Functions/FunctionCSAssembly.cpp" 2
# 1 "./Tools/FBuild/FBuildCore/Graph/CSNode.h" 1


       
# 17 "./Tools/FBuild/FBuildCore/Graph/CSNode.h"
class CSNode : public FileNode
{
public:
 explicit CSNode( const AString & compilerOutput,
      const Dependencies & inputNodes,
      const AString & compiler,
      const AString & compilerArgs,
      const Dependencies & extraRefs );
 virtual ~CSNode();

 static inline Node::Type GetType() { return Node::CS_NODE; }

 virtual void Save( IOStream & stream ) const;
 static Node * Load( IOStream & stream );
private:
 virtual bool DoDynamicDependencies( bool forceClean );
 virtual BuildResult DoBuild( Job * job );

 void EmitCompilationMessage( const AString & fullArgs ) const;

 void GetFullArgs( AString & fullArgs ) const;
 void GetInputFiles( AString & fullArgs, const AString & pre, const AString & post ) const;
 void GetExtraRefs( AString & fullArgs, const AString & pre, const AString & post ) const;

 AString m_CompilerPath;
 AString m_CompilerArgs;

 Dependencies m_ExtraRefs;
};
# 18 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/BFF/Functions/FunctionCSAssembly.cpp" 2



FunctionCSAssembly::FunctionCSAssembly()
: Function( "CSAssembly" )
{
}



            bool FunctionCSAssembly::AcceptsHeader() const
{
 return true;
}



            bool FunctionCSAssembly::Commit( const BFFIterator & funcStartIter ) const
{

 const BFFVariable * compiler;
 const BFFVariable * compilerOptions;
 const BFFVariable * compilerOutput;
 if ( !GetString( funcStartIter, compiler, ".Compiler", true ) ||
   !GetString( funcStartIter, compilerOptions, ".CompilerOptions", true ) ||
   !GetString( funcStartIter, compilerOutput, ".CompilerOutput", true ) )
 {
  return false;
 }

 NodeGraph & ng = FBuild::Get().GetDependencyGraph();

 Dependencies staticDeps( 32, true );


 const BFFVariable * inputPath = BFFStackFrame::GetVar( ".CompilerInputPath" );
 if ( inputPath )
 {

  const BFFVariable * patternVar = (0);
  if ( !GetString( funcStartIter, patternVar, ".CompilerInputPattern", false ) )
  {
   return false;
  }
  AStackString<> defaultWildCard( "*.cs" );
  const AString & pattern = patternVar ? patternVar->GetString() : defaultWildCard;


  bool recurse = true;
  if ( !GetBool( funcStartIter, recurse, ".CompilerInputPathRecurse", true, false ) )
  {
   return false;
  }


  Array< AString > excludePaths;
  if ( !GetFolderPaths( funcStartIter, excludePaths, ".CompilerInputExcludePath", false ) )
  {
   return false;
  }


  Array< AString > inputPaths;
  if ( !GetFolderPaths( funcStartIter, inputPaths, ".CompilerInputPath", false ) )
  {
   return false;
  }

  Dependencies dirNodes( inputPaths.GetSize() );
  if ( !GetDirectoryListNodeList( funcStartIter, inputPaths, excludePaths, recurse, pattern, "CompilerInputPath", dirNodes ) )
  {
   return false;
  }
  staticDeps.Append( dirNodes );
 }


 if ( !GetNodeList( funcStartIter, ".CompilerInputFiles", staticDeps, false ) )
 {

  return false;
 }

 if ( staticDeps.IsEmpty() )
 {
  Error::Error_1006_NothingToBuild( funcStartIter, this );
  return false;
 }


 Dependencies extraRefs( 0, true );
 if ( !GetNodeList( funcStartIter, ".CompilerReferences", extraRefs, false ) )
 {

  return false;
 }


 if ( ng.FindNode( compilerOutput->GetString() ) )
 {
  Error::Error_1100_AlreadyDefined( funcStartIter, this, compilerOutput->GetString() );
  return false;
 }
 Node * csNode = ng.CreateCSNode( compilerOutput->GetString(),
          staticDeps,
          compiler->GetString(),
          compilerOptions->GetString(),
          extraRefs );


 return ProcessAlias( funcStartIter, csNode );
}
# 86 "/home/ffulin/p4/tmp/Unity/Tools/FBuild/FBuildCore/Unity1.cpp" 2


# 1 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/BFF/Functions/FunctionVCXProject.cpp" 1





# 1 "./Tools/FBuild/FBuildCore/PrecompiledHeader.h" 1
# 7 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/BFF/Functions/FunctionVCXProject.cpp" 2


# 1 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/BFF/Functions/FunctionVCXProject.h" 1


       
# 13 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/BFF/Functions/FunctionVCXProject.h"
class BFFIterator;



class FunctionVCXProject : public Function
{
public:
 explicit FunctionVCXProject();
 inline virtual ~FunctionVCXProject() {}

protected:
 virtual bool AcceptsHeader() const;

 virtual bool Commit( const BFFIterator & funcStartIter ) const;

 bool GetStringFromStruct( const BFFVariable * s, const char * name, AString & result ) const;
};
# 10 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/BFF/Functions/FunctionVCXProject.cpp" 2





# 1 "./Tools/FBuild/FBuildCore/Graph/VCXProjectNode.h" 1


       
# 19 "./Tools/FBuild/FBuildCore/Graph/VCXProjectNode.h"
class DirectoryListNode;



class VCXProjectNode : public FileNode
{
public:
 explicit VCXProjectNode( const AString & projectOutput,
        const Array< AString > & projectBasePaths,
        const Dependencies & paths,
        const Array< AString > & pathsToExclude,
        const Array< AString > & allowedFileExtensions,
        const Array< AString > & files,
        const Array< AString > & filesToExclude,
        const AString & rootNamespace,
        const AString & projectGuid,
        const AString & defaultLanguage,
        const AString & applicationEnvironment,
        const Array< VSProjectConfig > & configs,
        const Array< VSProjectFileType > & fileTypes,
        const Array< AString > & references,
        const Array< AString > & projectReferences );
 virtual ~VCXProjectNode();

 static inline Node::Type GetType() { return Node::VCXPROJECT_NODE; }

 static Node * Load( IOStream & stream );
 virtual void Save( IOStream & stream ) const;
private:
 virtual BuildResult DoBuild( Job * job );

 bool Save( const AString & content, const AString & fileName ) const;


 void GetFiles( Array< FileIO::FileInfo * > & files ) const;

 void AddFile( VSProjectGenerator & pg, const AString & fileName ) const;

 Array< AString > m_ProjectBasePaths;
 Array< AString > m_PathsToExclude;
 Array< AString > m_AllowedFileExtensions;
 Array< AString > m_Files;
 Array< AString > m_FilesToExclude;
 AString m_RootNamespace;
 AString m_ProjectGuid;
 AString m_DefaultLanguage;
 AString m_ApplicationEnvironment;
 Array< VSProjectConfig > m_Configs;
 Array< VSProjectFileType > m_FileTypes;
 Array< AString > m_References;
 Array< AString > m_ProjectReferences;
};
# 16 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/BFF/Functions/FunctionVCXProject.cpp" 2






FunctionVCXProject::FunctionVCXProject()
: Function( "VCXProject" )
{
}



            bool FunctionVCXProject::AcceptsHeader() const
{
 return true;
}



            bool FunctionVCXProject::Commit( const BFFIterator & funcStartIter ) const
{

 AStackString<> projectOutput;
 AStackString<> rootNamespace;
 AStackString<> projectGuid;
 AStackString<> defaultLanguage;
 AStackString<> applicationEnvironment;
 if ( !GetString( funcStartIter, projectOutput, ".ProjectOutput", true ) ||
   !GetString( funcStartIter, rootNamespace, ".RootNamespace", false ) ||
   !GetString( funcStartIter, projectGuid, ".ProjectGuid", false ) ||
   !GetString( funcStartIter, defaultLanguage, ".DefaultLanguage", false ) ||
   !GetString( funcStartIter, applicationEnvironment, ".ApplicationEnvironment", false ) )
 {
  return false;
 }


 Array< AString > inputPaths;
 Array< AString > inputPathsExclude;
 if ( !GetStrings( funcStartIter, inputPaths, ".ProjectInputPaths", false ) ||
   !GetStrings( funcStartIter, inputPathsExclude, ".ProjectInputPathsExclude", false ) )
 {
  return false;
 }


 Array< AString > basePaths;
 if ( !GetStrings( funcStartIter, basePaths, ".ProjectBasePath", false ) )
 {
  return false;
 }
 CleanFolderPaths( basePaths );


 Array< AString > references;
 Array< AString > projectReferences;
 if ( !GetStrings( funcStartIter, references, ".ProjectReferences", false ) ||
   !GetStrings( funcStartIter, projectReferences, ".ProjectProjectReferences", false ) )
 {
  return false;
 }


 Array< AString > allowedFileExtensions( 8, true );
 if ( !GetStrings( funcStartIter, allowedFileExtensions, ".ProjectAllowedFileExtensions", false ) )
 {
  return true;
 }
 if ( allowedFileExtensions.IsEmpty() )
 {
  const char * extensions[] = { ".cpp", ".hpp", ".cxx",".hxx",".c",".h",".cc",".hh",
           ".cp",".hp",".cs",".inl",".bff",".rc",".resx",".m",".mm",
           ".cu",
           (0) };
  AStackString<> tmp;
  const char ** item = extensions;
  while ( *item )
  {
   tmp.Assign( *item );
   allowedFileExtensions.Append( tmp );
   ++item;
  }
 }


 Array< AString > files( 8, true );
 Array< AString > filesToExclude( 8, true );
 if ( !GetStrings( funcStartIter, files, ".ProjectFiles", false ) ||
    !GetStrings( funcStartIter, filesToExclude, ".ProjectFilesToExclude", false ) )
 {
  return false;
 }


 Array< VSProjectFileType > fileTypes;
 const BFFVariable * projectFileTypes = BFFStackFrame::GetVar( ".ProjectFileTypes" );
 if ( projectFileTypes )
 {
  if ( projectFileTypes->IsArrayOfStructs() == false )
  {
   Error::Error_1050_PropertyMustBeOfType( funcStartIter, this, ".ProjectFileTypes", projectFileTypes->GetType(), BFFVariable::VAR_ARRAY_OF_STRUCTS );
   return false;
  }

  const Array< const BFFVariable * > & structs = projectFileTypes->GetArrayOfStructs();
  const BFFVariable * const * end = structs.End();
  for ( const BFFVariable ** it = structs.Begin(); it != end; ++it )
  {
   const BFFVariable * s = *it;

   VSProjectFileType ft;


   if ( !GetStringFromStruct( s, ".FileType", ft.m_FileType ) )
   {

    Error::Error_1101_MissingProperty( funcStartIter, this, AStackString<>( ".FileType" ) );
    return false;
   }


   if ( !GetStringFromStruct( s, ".Pattern", ft.m_Pattern ) )
   {

    Error::Error_1101_MissingProperty( funcStartIter, this, AStackString<>( ".Pattern" ) );
    return false;
   }

   fileTypes.Append( ft );
  }
 }


 CleanFolderPaths( inputPaths );
 CleanFolderPaths( inputPathsExclude );
 CleanFilePaths( files );


 VSProjectConfig baseConfig;


 if ( !GetString( funcStartIter, baseConfig.m_BuildCommand, ".ProjectBuildCommand", false ) ||
   !GetString( funcStartIter, baseConfig.m_RebuildCommand,".ProjectRebuildCommand", false ) ||
   !GetString( funcStartIter, baseConfig.m_CleanCommand, ".ProjectCleanCommand", false ) ||
   !GetString( funcStartIter, baseConfig.m_Output, ".Output", false ) ||
   !GetString( funcStartIter, baseConfig.m_PreprocessorDefinitions, ".PreprocessorDefinitions", false ) ||
   !GetString( funcStartIter, baseConfig.m_IncludeSearchPath, ".IncludeSearchPath", false ) ||
   !GetString( funcStartIter, baseConfig.m_ForcedIncludes, ".ForcedIncludes", false ) ||
   !GetString( funcStartIter, baseConfig.m_AssemblySearchPath, ".AssemblySearchPath", false ) ||
   !GetString( funcStartIter, baseConfig.m_ForcedUsingAssemblies, ".ForcedUsingAssemblies", false ) ||
   !GetString( funcStartIter, baseConfig.m_AdditionalOptions, ".AdditionalOptions", false ) ||
   !GetString( funcStartIter, baseConfig.m_OutputDirectory, ".OutputDirectory", false ) ||
   !GetString( funcStartIter, baseConfig.m_IntermediateDirectory, ".IntermediateDirectory", false ) ||
   !GetString( funcStartIter, baseConfig.m_Xbox360DebuggerCommand,".Xbox360DebuggerCommand", false ) ||
   !GetString( funcStartIter, baseConfig.m_LayoutDir, ".LayoutDir", false ) ||
   !GetString( funcStartIter, baseConfig.m_LayoutExtensionFilter, ".LayoutExtensionFilter", false ) ||
   !GetString( funcStartIter, baseConfig.m_DebuggerFlavor, ".DebuggerFlavor", false ) ||
   !GetString( funcStartIter, baseConfig.m_AumidOverride, ".AumidOverride", false ) ||
   !GetString( funcStartIter, baseConfig.m_PlatformToolset, ".PlatformToolset", false ) ||
   !GetString( funcStartIter, baseConfig.m_DeploymentType, ".DeploymentType", false ) ||
   !GetString( funcStartIter, baseConfig.m_DeploymentFiles, ".DeploymentFiles", false ) ||
   !GetString( funcStartIter, baseConfig.m_LocalDebuggerCommandArguments, ".LocalDebuggerCommandArguments", false ) ||
   !GetString( funcStartIter, baseConfig.m_LocalDebuggerWorkingDirectory, ".LocalDebuggerWorkingDirectory", false ) ||
   !GetString( funcStartIter, baseConfig.m_LocalDebuggerCommand, ".LocalDebuggerCommand", false ) ||
   !GetString( funcStartIter, baseConfig.m_LocalDebuggerEnvironment, ".LocalDebuggerEnvironment", false ) )
 {
  return false;
 }


 Array< VSProjectConfig > configs( 16, true );

 const BFFVariable * projectConfigs = BFFStackFrame::GetVar( ".ProjectConfigs" );
 if ( projectConfigs )
 {
  if ( projectConfigs->IsArrayOfStructs() == false )
  {
   Error::Error_1050_PropertyMustBeOfType( funcStartIter, this, ".ProjectConfigs", projectConfigs->GetType(), BFFVariable::VAR_ARRAY_OF_STRUCTS );
   return false;
  }

  const Array< const BFFVariable * > & structs = projectConfigs->GetArrayOfStructs();
  const BFFVariable * const * end = structs.End();
  for ( const BFFVariable ** it = structs.Begin(); it != end; ++it )
  {
   const BFFVariable * s = *it;


   VSProjectConfig newConfig( baseConfig );


   if ( !GetStringFromStruct( s, ".Platform", newConfig.m_Platform ) )
   {

    Error::Error_1101_MissingProperty( funcStartIter, this, AStackString<>( ".Platform" ) );
    return false;
   }


   if ( !GetStringFromStruct( s, ".Config", newConfig.m_Config ) )
   {

    Error::Error_1101_MissingProperty( funcStartIter, this, AStackString<>( ".Config" ) );
    return false;
   }

   GetStringFromStruct( s, ".ProjectBuildCommand", newConfig.m_BuildCommand );
   GetStringFromStruct( s, ".ProjectRebuildCommand", newConfig.m_RebuildCommand );
   GetStringFromStruct( s, ".ProjectCleanCommand", newConfig.m_CleanCommand );
   GetStringFromStruct( s, ".Output", newConfig.m_Output );
   GetStringFromStruct( s, ".PreprocessorDefinitions", newConfig.m_PreprocessorDefinitions );
   GetStringFromStruct( s, ".IncludeSearchPath", newConfig.m_IncludeSearchPath );
   GetStringFromStruct( s, ".ForcedIncludes", newConfig.m_ForcedIncludes );
   GetStringFromStruct( s, ".AssemblySearchPath", newConfig.m_AssemblySearchPath );
   GetStringFromStruct( s, ".ForcedUsingAssemblies", newConfig.m_ForcedUsingAssemblies );
   GetStringFromStruct( s, ".AdditionalOptions", newConfig.m_AdditionalOptions );
   GetStringFromStruct( s, ".OutputDirectory", newConfig.m_OutputDirectory );
   GetStringFromStruct( s, ".IntermediateDirectory", newConfig.m_IntermediateDirectory );
    GetStringFromStruct( s, ".LayoutDir", newConfig.m_LayoutDir );
   GetStringFromStruct( s, ".LayoutExtensionFilter", newConfig.m_LayoutExtensionFilter );
   GetStringFromStruct( s, ".Xbox360DebuggerCommand", newConfig.m_Xbox360DebuggerCommand );
   GetStringFromStruct( s, ".DebuggerFlavor", newConfig.m_DebuggerFlavor );
   GetStringFromStruct( s, ".AumidOverride", newConfig.m_AumidOverride );
   GetStringFromStruct( s, ".PlatformToolset", newConfig.m_PlatformToolset );
   GetStringFromStruct( s, ".DeploymentType", newConfig.m_DeploymentType );
   GetStringFromStruct( s, ".DeploymentFiles", newConfig.m_DeploymentFiles );
   GetStringFromStruct( s, ".LocalDebuggerCommandArguments", newConfig.m_LocalDebuggerCommandArguments );
   GetStringFromStruct( s, ".LocalDebuggerWorkingDirectory", newConfig.m_LocalDebuggerWorkingDirectory );
   GetStringFromStruct( s, ".LocalDebuggerCommand", newConfig.m_LocalDebuggerCommand );
   GetStringFromStruct( s, ".LocalDebuggerEnvironment", newConfig.m_LocalDebuggerEnvironment );

   configs.Append( newConfig );
  }
 }
 else
 {



  VSProjectConfig config( baseConfig );


  config.m_Platform = "Win32";
  config.m_Config = "Debug";
  configs.Append( config );
  config.m_Config = "Release";
  configs.Append( config );
  config.m_Platform = "x64";
  configs.Append( config );
  config.m_Config = "Debug";
  configs.Append( config );
 }

 NodeGraph & ng = FBuild::Get().GetDependencyGraph();


 AStackString<> inputPattern( "*" );
 Dependencies dirNodes( inputPaths.GetSize() );
 if ( !GetDirectoryListNodeList( funcStartIter, inputPaths, Array< AString >(), true, inputPattern, "ProjectInputPaths", dirNodes ) )
 {
  return false;
 }


 if ( ng.FindNode( projectOutput ) )
 {
  Error::Error_1100_AlreadyDefined( funcStartIter, this, projectOutput );
  return false;
 }

 VCXProjectNode * pn = ng.CreateVCXProjectNode( projectOutput,
               basePaths,
               dirNodes,
               inputPathsExclude,
               allowedFileExtensions,
               files,
               filesToExclude,
               rootNamespace,
               projectGuid,
               defaultLanguage,
               applicationEnvironment,
               configs,
               fileTypes,
               references,
               projectReferences );

 do { if ( !( pn ) ) { if ( AssertHandler::Failure( "pn", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/BFF/Functions/FunctionVCXProject.cpp", 303 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;

 return ProcessAlias( funcStartIter, pn );
}



bool FunctionVCXProject::GetStringFromStruct( const BFFVariable * s, const char * name, AString & result ) const
{
 const Array< const BFFVariable * > & members = s->GetStructMembers();
 const BFFVariable * const * end = members.End();
 for ( const BFFVariable ** it = members.Begin(); it != end; ++it )
 {
  const BFFVariable * v = *it;
  if ( v->IsString() == false )
  {
   continue;
  }
  if ( v->GetName() == name )
  {
   result = v->GetString();
   return true;
  }
 }
 return false;
}
# 89 "/home/ffulin/p4/tmp/Unity/Tools/FBuild/FBuildCore/Unity1.cpp" 2


# 1 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/BFF/Functions/FunctionCopyDir.cpp" 1





# 1 "./Tools/FBuild/FBuildCore/PrecompiledHeader.h" 1
# 7 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/BFF/Functions/FunctionCopyDir.cpp" 2

# 1 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/BFF/Functions/FunctionCopyDir.h" 1


       
# 16 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/BFF/Functions/FunctionCopyDir.h"
class FunctionCopyDir : public Function
{
public:
 explicit FunctionCopyDir();
 inline virtual ~FunctionCopyDir() {}

protected:
 virtual bool AcceptsHeader() const;
 virtual bool Commit( const BFFIterator & funcStartIter ) const;
};
# 9 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/BFF/Functions/FunctionCopyDir.cpp" 2
# 19 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/BFF/Functions/FunctionCopyDir.cpp"
FunctionCopyDir::FunctionCopyDir()
: Function( "CopyDir" )
{
}



            bool FunctionCopyDir::AcceptsHeader() const
{
 return true;
}



            bool FunctionCopyDir::Commit( const BFFIterator & funcStartIter ) const
{

 Array< AString > inputPaths;
 if ( !GetFolderPaths( funcStartIter, inputPaths, ".SourcePaths", true ) )
 {
  return false;
 }


 AStackString<> pattern;
 bool recurse = true;
 Array< AString > excludePaths;
 if ( !GetString( funcStartIter, pattern, ".SourcePathsPattern" ) ||
   !GetBool( funcStartIter, recurse, ".SourcePathsRecurse", true ) ||
   !GetStrings( funcStartIter, excludePaths, ".SourceExcludePaths" ) )
 {
  return false;
 }
 if ( pattern.IsEmpty() )
 {
  pattern = "*";
 }


 Dependencies staticDeps( inputPaths.GetSize() );
 if ( !GetDirectoryListNodeList( funcStartIter, inputPaths, excludePaths, recurse, pattern, ".SourcePaths", staticDeps ) )
 {
  return false;
 }


 AStackString<> destPath;
 if ( !GetString( funcStartIter, destPath, ".Dest", true ) )
 {
  return false;
 }
 PathUtils::FixupFolderPath( destPath );


 Dependencies preBuildDeps;
 if ( !GetNodeList( funcStartIter, ".PreBuildDependencies", preBuildDeps, false ) )
 {
  return false;
 }


 if ( staticDeps.IsEmpty() )
 {
  Error::Error_1006_NothingToBuild( funcStartIter, this );
  return false;
 }


 NodeGraph & ng = FBuild::Get().GetDependencyGraph();
 if ( ng.FindNode( m_AliasForFunction ) )
 {
  Error::Error_1100_AlreadyDefined( funcStartIter, this, m_AliasForFunction );
  return false;
 }


 ng.CreateCopyDirNode( m_AliasForFunction, staticDeps, destPath, preBuildDeps );
 return true;
}
# 92 "/home/ffulin/p4/tmp/Unity/Tools/FBuild/FBuildCore/Unity1.cpp" 2


# 1 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/BFF/Functions/FunctionCopy.cpp" 1





# 1 "./Tools/FBuild/FBuildCore/PrecompiledHeader.h" 1
# 7 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/BFF/Functions/FunctionCopy.cpp" 2

# 1 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/BFF/Functions/FunctionCopy.h" 1


       
# 16 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/BFF/Functions/FunctionCopy.h"
class FunctionCopy : public Function
{
public:
 explicit FunctionCopy();
 inline virtual ~FunctionCopy() {}

protected:
 virtual bool AcceptsHeader() const;
 virtual bool Commit( const BFFIterator & funcStartIter ) const;

 bool GetSourceNodes( const BFFIterator & iter, Node * node, Array< Node * > & nodes ) const;
};
# 9 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/BFF/Functions/FunctionCopy.cpp" 2





# 1 "./Tools/FBuild/FBuildCore/Graph/CopyNode.h" 1


       
# 16 "./Tools/FBuild/FBuildCore/Graph/CopyNode.h"
class CopyNode : public FileNode
{
public:
 explicit CopyNode( const AString & dstFileName,
         FileNode * sourceFile,
      const Dependencies & preBuildDependencies );
 virtual ~CopyNode();

 static inline Node::Type GetType() { return Node::COPY_NODE; }

 static Node * Load( IOStream & stream );
 virtual void Save( IOStream & stream ) const;

 FileNode * GetSourceNode() const { return m_SourceFile; }

private:
 virtual BuildResult DoBuild( Job * job );

 void EmitCopyMessage() const;

 FileNode * m_SourceFile;
};
# 15 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/BFF/Functions/FunctionCopy.cpp" 2







FunctionCopy::FunctionCopy()
: Function( "Copy" )
{
}



            bool FunctionCopy::AcceptsHeader() const
{
 return true;
}



            bool FunctionCopy::Commit( const BFFIterator & funcStartIter ) const
{

 Array< AString > sources( 16, true );
 const BFFVariable * dstFileV;
 if ( !GetStrings( funcStartIter, sources, ".Source", true ) ||
   !GetString( funcStartIter, dstFileV, ".Dest", true ) )
 {
  return false;
 }


 {
  const AString * const end = sources.End();
  for ( const AString * it = sources.Begin(); it != end; ++it )
  {
   const AString & srcFile( *it );


   if ( PathUtils::IsFolderPath( srcFile ) )
   {
    Error::Error_1105_PathNotAllowed( funcStartIter, this, ".Source", srcFile );
    return false;
   }
  }
 }


 Dependencies preBuildDependencies;
 if ( !GetNodeList( funcStartIter, ".PreBuildDependencies", preBuildDependencies, false ) )
 {
  return false;
 }


 NodeGraph & ng = FBuild::Get().GetDependencyGraph();
 Array< Node * > srcNodes;
 {
  const AString * const end = sources.End();
  for ( const AString * it = sources.Begin(); it != end; ++it )
  {

   Node * srcNode = ng.FindNode( *it );
   if ( srcNode )
   {
    if ( GetSourceNodes( funcStartIter, srcNode, srcNodes ) == false )
    {
     return false;
    }
   }
   else
   {

    srcNodes.Append( ng.CreateFileNode( *it ) );
   }
  }
 }

 if ( srcNodes.IsEmpty() )
 {
  Error::Error_1006_NothingToBuild( funcStartIter, this );
  return false;
 }

 AStackString<> dstFile;
 NodeGraph::CleanPath( dstFileV->GetString(), dstFile );


 Dependencies copyNodes( srcNodes.GetSize(), false );
 Node * const * end = srcNodes.End();
 for ( Node ** it = srcNodes.Begin(); it != end; ++it )
 {
  AStackString<> dst( dstFile );


  if ( PathUtils::IsFolderPath( dstFile ) )
  {

   const AString & srcName = ( *it )->GetName();
   const char * lastSlash = srcName.FindLast( ( '/' ) );
   dst += lastSlash ? ( lastSlash + 1 )
         : srcName.Get();
  }


  if ( ng.FindNode( dst ) )
  {


   Error::Error_1100_AlreadyDefined( funcStartIter, this, dst );
   return false;
  }


  Node * copyNode = ng.CreateCopyNode( dst, *it, preBuildDependencies );
  copyNodes.Append( Dependency( copyNode ) );
 }


 return ProcessAlias( funcStartIter, copyNodes );
}



bool FunctionCopy::GetSourceNodes( const BFFIterator & iter, Node * node, Array< Node * > & nodes ) const
{
 if ( node->GetType() == Node::ALIAS_NODE )
 {

  AliasNode * aliasNode = node->CastTo< AliasNode >();
  const Dependencies & aliasedNodes = aliasNode->GetAliasedNodes();
  const Dependency * const end = aliasedNodes.End();
  for ( const Dependency * it = aliasedNodes.Begin(); it != end; ++it )
  {
   if ( !GetSourceNodes( iter, it->GetNode(), nodes ) )
   {
    return false;
   }
  }
  return true;
 }
 else if ( node->IsAFile() )
 {

  nodes.Append( node );
  return true;
 }


 Error::Error_1005_UnsupportedNodeType( iter, this, ".Source", node->GetName(), node->GetType() );
 return false;
}
# 95 "/home/ffulin/p4/tmp/Unity/Tools/FBuild/FBuildCore/Unity1.cpp" 2


# 1 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/BFF/Functions/FunctionSettings.cpp" 1





# 1 "./Tools/FBuild/FBuildCore/PrecompiledHeader.h" 1
# 7 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/BFF/Functions/FunctionSettings.cpp" 2

# 1 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/BFF/Functions/FunctionSettings.h" 1


       
# 15 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/BFF/Functions/FunctionSettings.h"
class FunctionSettings : public Function
{
public:
 explicit FunctionSettings();
 inline virtual ~FunctionSettings() {}

 static inline void SetCachePath( const AString & cachePath ) { s_CachePath = cachePath; }
 static inline const AString & GetCachePath() { return s_CachePath; }

protected:
 virtual bool IsUnique() const;
 virtual bool Commit( const BFFIterator & funcStartIter ) const;

private:
 void ProcessEnvironment( const Array< AString > & envStrings ) const;

 static AString s_CachePath;
};
# 9 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/BFF/Functions/FunctionSettings.cpp" 2
# 20 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/BFF/Functions/FunctionSettings.cpp"
           AString FunctionSettings::s_CachePath( 64 );



FunctionSettings::FunctionSettings()
: Function( "Settings" )
{
}



            bool FunctionSettings::IsUnique() const
{
 return true;
}



            bool FunctionSettings::Commit( const BFFIterator & funcStartIter ) const
{

 AStackString<> cachePluginDLL;
 if ( !GetString( funcStartIter, cachePluginDLL, ".CachePluginDLL" ) )
 {
  return false;
 }
 FBuild::Get().SetCachePluginDLL( cachePluginDLL );
 if ( !cachePluginDLL.IsEmpty() )
 {
  do { if ( FLog::ShowInfo() ) { FLog::Info( "CachePluginDLL: '%s'", cachePluginDLL.Get() ); } } while ( false ); ;
 }


 const BFFVariable * cachePathVar;
 if ( !GetString( funcStartIter, cachePathVar, ".CachePath" ) )
 {
  return false;
 }
 if ( cachePathVar )
 {
  s_CachePath = cachePathVar->GetString();


  if ( s_CachePath.IsEmpty() == false )
  {
   FBuild::Get().SetCachePath( s_CachePath );
  }
 }


 Array< AString > workerList;
 if ( !GetStrings( funcStartIter, workerList, ".Workers" ) )
 {
  return false;
 }
 if ( !workerList.IsEmpty() )
 {
  FBuild::Get().SetWorkerList( workerList );
 }


 Array< AString > environment;
 if ( !GetStrings( funcStartIter, environment, ".Environment" ) )
 {
  return false;
 }
 if ( !environment.IsEmpty() )
 {
  ProcessEnvironment( environment );
 }

 return true;
}



void FunctionSettings::ProcessEnvironment( const Array< AString > & envStrings ) const
{




 uint32_t size = 0;
 for ( uint32_t i=0; i<envStrings.GetSize(); ++i )
 {
  size += envStrings[ i ].GetLength() + 1;
 }


 AutoPtr< char > envString( (char *)::AllocFileLine( size + 1, "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/BFF/Functions/FunctionSettings.cpp", 109 ) );


 AStackString<> libEnvVar;


 char * dst = envString.Get();
 for ( uint32_t i=0; i<envStrings.GetSize(); ++i )
 {
  if ( envStrings[ i ].BeginsWith( "LIB=" ) )
  {
   libEnvVar.Assign( envStrings[ i ].Get() + 4, envStrings[ i ].GetEnd() );
  }

  const uint32_t thisStringLen = envStrings[ i ].GetLength();
  AString::Copy( envStrings[ i ].Get(), dst, thisStringLen );
  dst += ( thisStringLen + 1 );
 }


 *dst = '\000';

 FBuild::Get().SetEnvironmentString( envString.Get(), size, libEnvVar );
}
# 98 "/home/ffulin/p4/tmp/Unity/Tools/FBuild/FBuildCore/Unity1.cpp" 2


# 1 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/BFF/Functions/FunctionLibrary.cpp" 1





# 1 "./Tools/FBuild/FBuildCore/PrecompiledHeader.h" 1
# 7 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/BFF/Functions/FunctionLibrary.cpp" 2

# 1 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/BFF/Functions/FunctionLibrary.h" 1


       






# 1 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/BFF/Functions/FunctionObjectList.h" 1


       
# 13 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/BFF/Functions/FunctionObjectList.h"
class CompilerNode;
class Dependencies;
class ObjectNode;



class FunctionObjectList : public Function
{
public:
 explicit FunctionObjectList();
 inline virtual ~FunctionObjectList() {}

protected:
 virtual bool AcceptsHeader() const;
 virtual bool NeedsHeader() const;

 virtual bool Commit( const BFFIterator & funcStartIter ) const;


 bool GetCompilerNode( const BFFIterator & iter, const AString & compiler, CompilerNode * & compilerNode ) const;
 bool GetPrecompiledHeaderNode( const BFFIterator & iter,
           CompilerNode * compilerNode,
           uint32_t objFlags,
           const BFFVariable * compilerOptions,
           const Dependencies & compilerForceUsing,
           ObjectNode * & precompiledHeaderNode,
           bool deoptimizeWritableFiles,
           bool deoptimizeWritableFilesWithToken ) const;
 bool GetInputs( const BFFIterator & iter, Dependencies & inputs ) const;
};
# 11 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/BFF/Functions/FunctionLibrary.h" 2



class FunctionLibrary : public FunctionObjectList
{
public:
 explicit FunctionLibrary();
 inline virtual ~FunctionLibrary() {}

protected:
 virtual bool AcceptsHeader() const;
 virtual bool NeedsHeader() const;

 virtual bool Commit( const BFFIterator & funcStartIter ) const;
};
# 9 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/BFF/Functions/FunctionLibrary.cpp" 2
# 20 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/BFF/Functions/FunctionLibrary.cpp"
# 1 "./Tools/FBuild/FBuildCore/Graph/LibraryNode.h" 1


       
# 14 "./Tools/FBuild/FBuildCore/Graph/LibraryNode.h"
class CompilerNode;
class ObjectNode;



class LibraryNode : public FileNode
{
public:
 explicit LibraryNode( const AString & libraryName,
        const Dependencies & inputNodes,
        CompilerNode * compiler,
        const AString & compilerArgs,
        const AString & compilerArgsDeoptimized,
        const AString & compilerOutputPath,
        const AString & librarian,
        const AString & librarianArgs,
        uint32_t flags,
        ObjectNode * precompiledHeader,
        const Dependencies & compilerForceUsing,
        const Dependencies & preBuildDependencies,
        const Dependencies & additionalInputs,
        bool deoptimizeWritableFiles,
        bool deoptimizeWritableFilesWithToken );
 virtual ~LibraryNode();

 static inline Node::Type GetType() { return Node::LIBRARY_NODE; }

 static Node * Load( IOStream & stream );
 virtual void Save( IOStream & stream ) const;

 const char * GetObjExtension() const;

 void GetInputFiles( AString & fullArgs, const AString & pre, const AString & post ) const;

 enum Flag
 {
  LIB_FLAG_LIB = 0x01,
  LIB_FLAG_AR = 0x02,
  LIB_FLAG_ORBIS_AR=0x04,
  LIB_FLAG_GREENHILLS_AX=0x08,
 };
 static uint32_t DetermineFlags( const AString & librarianName );
private:
 friend class FunctionLibrary;

 virtual bool DoDynamicDependencies( bool forceClean );
 virtual BuildResult DoBuild( Job * job );


 void GetFullArgs( AString & fullArgs ) const;
 bool CreateDynamicObjectNode( Node * inputFile, bool isUnityNode = false, bool isIsolatedFromUnityNode = false );
 void EmitCompilationMessage( const AString & fullArgs ) const;

 virtual Priority GetPriority() const { return PRIORITY_HIGH; }

 inline bool GetFlag( Flag flag ) const { return ( ( m_Flags & (uint32_t)flag ) != 0 ); }

 CompilerNode * m_Compiler;
 AString m_CompilerArgs;
 AString m_CompilerArgsDeoptimized;
 AString m_CompilerOutputPath;
 Dependencies m_CompilerForceUsing;
 AString m_LibrarianPath;
 AString m_LibrarianArgs;
 uint32_t m_Flags;
 ObjectNode * m_PrecompiledHeader;
 AString m_ObjExtensionOverride;
 Dependencies m_AdditionalInputs;
 bool m_DeoptimizeWritableFiles;
 bool m_DeoptimizeWritableFilesWithToken;
};
# 21 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/BFF/Functions/FunctionLibrary.cpp" 2




FunctionLibrary::FunctionLibrary()
: FunctionObjectList()
{
 m_Name = "Library";
}



            bool FunctionLibrary::AcceptsHeader() const
{
 return true;
}



            bool FunctionLibrary::NeedsHeader() const
{
 return false;
}



            bool FunctionLibrary::Commit( const BFFIterator & funcStartIter ) const
{

 const BFFVariable * outputLib;
 const BFFVariable * compiler;
 const BFFVariable * compilerOptions;
 AStackString<> compilerOptionsDeoptimized;
 const BFFVariable * compilerOutputPath;
 const BFFVariable * compilerOutputExtension;
 const BFFVariable * librarian;
 const BFFVariable * librarianOptions;
 if ( !GetString( funcStartIter, outputLib, ".LibrarianOutput", true ) ||
   !GetString( funcStartIter, compiler, ".Compiler", true ) ||
   !GetString( funcStartIter, compilerOptions, ".CompilerOptions", true ) ||
   !GetString( funcStartIter, compilerOptionsDeoptimized, ".CompilerOptionsDeoptimized", false ) ||
   !GetString( funcStartIter, compilerOutputPath, ".CompilerOutputPath", true ) ||
   !GetString( funcStartIter, compilerOutputExtension, ".CompilerOutputExtension", false ) ||
   !GetString( funcStartIter, librarian, ".Librarian", true ) ||
   !GetString( funcStartIter, librarianOptions, ".LibrarianOptions", true ) )
 {
  return false;
 }

 NodeGraph & ng = FBuild::Get().GetDependencyGraph();


 CompilerNode * compilerNode = (0);
 if ( !FunctionObjectList::GetCompilerNode( funcStartIter, compiler->GetString(), compilerNode ) )
 {
  return false;
 }


 uint32_t objFlags = ObjectNode::DetermineFlags( compilerNode, compilerOptions->GetString() );
 if ( ( objFlags & ObjectNode::FLAG_MSVC ) && ( objFlags & ObjectNode::FLAG_CREATING_PCH ) )
 {

  Error::Error_1303_PCHCreateOptionOnlyAllowedOnPCH( funcStartIter, this, "/Yc", "CompilerOptions" );
  return false;
 }


 {
  const AString & args = compilerOptions->GetString();
  bool hasInputToken = ( args.Find( "%1" ) || args.Find( "\"%1\"" ) );
  if ( hasInputToken == false )
  {
   Error::Error_1106_MissingRequiredToken( funcStartIter, this, ".CompilerOptions", "%1" );
   return false;
  }
  bool hasOutputToken = ( args.Find( "%2" ) || args.Find( "\"%2\"" ) );
  if ( hasOutputToken == false )
  {
   Error::Error_1106_MissingRequiredToken( funcStartIter, this, ".CompilerOptions", "%2" );
   return false;
  }
 }


 {
  const AString & args = librarianOptions->GetString();
  bool hasInputToken = ( args.Find( "%1" ) || args.Find( "\"%1\"" ) );
  if ( hasInputToken == false )
  {
   Error::Error_1106_MissingRequiredToken( funcStartIter, this, ".LibrarianOptions", "%1" );
   return false;
  }
  bool hasOutputToken = ( args.Find( "%2" ) || args.Find( "\"%2\"" ) );
  if ( hasOutputToken == false )
  {
   Error::Error_1106_MissingRequiredToken( funcStartIter, this, ".LibrarianOptions", "%2" );
   return false;
  }
 }


 Dependencies compilerForceUsing;
 if ( !GetNodeList( funcStartIter, ".CompilerForceUsing", compilerForceUsing, false ) )
 {
  return false;
 }


 Dependencies preBuildDependencies;
 if ( !GetNodeList( funcStartIter, ".PreBuildDependencies", preBuildDependencies, false ) )
 {
  return false;
 }


 bool deoptimizeWritableFiles = false;
 bool deoptimizeWritableFilesWithToken = false;
 if ( !GetBool( funcStartIter, deoptimizeWritableFiles, ".DeoptimizeWritableFiles", false, false ) )
 {
  return false;
 }
 if ( !GetBool( funcStartIter, deoptimizeWritableFilesWithToken, ".DeoptimizeWritableFilesWithToken", false, false ) )
 {
  return false;
 }
 if ( ( deoptimizeWritableFiles || deoptimizeWritableFilesWithToken ) && compilerOptionsDeoptimized.IsEmpty() )
 {
  Error::Error_1101_MissingProperty( funcStartIter, this, AStackString<>( ".CompilerOptionsDeoptimized" ) );
  return false;
 }


 ObjectNode * precompiledHeaderNode = (0);
 if ( !GetPrecompiledHeaderNode( funcStartIter, compilerNode, objFlags, compilerOptions, compilerForceUsing, precompiledHeaderNode, deoptimizeWritableFiles, deoptimizeWritableFilesWithToken ) )
 {
  return false;
 }

 Dependencies staticDeps( 32, true );
 if ( !GetInputs( funcStartIter, staticDeps ) )
 {
  return false;
 }


 Dependencies additionalInputs;
 if ( !GetNodeList( funcStartIter, ".LibrarianAdditionalInputs", additionalInputs, false ) )
 {
  return false;
 }

 if ( staticDeps.IsEmpty() && additionalInputs.IsEmpty() )
 {
  Error::Error_1006_NothingToBuild( funcStartIter, this );
  return false;
 }

 uint32_t flags = LibraryNode::DetermineFlags( librarian->GetString() );


 if ( ng.FindNode( outputLib->GetString() ) )
 {
  Error::Error_1100_AlreadyDefined( funcStartIter, this, outputLib->GetString() );
  return false;
 }
 LibraryNode * libNode = ng.CreateLibraryNode( outputLib->GetString(),
        staticDeps,
        compilerNode,
        compilerOptions->GetString(),
        compilerOptionsDeoptimized,
        compilerOutputPath->GetString(),
        librarian->GetString(),
        librarianOptions->GetString(),
        flags,
        precompiledHeaderNode,
        compilerForceUsing,
        preBuildDependencies,
        additionalInputs,
        deoptimizeWritableFiles,
        deoptimizeWritableFilesWithToken );
 if ( compilerOutputExtension )
 {
  libNode->m_ObjExtensionOverride = compilerOutputExtension->GetString();
 }

 return ProcessAlias( funcStartIter, libNode );
}
# 101 "/home/ffulin/p4/tmp/Unity/Tools/FBuild/FBuildCore/Unity1.cpp" 2


# 1 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/BFF/Functions/FunctionUsing.cpp" 1





# 1 "./Tools/FBuild/FBuildCore/PrecompiledHeader.h" 1
# 7 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/BFF/Functions/FunctionUsing.cpp" 2

# 1 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/BFF/Functions/FunctionUsing.h" 1


       
# 13 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/BFF/Functions/FunctionUsing.h"
class FunctionUsing : public Function
{
public:
 explicit FunctionUsing();
 inline virtual ~FunctionUsing() {}

protected:
 virtual bool AcceptsHeader() const;
 virtual bool NeedsHeader() const;
 virtual bool NeedsBody() const;

 virtual bool ParseFunction( const BFFIterator & functionNameStart,
        const BFFIterator * functionBodyStartToken,
        const BFFIterator * functionBodyStopToken,
        const BFFIterator * functionHeaderStartToken,
        const BFFIterator * functionHeaderStopToken ) const;
};
# 9 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/BFF/Functions/FunctionUsing.cpp" 2







FunctionUsing::FunctionUsing()
: Function( "Using" )
{
}



            bool FunctionUsing::AcceptsHeader() const
{
 return true;
}



            bool FunctionUsing::NeedsHeader() const
{
 return true;
}



            bool FunctionUsing::NeedsBody() const
{
 return false;
}


            bool FunctionUsing::ParseFunction( const BFFIterator & functionNameStart,
              const BFFIterator * functionBodyStartToken,
              const BFFIterator * functionBodyStopToken,
              const BFFIterator * functionHeaderStartToken,
              const BFFIterator * functionHeaderStopToken ) const
{
 (void)functionNameStart;
 (void)functionBodyStartToken;
 (void)functionBodyStopToken;

 if ( functionHeaderStartToken && functionHeaderStopToken &&
   ( functionHeaderStartToken->GetDistTo( *functionHeaderStopToken ) >= 1 ) )
 {
  BFFIterator start( *functionHeaderStartToken );
  do { if ( !( *start == BFFParser::BFF_FUNCTION_ARGS_OPEN ) ) { if ( AssertHandler::Failure( "*start == BFFParser::BFF_FUNCTION_ARGS_OPEN", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/BFF/Functions/FunctionUsing.cpp", 57 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;
  start++;
  start.SkipWhiteSpace();


  const char c = *start;
  if ( c != BFFParser::BFF_DECLARE_VAR_INTERNAL )
  {
   Error::Error_1007_ExpectedVariable( start, this );
   return false;
  }


  BFFIterator stop( start );
  stop++;
  stop.SkipVariableName();
  do { if ( !( stop.GetCurrent() <= functionHeaderStopToken->GetCurrent() ) ) { if ( AssertHandler::Failure( "stop.GetCurrent() <= functionHeaderStopToken->GetCurrent()", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/BFF/Functions/FunctionUsing.cpp", 73 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;
  AStackString<> varName( start.GetCurrent(), stop.GetCurrent() );


  const BFFVariable * v = BFFStackFrame::GetVar( varName );
  if ( v == (0) )
  {
   Error::Error_1009_UnknownVariable( start, this );
   return false;
  }
  if ( v->IsStruct() == false )
  {
   Error::Error_1008_VariableOfWrongType( start, this,
               BFFVariable::VAR_STRUCT,
               v->GetType() );
   return false;
  }


  BFFStackFrame * frame = BFFStackFrame::GetCurrent()->GetParent();
  do { if ( !( frame ) ) { if ( AssertHandler::Failure( "frame", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/BFF/Functions/FunctionUsing.cpp", 93 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;

  const Array< const BFFVariable * > & members = v->GetStructMembers();
  for ( const BFFVariable ** it = members.Begin();
     it != members.End();
     ++it )
  {
   const BFFVariable * member = ( *it );
   BFFStackFrame::SetVar( member, frame );
  }
 }

 return true;
}
# 104 "/home/ffulin/p4/tmp/Unity/Tools/FBuild/FBuildCore/Unity1.cpp" 2


# 1 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/BFF/Functions/FunctionUnity.cpp" 1





# 1 "./Tools/FBuild/FBuildCore/PrecompiledHeader.h" 1
# 7 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/BFF/Functions/FunctionUnity.cpp" 2

# 1 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/BFF/Functions/FunctionUnity.h" 1


       







class FunctionUnity : public Function
{
public:
 explicit FunctionUnity();
 inline virtual ~FunctionUnity() {}

protected:
 virtual bool AcceptsHeader() const;
 virtual bool NeedsHeader() const;

 virtual bool Commit( const BFFIterator & funcStartIter ) const;
};
# 9 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/BFF/Functions/FunctionUnity.cpp" 2
# 22 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/BFF/Functions/FunctionUnity.cpp"
class UnityNode;



FunctionUnity::FunctionUnity()
: Function( "Unity" )
{
}



            bool FunctionUnity::AcceptsHeader() const
{
 return true;
}



            bool FunctionUnity::NeedsHeader() const
{
 return true;
}



            bool FunctionUnity::Commit( const BFFIterator & funcStartIter ) const
{
 Array< AString > paths;
 Array< AString > pathsToExclude;
 Array< AString > excludePatterns;
 const BFFVariable * inputPatternV;
 bool inputPathRecurse;
 const BFFVariable * outputPathV;
 const BFFVariable * outputPatternV;
 bool isolateWritableFiles;
 Array< AString > files;
 int numFiles;
 int maxIsolatedFiles;
 if ( !GetStrings( funcStartIter, pathsToExclude, ".UnityInputExcludePath", false ) ||
   !GetStrings( funcStartIter, excludePatterns, ".UnityInputExcludePattern", false ) ||
   !GetString( funcStartIter, inputPatternV, ".UnityInputPattern" ) ||
   !GetBool( funcStartIter, inputPathRecurse,".UnityInputPathRecurse", true ) ||
   !GetStrings( funcStartIter, files, ".UnityInputFiles", false ) ||
   !GetString( funcStartIter, outputPathV, ".UnityOutputPath", true ) ||
   !GetString( funcStartIter, outputPatternV, ".UnityOutputPattern" ) ||
   !GetStrings( funcStartIter, paths, ".UnityInputPath", false ) ||
   !GetBool( funcStartIter, isolateWritableFiles,".UnityInputIsolateWritableFiles", false ) ||
   !GetInt( funcStartIter, numFiles, ".UnityNumFiles", 1, false, 1, 999 ) ||
   !GetInt( funcStartIter, maxIsolatedFiles, ".UnityInputIsolateWritableFilesLimit", 0, false, 0, 999 ) )
 {
  return false;
 }


 CleanFolderPaths( paths );
 CleanFolderPaths( pathsToExclude );
 CleanFilePaths( files );


 for ( Array< AString >::Iter it = excludePatterns.Begin(); it != excludePatterns.End(); ++it )
 {
  it->Replace( ( '\\' ), ( '/' ) );
 }

 NodeGraph & ng = FBuild::Get().GetDependencyGraph();

 const AString & inputPattern = inputPatternV ? inputPatternV->GetString() : (const AString &)AStackString<>( "*.cpp" );
 const AString & outputPattern = outputPatternV ? outputPatternV->GetString() : (const AString &)AStackString<>( "Unity*.cpp" );

 Dependencies dirNodes( paths.GetSize() );
 if ( !GetDirectoryListNodeList( funcStartIter, paths, pathsToExclude, inputPathRecurse, inputPattern, "UnityInputPath", dirNodes ) )
 {
  return false;
 }


 AStackString< 512 > precompiledHeader;
 const BFFVariable * pchV = (0);
 if ( !GetString( funcStartIter, pchV, ".UnityPCH" ) )
 {
  return false;
 }
 if ( pchV )
 {

  precompiledHeader = pchV->GetString();
        PathUtils::FixupFilePath( precompiledHeader );
 }


 Array< AString > filesToExclude( 0, true );
 if ( !GetStrings( funcStartIter, filesToExclude, ".UnityInputExcludedFiles", false ) )
 {
  return false;
 }

 AString * const end = filesToExclude.End();
 for ( AString * it = filesToExclude.Begin(); it != end; ++it )
 {
  AString & file = *it;


  PathUtils::FixupFilePath( file );


  if ( PathUtils::IsFullPath( file ) == false )
  {
   AStackString<> tmp;
   tmp += ( '/' );
   tmp += file;
   file = tmp;
  }
 }


 if ( precompiledHeader.EndsWithI( ".h" ) )
 {
  AStackString<> pchCPP( precompiledHeader.Get(),
          precompiledHeader.Get() + precompiledHeader.GetLength() - 2 );
  pchCPP += ".cpp";
  filesToExclude.Append( pchCPP );
 }


 do { if ( !( m_AliasForFunction.IsEmpty() == false ) ) { if ( AssertHandler::Failure( "m_AliasForFunction.IsEmpty() == false", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/BFF/Functions/FunctionUnity.cpp", 146 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;

 AStackString< 512 > fullOutputPath;
 NodeGraph::CleanPath( outputPathV->GetString(), fullOutputPath );
 PathUtils::EnsureTrailingSlash( fullOutputPath );


 if ( ng.FindNode( m_AliasForFunction ) )
 {
  Error::Error_1100_AlreadyDefined( funcStartIter, this, m_AliasForFunction );
  return false;
 }

 UnityNode * un = ng.CreateUnityNode( m_AliasForFunction,
           dirNodes,
           files,
           fullOutputPath,
           outputPattern,
           numFiles,
           precompiledHeader,
           pathsToExclude,
           filesToExclude,
           isolateWritableFiles,
           maxIsolatedFiles,
           excludePatterns );
 do { if ( !( un ) ) { if ( AssertHandler::Failure( "un", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/BFF/Functions/FunctionUnity.cpp", 171 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ; (void)un;

 return true;
}
# 107 "/home/ffulin/p4/tmp/Unity/Tools/FBuild/FBuildCore/Unity1.cpp" 2


# 1 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/BFF/Functions/FunctionPrint.cpp" 1





# 1 "./Tools/FBuild/FBuildCore/PrecompiledHeader.h" 1
# 7 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/BFF/Functions/FunctionPrint.cpp" 2

# 1 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/BFF/Functions/FunctionPrint.h" 1


       
# 13 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/BFF/Functions/FunctionPrint.h"
class FunctionPrint : public Function
{
public:
 explicit FunctionPrint();
 inline virtual ~FunctionPrint() {}

protected:
 virtual bool AcceptsHeader() const;
 virtual bool NeedsHeader() const;
 virtual bool NeedsBody() const;

 virtual bool ParseFunction( const BFFIterator & functionNameStart,
        const BFFIterator * functionBodyStartToken,
        const BFFIterator * functionBodyStopToken,
        const BFFIterator * functionHeaderStartToken,
        const BFFIterator * functionHeaderStopToken ) const;
};
# 9 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/BFF/Functions/FunctionPrint.cpp" 2






FunctionPrint::FunctionPrint()
: Function( "Print" )
{
}



            bool FunctionPrint::AcceptsHeader() const
{
 return true;
}



            bool FunctionPrint::NeedsHeader() const
{
 return true;
}



            bool FunctionPrint::NeedsBody() const
{
 return false;
}


            bool FunctionPrint::ParseFunction( const BFFIterator & functionNameStart,
              const BFFIterator * functionBodyStartToken,
              const BFFIterator * functionBodyStopToken,
              const BFFIterator * functionHeaderStartToken,
              const BFFIterator * functionHeaderStopToken ) const
{
 (void)functionNameStart;
 (void)functionBodyStartToken;
 (void)functionBodyStopToken;

 if ( functionHeaderStartToken && functionHeaderStopToken &&
   ( functionHeaderStartToken->GetDistTo( *functionHeaderStopToken ) >= 1 ) )
 {
  BFFIterator start( *functionHeaderStartToken );
  do { if ( !( *start == BFFParser::BFF_FUNCTION_ARGS_OPEN ) ) { if ( AssertHandler::Failure( "*start == BFFParser::BFF_FUNCTION_ARGS_OPEN", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/BFF/Functions/FunctionPrint.cpp", 56 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;
  start++;
  start.SkipWhiteSpace();


  const char c = *start;
  if ( ( c != '"' ) && ( c != '\'' ) )
  {
   Error::Error_1001_MissingStringStartToken( start, this );
   return false;
  }


  BFFIterator stop( start );
  stop.SkipString( c );
  do { if ( !( stop.GetCurrent() <= functionHeaderStopToken->GetCurrent() ) ) { if ( AssertHandler::Failure( "stop.GetCurrent() <= functionHeaderStopToken->GetCurrent()", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/BFF/Functions/FunctionPrint.cpp", 71 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;


  AStackString< 1024 > tmp;

  start++;
  if ( BFFParser::PerformVariableSubstitutions( start, stop, tmp ) == false )
  {
   return false;
  }
  tmp += '\n';

  do { FLog::Build( "%s", tmp.Get() ); } while ( false ); ;
 }

 return true;
}
# 110 "/home/ffulin/p4/tmp/Unity/Tools/FBuild/FBuildCore/Unity1.cpp" 2


# 1 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/BFF/Functions/FunctionDLL.cpp" 1





# 1 "./Tools/FBuild/FBuildCore/PrecompiledHeader.h" 1
# 7 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/BFF/Functions/FunctionDLL.cpp" 2

# 1 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/BFF/Functions/FunctionDLL.h" 1


       





# 1 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/BFF/Functions/FunctionExecutable.h" 1


       
# 15 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/BFF/Functions/FunctionExecutable.h"
class AString;
class Dependencies;
class Node;



class FunctionExecutable : public Function
{
public:
 explicit FunctionExecutable();
 inline virtual ~FunctionExecutable() {}

protected:
 virtual bool AcceptsHeader() const;
 virtual bool Commit( const BFFIterator & funcStartIter ) const;
private:

 bool DependOnNode( const BFFIterator & iter, const AString & nodeName, Dependencies & nodes ) const;
 bool DependOnNode( const BFFIterator & iter, Node * node, Dependencies & nodes ) const;

 void GetImportLibName( const AString & args, AString & importLibName ) const;

 bool GetOtherLibraries( const BFFIterator & iter, const AString & args, Dependencies & otherLibraries, bool msvc ) const;
 bool GetOtherLibrary( const BFFIterator & iter, Dependencies & libs, const AString & path, const AString & lib, bool & found ) const;

 static bool GetOtherLibsArg( const char * arg,
         Array< AString > & list,
         const AString * & it,
         const AString * const & end,
         bool canonicalizePath = false );
};
# 10 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/BFF/Functions/FunctionDLL.h" 2



class FunctionDLL : public FunctionExecutable
{
public:
 explicit FunctionDLL();
 inline virtual ~FunctionDLL() {}
};
# 9 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/BFF/Functions/FunctionDLL.cpp" 2



FunctionDLL::FunctionDLL()
: FunctionExecutable()
{

 m_Name = "DLL";
}
# 113 "/home/ffulin/p4/tmp/Unity/Tools/FBuild/FBuildCore/Unity1.cpp" 2


# 1 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/BFF/Functions/FunctionObjectList.cpp" 1





# 1 "./Tools/FBuild/FBuildCore/PrecompiledHeader.h" 1
# 7 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/BFF/Functions/FunctionObjectList.cpp" 2
# 19 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/BFF/Functions/FunctionObjectList.cpp"
# 1 "./Tools/FBuild/FBuildCore/Graph/ObjectListNode.h" 1


       
# 14 "./Tools/FBuild/FBuildCore/Graph/ObjectListNode.h"
class CompilerNode;
class ObjectNode;



class ObjectListNode : public Node
{
public:
 explicit ObjectListNode( const AString & listName,
        const Dependencies & inputNodes,
        CompilerNode * compiler,
        const AString & compilerArgs,
        const AString & compilerArgsDeoptimized,
        const AString & compilerOutputPath,
        ObjectNode * precompiledHeader,
        const Dependencies & compilerForceUsing,
        const Dependencies & preBuildDependencies,
        bool deoptimizeWritableFiles,
        bool deoptimizeWritableFilesWithToken );
 virtual ~ObjectListNode();

 static inline Node::Type GetType() { return Node::OBJECT_LIST_NODE; }

 virtual bool IsAFile() const;

 static Node * Load( IOStream & stream );
 virtual void Save( IOStream & stream ) const;

 const char * GetObjExtension() const;

 void GetInputFiles( AString & fullArgs, const AString & pre, const AString & post ) const;
private:
 friend class FunctionObjectList;

 virtual bool DoDynamicDependencies( bool forceClean );
 virtual BuildResult DoBuild( Job * job );


 bool CreateDynamicObjectNode( Node * inputFile, bool isUnityNode = false, bool isIsolatedFromUnityNode = false );

 CompilerNode * m_Compiler;
 AString m_CompilerArgs;
 AString m_CompilerArgsDeoptimized;
 AString m_CompilerOutputPath;
 Dependencies m_CompilerForceUsing;
 ObjectNode * m_PrecompiledHeader;
 AString m_ObjExtensionOverride;
 bool m_DeoptimizeWritableFiles;
 bool m_DeoptimizeWritableFilesWithToken;
};
# 20 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/BFF/Functions/FunctionObjectList.cpp" 2




FunctionObjectList::FunctionObjectList()
: Function( "ObjectList" )
{
}



            bool FunctionObjectList::AcceptsHeader() const
{
 return true;
}



            bool FunctionObjectList::NeedsHeader() const
{
 return true;
}



            bool FunctionObjectList::Commit( const BFFIterator & funcStartIter ) const
{

 const BFFVariable * compiler;
 const BFFVariable * compilerOptions;
 AStackString<> compilerOptionsDeoptimized;
 const BFFVariable * compilerOutputPath;
 const BFFVariable * compilerOutputExtension;
 if ( !GetString( funcStartIter, compiler, ".Compiler", true ) ||
   !GetString( funcStartIter, compilerOptions, ".CompilerOptions", true ) ||
   !GetString( funcStartIter, compilerOptionsDeoptimized, ".CompilerOptionsDeoptimized", false ) ||
   !GetString( funcStartIter, compilerOutputPath, ".CompilerOutputPath", true ) ||
   !GetString( funcStartIter, compilerOutputExtension, ".CompilerOutputExtension", false ) )
 {
  return false;
 }

 NodeGraph & ng = FBuild::Get().GetDependencyGraph();


 CompilerNode * compilerNode = (0);
 if ( !FunctionObjectList::GetCompilerNode( funcStartIter, compiler->GetString(), compilerNode ) )
 {
  return false;
 }


 uint32_t objFlags = ObjectNode::DetermineFlags( compilerNode, compilerOptions->GetString() );
 if ( ( objFlags & ObjectNode::FLAG_MSVC ) && ( objFlags & ObjectNode::FLAG_CREATING_PCH ) )
 {

  Error::Error_1303_PCHCreateOptionOnlyAllowedOnPCH( funcStartIter, this, "/Yc", "CompilerOptions" );
  return false;
 }


 {
  const AString & args = compilerOptions->GetString();
  bool hasInputToken = ( args.Find( "%1" ) || args.Find( "\"%1\"" ) );
  if ( hasInputToken == false )
  {
   Error::Error_1106_MissingRequiredToken( funcStartIter, this, ".CompilerOptions", "%1" );
   return false;
  }
  bool hasOutputToken = ( args.Find( "%2" ) || args.Find( "\"%2\"" ) );
  if ( hasOutputToken == false )
  {
   Error::Error_1106_MissingRequiredToken( funcStartIter, this, ".CompilerOptions", "%2" );
   return false;
  }
 }


 Dependencies compilerForceUsing;
 if ( !GetNodeList( funcStartIter, ".CompilerForceUsing", compilerForceUsing, false ) )
 {
  return false;
 }


 Dependencies preBuildDependencies;
 if ( !GetNodeList( funcStartIter, ".PreBuildDependencies", preBuildDependencies, false ) )
 {
  return false;
 }


 bool deoptimizeWritableFiles = false;
 bool deoptimizeWritableFilesWithToken = false;
 if ( !GetBool( funcStartIter, deoptimizeWritableFiles, ".DeoptimizeWritableFiles", false, false ) )
 {
  return false;
 }
 if ( !GetBool( funcStartIter, deoptimizeWritableFilesWithToken, ".DeoptimizeWritableFilesWithToken", false, false ) )
 {
  return false;
 }
 if ( ( deoptimizeWritableFiles || deoptimizeWritableFilesWithToken ) && compilerOptionsDeoptimized.IsEmpty() )
 {
  Error::Error_1101_MissingProperty( funcStartIter, this, AStackString<>( ".CompilerOptionsDeoptimized" ) );
  return false;
 }


 ObjectNode * precompiledHeaderNode = (0);
 if ( !GetPrecompiledHeaderNode( funcStartIter, compilerNode, objFlags, compilerOptions, compilerForceUsing, precompiledHeaderNode, deoptimizeWritableFiles, deoptimizeWritableFilesWithToken ) )
 {
  return false;
 }

 Dependencies staticDeps( 32, true );
 if ( !GetInputs( funcStartIter, staticDeps ) )
 {
  return false;
 }

 if ( staticDeps.IsEmpty() )
 {
  Error::Error_1006_NothingToBuild( funcStartIter, this );
  return false;
 }


 do { if ( !( m_AliasForFunction.IsEmpty() == false ) ) { if ( AssertHandler::Failure( "m_AliasForFunction.IsEmpty() == false", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/BFF/Functions/FunctionObjectList.cpp", 148 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;


 if ( ng.FindNode( m_AliasForFunction ) )
 {
  Error::Error_1100_AlreadyDefined( funcStartIter, this, m_AliasForFunction );
  return false;
 }


 ObjectListNode * o = ng.CreateObjectListNode( m_AliasForFunction,
              staticDeps,
              compilerNode,
              compilerOptions->GetString(),
              compilerOptionsDeoptimized,
              compilerOutputPath->GetString(),
              precompiledHeaderNode,
              compilerForceUsing,
              preBuildDependencies,
              deoptimizeWritableFiles,
              deoptimizeWritableFilesWithToken );
 if ( compilerOutputExtension )
 {
  o->m_ObjExtensionOverride = compilerOutputExtension->GetString();
 }

 return true;
}



bool FunctionObjectList::GetCompilerNode( const BFFIterator & iter, const AString & compiler, CompilerNode * & compilerNode ) const
{
 NodeGraph & ng = FBuild::Get().GetDependencyGraph();
 Node * cn = ng.FindNode( compiler );
 compilerNode = (0);
 if ( cn != (0) )
 {
  if ( cn->GetType() == Node::ALIAS_NODE )
  {
   AliasNode * an = cn->CastTo< AliasNode >();
   cn = an->GetAliasedNodes()[ 0 ].GetNode();
  }
  if ( cn->GetType() != Node::COMPILER_NODE )
  {
   Error::Error_1102_UnexpectedType( iter, this, "Compiler", cn->GetName(), cn->GetType(), Node::COMPILER_NODE );
   return false;
  }
  compilerNode = cn->CastTo< CompilerNode >();
 }
 else
 {


  const bool allowDistribution = false;
  compilerNode = ng.CreateCompilerNode( compiler, Dependencies( 0, false ), allowDistribution );
 }

 return true;
}



bool FunctionObjectList::GetPrecompiledHeaderNode( const BFFIterator & iter,
               CompilerNode * compilerNode,
               uint32_t objFlags,
               const BFFVariable * compilerOptions,
               const Dependencies & compilerForceUsing,
               ObjectNode * & precompiledHeaderNode,
               bool deoptimizeWritableFiles,
               bool deoptimizeWritableFilesWithToken ) const
{
 const BFFVariable * pchInputFile = (0);
 const BFFVariable * pchOutputFile = (0);
 const BFFVariable * pchOptions = (0);
 if ( !GetString( iter, pchInputFile, ".PCHInputFile" ) ||
   !GetString( iter, pchOutputFile, ".PCHOutputFile" ) ||
   !GetString( iter, pchOptions, ".PCHOptions" ) )
 {
  return false;
 }

 precompiledHeaderNode = (0);

 if ( pchInputFile )
 {
  if ( !pchOutputFile || !pchOptions )
  {
   Error::Error_1300_MissingPCHArgs( iter, this );
   return false;
  }

  AStackString<> pchOptionsDeoptimized;
  if ( !GetString( iter, pchOptionsDeoptimized, ".PCHOptionsDeoptimized", ( deoptimizeWritableFiles || deoptimizeWritableFilesWithToken ) ) )
  {
   return false;
  }

  NodeGraph & ng = FBuild::Get().GetDependencyGraph();
  Node * pchInputNode = ng.FindNode( pchInputFile->GetString() );
  if ( pchInputNode )
  {

   if ( pchInputNode->IsAFile() == false )
   {
    Error::Error_1103_NotAFile( iter, this, "PCHInputFile", pchInputNode->GetName(), pchInputNode->GetType() );
    return false;
   }
  }
  else
  {

   pchInputNode = ng.CreateFileNode( pchInputFile->GetString() );
  }

  if ( ng.FindNode( pchOutputFile->GetString() ) )
  {
   Error::Error_1301_AlreadyDefinedPCH( iter, this, pchOutputFile->GetString().Get() );
   return false;
  }

  uint32_t pchFlags = ObjectNode::DetermineFlags( compilerNode, pchOptions->GetString() );
  if ( pchFlags & ObjectNode::FLAG_MSVC )
  {



   if ( !( pchFlags & ObjectNode::FLAG_CREATING_PCH ) )
   {
    Error::Error_1302_MissingPCHCompilerOption( iter, this, "/Yc", "PCHOptions" );
    return false;
   }

   if ( pchOptions->GetString().Find( "/Fp" ) == (0) )
   {
    Error::Error_1302_MissingPCHCompilerOption( iter, this, "/Fp", "PCHOptions" );
    return false;
   }

   if ( pchOptions->GetString().Find( "/Fo" ) == (0) )
   {
    Error::Error_1302_MissingPCHCompilerOption( iter, this, "/Fo", "PCHOptions" );
    return false;
   }


   if ( !( objFlags & ObjectNode::FLAG_USING_PCH ) )
   {
    Error::Error_1302_MissingPCHCompilerOption( iter, this, "/Yu", "CompilerOptions" );
    return false;
   }

   if ( compilerOptions->GetString().Find( "/Fp" ) == (0) )
   {
    Error::Error_1302_MissingPCHCompilerOption( iter, this, "/Fp", "CompilerOptions" );
    return false;
   }
  }



  precompiledHeaderNode = ng.CreateObjectNode( pchOutputFile->GetString(),
              pchInputNode,
              compilerNode,
              pchOptions->GetString(),
              pchOptionsDeoptimized,
              (0),
              pchFlags,
              compilerForceUsing,
              deoptimizeWritableFiles,
              deoptimizeWritableFilesWithToken );
 }

 return true;
}



bool FunctionObjectList::GetInputs( const BFFIterator & iter, Dependencies & inputs ) const
{
 NodeGraph & ng = FBuild::Get().GetDependencyGraph();


 const BFFVariable * inputUnity = (0);
 if ( !GetString( iter, inputUnity, ".CompilerInputUnity" ) )
 {
  return false;
 }
 if ( inputUnity )
 {
  Node * n = ng.FindNode( inputUnity->GetString() );
  if ( n == (0) )
  {
   Error::Error_1104_TargetNotDefined( iter, this, "CompilerInputUnity", inputUnity->GetString() );
   return false;
  }
  if ( n->GetType() != Node::UNITY_NODE )
  {
   Error::Error_1102_UnexpectedType( iter, this, "CompilerInputUnity", inputUnity->GetString(), n->GetType(), Node::UNITY_NODE );
   return false;
  }
  inputs.Append( Dependency( n ) );
 }


 const BFFVariable * inputPath = BFFStackFrame::GetVar( ".CompilerInputPath" );
 if ( inputPath )
 {

  const BFFVariable * patternVar = (0);
  if ( !GetString( iter, patternVar, ".CompilerInputPattern", false ) )
  {
   return false;
  }
  AStackString<> defaultWildCard( "*.cpp" );
  const AString & pattern = patternVar ? patternVar->GetString() : defaultWildCard;


  bool recurse = true;
  if ( !GetBool( iter, recurse, ".CompilerInputPathRecurse", true, false ) )
  {
   return false;
  }


  Array< AString > excludePaths;
  if ( !GetFolderPaths( iter, excludePaths, ".CompilerInputExcludePath", false ) )
  {
   return false;
  }


  Array< AString > inputPaths;
  if ( !GetFolderPaths( iter, inputPaths, ".CompilerInputPath", false ) )
  {
   return false;
  }

  Dependencies dirNodes( inputPaths.GetSize() );
  if ( !GetDirectoryListNodeList( iter, inputPaths, excludePaths, recurse, pattern, "CompilerInputPath", dirNodes ) )
  {
   return false;
  }
  inputs.Append( dirNodes );
 }


 if ( !GetNodeList( iter, ".CompilerInputFiles", inputs, false ) )
 {

  return false;
 }

 return true;
}
# 116 "/home/ffulin/p4/tmp/Unity/Tools/FBuild/FBuildCore/Unity1.cpp" 2


# 1 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/BFF/Functions/FunctionForEach.cpp" 1





# 1 "./Tools/FBuild/FBuildCore/PrecompiledHeader.h" 1
# 7 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/BFF/Functions/FunctionForEach.cpp" 2

# 1 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/BFF/Functions/FunctionForEach.h" 1


       
# 13 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/BFF/Functions/FunctionForEach.h"
class FunctionForEach : public Function
{
public:
 explicit FunctionForEach();
 inline virtual ~FunctionForEach() {}

 virtual bool AcceptsHeader() const;
 virtual bool NeedsHeader() const;
 virtual bool ParseFunction( const BFFIterator & functionNameStart,
        const BFFIterator * functionBodyStartToken,
        const BFFIterator * functionBodyStopToken,
        const BFFIterator * functionHeaderStartToken,
        const BFFIterator * functionHeaderStopToken ) const;
};
# 9 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/BFF/Functions/FunctionForEach.cpp" 2
# 19 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/BFF/Functions/FunctionForEach.cpp"
FunctionForEach::FunctionForEach()
: Function( "ForEach" )
{
}



            bool FunctionForEach::AcceptsHeader() const
{
 return true;
}



            bool FunctionForEach::NeedsHeader() const
{
 return true;
}


            bool FunctionForEach::ParseFunction(
     const BFFIterator & functionNameStart,
     const BFFIterator * functionBodyStartToken,
     const BFFIterator * functionBodyStopToken,
     const BFFIterator * functionHeaderStartToken,
     const BFFIterator * functionHeaderStopToken ) const
{

 Array< AString > localNames( 4, true );
 Array< const BFFVariable * > arrayVars( 4, true );

 int loopLen = -1;


 BFFIterator pos( *functionHeaderStartToken );
 pos++;
 while ( pos < *functionHeaderStopToken )
 {
  pos.SkipWhiteSpace();
  if ( *pos != BFFParser::BFF_DECLARE_VAR_INTERNAL )
  {
   Error::Error_1200_ExpectedVar( pos, this );
   return false;
  }
  BFFIterator varNameStart( pos );
  pos++;
  if ( pos.IsAtValidVariableNameCharacter() == false )
  {
   Error::Error_1013_UnexpectedCharInVariableName( pos, this );
   return false;
  }
  pos.SkipVariableName();
  BFFIterator varNameEnd( pos );


  size_t varNameLen = varNameStart.GetDistTo( varNameEnd );
  if ( varNameLen > BFFParser::MAX_VARIABLE_NAME_LENGTH )
  {
   Error::Error_1014_VariableNameIsTooLong( varNameStart, (uint32_t)varNameLen, (uint32_t)BFFParser::MAX_VARIABLE_NAME_LENGTH );
   return false;
  }
  AStackString< BFFParser::MAX_VARIABLE_NAME_LENGTH > localName( varNameStart.GetCurrent(), varNameEnd.GetCurrent() );
  localNames.Append( localName );

  pos.SkipWhiteSpace();


  bool foundIn = false;
  if ( *pos == 'i' )
  {
   pos++;
   if ( *pos == 'n' )
   {
    foundIn = true;
   }
  }
  if ( foundIn == false )
  {
   Error::Error_1201_MissingIn( pos, this );
   return false;
  }
  pos++;
  pos.SkipWhiteSpace();

  BFFIterator arrayVarNameBegin( pos );
  if ( *pos != BFFParser::BFF_DECLARE_VAR_INTERNAL )
  {
   Error::Error_1202_ExpectedVarFollowingIn( pos, this );
   return false;
  }
  pos++;
  if ( pos.IsAtValidVariableNameCharacter() == false )
  {
   Error::Error_1013_UnexpectedCharInVariableName( pos, this );
   return false;
  }
  pos.SkipVariableName();
  BFFIterator arrayVarNameEnd( pos );


  size_t arrayVarNameLen = arrayVarNameBegin.GetDistTo( arrayVarNameEnd );
  if ( arrayVarNameLen > BFFParser::MAX_VARIABLE_NAME_LENGTH )
  {
   Error::Error_1014_VariableNameIsTooLong( arrayVarNameBegin, (uint32_t)arrayVarNameLen, (uint32_t)BFFParser::MAX_VARIABLE_NAME_LENGTH );
   return false;
  }
  AStackString< BFFParser::MAX_VARIABLE_NAME_LENGTH > arrayVarName( arrayVarNameBegin.GetCurrent(), arrayVarNameEnd.GetCurrent() );

  const BFFVariable * var = BFFStackFrame::GetVar( arrayVarName );
  if ( var == (0) )
  {
   Error::Error_1009_UnknownVariable( arrayVarNameBegin, this );
   return false;
  }


  if ( ( var->IsArrayOfStrings() == false ) && ( var->IsArrayOfStructs() == false ) )
  {
   Error::Error_1050_PropertyMustBeOfType( arrayVarNameBegin, this, arrayVarName.Get(), var->GetType(), BFFVariable::VAR_ARRAY_OF_STRINGS, BFFVariable::VAR_ARRAY_OF_STRUCTS );
   return false;
  }


  int thisArrayLen( -1 );
  if ( var->GetType() == BFFVariable::VAR_ARRAY_OF_STRINGS )
  {
   thisArrayLen = (int)var->GetArrayOfStrings().GetSize();
  }
  else if ( var->GetType() == BFFVariable::VAR_ARRAY_OF_STRUCTS )
  {
   thisArrayLen = (int)var->GetArrayOfStructs().GetSize();
  }
  else
  {
   do { if ( !( false ) ) { if ( AssertHandler::Failure( "false", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/BFF/Functions/FunctionForEach.cpp", 153 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;
  }

  if ( loopLen == -1 )
  {

   loopLen = thisArrayLen;
  }
  else
  {

   if ( loopLen != thisArrayLen )
   {
    Error::Error_1204_LoopVariableLengthsDiffer( arrayVarNameBegin, this, arrayVarName.Get(), (uint32_t)thisArrayLen, (uint32_t)loopLen );
    return false;
   }
  }
  arrayVars.Append( var );


  pos.SkipWhiteSpace();
  if ( *pos == ',' )
  {
   pos++;
  }
 }

 do { if ( !( localNames.GetSize() == arrayVars.GetSize() ) ) { if ( AssertHandler::Failure( "localNames.GetSize() == arrayVars.GetSize()", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/BFF/Functions/FunctionForEach.cpp", 180 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;


 if ( loopLen < 1 )
 {
  return true;
 }

 for ( uint32_t i=0; i<(uint32_t)loopLen; ++i )
 {

  BFFStackFrame loopStackFrame;
  for ( uint32_t j=0; j<localNames.GetSize(); ++j )
  {
   if ( arrayVars[ j ]->GetType() == BFFVariable::VAR_ARRAY_OF_STRINGS )
   {
    loopStackFrame.SetVarString( localNames[ j ], arrayVars[ j ]->GetArrayOfStrings()[ i ] );
   }
   else if ( arrayVars[ j ]->GetType() == BFFVariable::VAR_ARRAY_OF_STRUCTS )
   {
    loopStackFrame.SetVarStruct( localNames[ j ], arrayVars[ j ]->GetArrayOfStructs()[ i ]->GetStructMembers() );
   }
   else
   {
    do { if ( !( false ) ) { if ( AssertHandler::Failure( "false", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/BFF/Functions/FunctionForEach.cpp", 204 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;
   }
  }


  BFFParser subParser;
  BFFIterator subIter( *functionBodyStartToken );
  subIter++;
  subIter.SetMax( functionBodyStopToken->GetCurrent() );
  if ( subParser.Parse( subIter ) == false )
  {
   return false;
  }


  if ( Commit( functionNameStart ) == false )
  {
   return false;
  }
 }

 return true;
}
# 119 "/home/ffulin/p4/tmp/Unity/Tools/FBuild/FBuildCore/Unity1.cpp" 2


# 1 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/BFF/Functions/FunctionExecutable.cpp" 1





# 1 "./Tools/FBuild/FBuildCore/PrecompiledHeader.h" 1
# 7 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/BFF/Functions/FunctionExecutable.cpp" 2







# 1 "./Tools/FBuild/FBuildCore/Graph/DLLNode.h" 1


       





# 1 "./Tools/FBuild/FBuildCore/Graph/LinkerNode.h" 1


       
# 17 "./Tools/FBuild/FBuildCore/Graph/LinkerNode.h"
class LinkerNode : public FileNode
{
public:
 explicit LinkerNode( const AString & linkerOutputName,
       const Dependencies & inputLibraries,
       const Dependencies & otherLibraries,
       const AString & linker,
       const AString & linkerArgs,
       uint32_t flags,
       const Dependencies & assemblyResources,
       Node * linkerStampExe,
       const AString & linkerStampExeArgs );
 virtual ~LinkerNode();

 enum Flag
 {
  LINK_FLAG_MSVC = 0x01,
  LINK_FLAG_DLL = 0x02,
  LINK_OBJECTS = 0x04,
  LINK_FLAG_GCC = 0x08,
  LINK_FLAG_SNC = 0x10,
  LINK_FLAG_ORBIS_LD = 0x20,
  LINK_FLAG_INCREMENTAL = 0x40,
  LINK_FLAG_GREENHILLS_ELXR = 0x80,
  LINK_FLAG_CODEWARRIOR_LD=0x100
 };

 inline bool IsADLL() const { return GetFlag( LINK_FLAG_DLL ); }

 virtual void Save( IOStream & stream ) const;

 static uint32_t DetermineFlags( const AString & linkerName, const AString & args );
protected:
 virtual BuildResult DoBuild( Job * job );

 void DoPreLinkCleanup() const;

 void GetFullArgs( AString & fullArgs ) const;
 void GetInputFiles( AString & fullArgs, const AString & pre, const AString & post ) const;
 void GetInputFiles( Node * n, AString & fullArgs, const AString & pre, const AString & post ) const;
 void GetAssemblyResourceFiles( AString & fullArgs, const AString & pre, const AString & post ) const;
 void EmitCompilationMessage( const AString & fullArgs ) const;
 void EmitStampMessage() const;

 inline bool GetFlag( Flag flag ) const { return ( ( m_Flags & (uint32_t)flag ) != 0 ); }

 inline const char * GetDLLOrExe() const { return GetFlag( LINK_FLAG_DLL ) ? "DLL" : "Exe"; }

 virtual Priority GetPriority() const { return PRIORITY_HIGH; }

 AString m_Linker;
 AString m_LinkerArgs;
 uint32_t m_Flags;
 Dependencies m_AssemblyResources;
 Dependencies m_OtherLibraries;
    const Node * m_LinkerStampExe;
    AString m_LinkerStampExeArgs;
};
# 10 "./Tools/FBuild/FBuildCore/Graph/DLLNode.h" 2






class DLLNode : public LinkerNode
{
public:
 explicit DLLNode( const AString & linkerOutputName,
       const Dependencies & inputLibraries,
       const Dependencies & otherLibraries,
       const AString & linker,
       const AString & linkerArgs,
       uint32_t flags,
       const Dependencies & assemblyResources,
       const AString & importLibName,
       Node * linkerStampExe,
       const AString & linkerStampExeArgs );
 virtual ~DLLNode();

 void GetImportLibName( AString & importLibName ) const;

 static inline Node::Type GetType() { return Node::DLL_NODE; }

 static Node * Load( IOStream & stream );
private:
 virtual void Save( IOStream & stream ) const;

 AString m_ImportLibName;
};
# 15 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/BFF/Functions/FunctionExecutable.cpp" 2
# 1 "./Tools/FBuild/FBuildCore/Graph/ExeNode.h" 1


       
# 16 "./Tools/FBuild/FBuildCore/Graph/ExeNode.h"
class ExeNode : public LinkerNode
{
public:
 explicit ExeNode( const AString & linkerOutputName,
       const Dependencies & inputLibraries,
       const Dependencies & otherLibraries,
       const AString & linker,
       const AString & linkerArgs,
       uint32_t flags,
       const Dependencies & assemblyResources,
       Node * linkerStampExe,
       const AString & linkerStampExeArgs );
 virtual ~ExeNode();

 static inline Node::Type GetType() { return Node::EXE_NODE; }

 static Node * Load( IOStream & stream );
private:
};
# 16 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/BFF/Functions/FunctionExecutable.cpp" 2
# 26 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/BFF/Functions/FunctionExecutable.cpp"
FunctionExecutable::FunctionExecutable()
: Function( "Executable" )
{
}



            bool FunctionExecutable::AcceptsHeader() const
{
 return true;
}



            bool FunctionExecutable::Commit( const BFFIterator & funcStartIter ) const
{

 const BFFVariable * linker = BFFStackFrame::GetVar( ".Linker" );
 if ( linker == (0) )
 {
  Error::Error_1101_MissingProperty( funcStartIter, this, AStackString<>( "Linker" ) );
  return false;
 }
 AStackString<> linkerOutput;
 if ( !GetString( funcStartIter, linkerOutput, ".LinkerOutput", true ) )
 {
  return false;
 }
 if ( PathUtils::IsFolderPath( linkerOutput ) )
 {
  Error::Error_1105_PathNotAllowed( funcStartIter, this, ".LinkerOutput", linkerOutput );
  return false;
 }
 const BFFVariable * linkerOptions = BFFStackFrame::GetVar( ".LinkerOptions" );
 if ( linkerOptions == (0) )
 {
  Error::Error_1101_MissingProperty( funcStartIter, this, AStackString<>( "LinkerOptions" ) );
  return false;
 }
 const BFFVariable * libraries = BFFStackFrame::GetVar( ".Libraries" );
 if ( libraries == (0) )
 {
  Error::Error_1101_MissingProperty( funcStartIter, this, AStackString<>( "Libraries" ) );
  return false;
 }


 {
  const AString & args = linkerOptions->GetString();
  bool hasInputToken = ( args.Find( "%1" ) || args.Find( "\"%1\"" ) );
  if ( hasInputToken == false )
  {
   Error::Error_1106_MissingRequiredToken( funcStartIter, this, ".LinkerOptions", "%1" );
   return false;
  }
  bool hasOutputToken = ( args.Find( "%2" ) || args.Find( "\"%2\"" ) );
  if ( hasOutputToken == false )
  {
   Error::Error_1106_MissingRequiredToken( funcStartIter, this, ".LinkerOptions", "%2" );
   return false;
  }
 }


 Node * linkerStampExe( (0) );
 AStackString<> linkerStampExeArgs;
 if ( !GetFileNode( funcStartIter, linkerStampExe, ".LinkerStampExe" ) ||
   !GetString( funcStartIter, linkerStampExeArgs, ".LinkerStampExeArgs" ) )
 {
  return false;
 }

 NodeGraph & ng = FBuild::Get().GetDependencyGraph();


 Dependencies libraryNodes( 64, true );


 if ( libraries->IsArrayOfStrings() )
 {

  const Array< AString > & libraryNames = libraries->GetArrayOfStrings();
  for ( Array< AString >::ConstIter it = libraryNames.Begin();
     it != libraryNames.End();
     it++ )
  {
   if ( DependOnNode( funcStartIter, *it, libraryNodes ) == false )
   {
    return false;
   }
  }
 }
 else if ( libraries->IsString() )
 {

  if ( DependOnNode( funcStartIter, libraries->GetString(), libraryNodes ) == false )
  {
   return false;
  }
 }
 else
 {
  Error::Error_1050_PropertyMustBeOfType( funcStartIter, this, "Libraries", libraries->GetType(), BFFVariable::VAR_STRING, BFFVariable::VAR_ARRAY_OF_STRINGS );
  return false;
 }


 if ( ng.FindNode( linkerOutput ) )
 {
  Error::Error_1100_AlreadyDefined( funcStartIter, this, linkerOutput );
  return false;
 }


 Dependencies assemblyResources;
 if ( !GetNodeList( funcStartIter, ".LinkerAssemblyResources", assemblyResources, false ) )
 {
  return false;
 }


 uint32_t flags = LinkerNode::DetermineFlags( linker->GetString(), linkerOptions->GetString() );
 bool isADLL = ( ( flags & LinkerNode::LINK_FLAG_DLL ) != 0 );

 bool linkObjects = isADLL ? true : false;
 if ( GetBool( funcStartIter, linkObjects, ".LinkerLinkObjects", linkObjects, false ) == false )
 {
  return false;
 }
 if ( linkObjects )
 {
  flags |= LinkerNode::LINK_OBJECTS;
 }


 Dependencies otherLibraryNodes( 64, true );
 if ( ( flags & ( LinkerNode::LINK_FLAG_MSVC | LinkerNode::LINK_FLAG_GCC | LinkerNode::LINK_FLAG_SNC | LinkerNode::LINK_FLAG_ORBIS_LD | LinkerNode::LINK_FLAG_GREENHILLS_ELXR | LinkerNode::LINK_FLAG_CODEWARRIOR_LD ) ) != 0 )
 {
  const bool msvcStyle = ( ( flags & LinkerNode::LINK_FLAG_MSVC ) == LinkerNode::LINK_FLAG_MSVC );
  if ( !GetOtherLibraries( funcStartIter, linkerOptions->GetString(), otherLibraryNodes, msvcStyle ) )
  {
   return false;
  }
 }


 AStackString<> importLibName;
 if ( isADLL && ( ( flags & LinkerNode::LINK_FLAG_MSVC ) != 0 ) )
 {
  GetImportLibName( linkerOptions->GetString(), importLibName );
 }


 Node * n( (0) );
 if ( isADLL )
 {
  n = ng.CreateDLLNode( linkerOutput,
         libraryNodes,
         otherLibraryNodes,
         linker->GetString(),
         linkerOptions->GetString(),
         flags,
         assemblyResources,
         importLibName,
         linkerStampExe,
         linkerStampExeArgs );
 }
 else
 {
  n = ng.CreateExeNode( linkerOutput,
         libraryNodes,
         otherLibraryNodes,
         linker->GetString(),
         linkerOptions->GetString(),
         flags,
         assemblyResources,
         linkerStampExe,
         linkerStampExeArgs );
 }

 return ProcessAlias( funcStartIter, n );
}



bool FunctionExecutable::DependOnNode( const BFFIterator & iter, const AString & nodeName, Dependencies & nodes ) const
{

 if ( nodeName.IsEmpty() )
 {
  return true;
 }

 NodeGraph & ng = FBuild::Get().GetDependencyGraph();
 Node * node = ng.FindNode( nodeName );


 if ( node != (0) )
 {

  return DependOnNode( iter, node, nodes );
 }



 node = ng.CreateFileNode( nodeName );
 nodes.Append( Dependency( node ) );
 return true;
}



bool FunctionExecutable::DependOnNode( const BFFIterator & iter, Node * node, Dependencies & nodes ) const
{
 do { if ( !( node ) ) { if ( AssertHandler::Failure( "node", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/BFF/Functions/FunctionExecutable.cpp", 240 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;


 if ( node->GetType() == Node::LIBRARY_NODE )
 {

  nodes.Append( Dependency( node ) );
  return true;
 }


 if ( node->GetType() == Node::OBJECT_LIST_NODE )
 {

  nodes.Append( Dependency( node ) );
  return true;
 }


 if ( node->GetType() == Node::DLL_NODE )
 {

  nodes.Append( Dependency( node, true ) );
  return true;
 }


 if ( node->GetType() == Node::FILE_NODE )
 {

  nodes.Append( Dependency( node ) );
  return true;
 }


 if ( node->GetType() == Node::COPY_NODE )
 {

  nodes.Append( Dependency( node ) );
  return true;
 }


 if ( node->GetType() == Node::EXEC_NODE )
 {

  nodes.Append( Dependency( node ) );
  return true;
 }


 if ( node->GetType() == Node::ALIAS_NODE )
 {

  AliasNode * an = node->CastTo< AliasNode >();
  const Dependencies & aliasNodeList = an->GetAliasedNodes();
  const Dependencies::Iter end = aliasNodeList.End();
  for ( Dependencies::Iter it = aliasNodeList.Begin();
     it != end;
     ++it )
  {
   if ( DependOnNode( iter, it->GetNode(), nodes ) == false )
   {
    return false;
   }
  }
  return true;
 }


 Error::Error_1005_UnsupportedNodeType( iter, this, "Libraries", node->GetName(), node->GetType() );
 return false;
}



void FunctionExecutable::GetImportLibName( const AString & args, AString & importLibName ) const
{

 Array< AString > tokens;
 args.Tokenize( tokens );

 const AString * const end = tokens.End();
 for ( const AString * it = tokens.Begin(); it != end; ++it )
 {
  if ( it->BeginsWith( "/IMPLIB:") )
  {
   const char * impStart = it->Get() + 8;
   const char * impEnd = it->GetEnd();


   if ( impStart == impEnd )
   {
    ++it;

    if ( it == end )
    {
     return;
    }

    impStart = it->Get();
    impEnd = it->GetEnd();
   }

   Args::StripQuotes( impStart, impEnd, importLibName );
  }
 }
}



bool FunctionExecutable::GetOtherLibraries( const BFFIterator & iter,
           const AString & args,
           Dependencies & otherLibraries,
           bool msvc ) const
{

 Array< AString > tokens;
 args.Tokenize( tokens );

 bool ignoreAllDefaultLibs = false;
 Array< AString > defaultLibsToIgnore( 8, true );
 Array< AString > defaultLibs( 16, true );
 Array< AString > libs( 16, true );
 Array< AString > dashlLibs( 16, true );
 Array< AString > libPaths( 16, true );
 Array< AString > envLibPaths( 32, true );


 AStackString< 1024 > libVar;
 if ( Env::GetEnvVariable( "LIB", libVar ) )
 {
  libVar.Tokenize( envLibPaths, ';' );
 }

 const AString * const end = tokens.End();
 for ( const AString * it = tokens.Begin(); it != end; ++it )
 {
  const AString & token = *it;


  if ( msvc )
  {

   if ( token == "/NODEFAULTLIB" )
   {
    ignoreAllDefaultLibs = true;
    continue;
   }


   if ( GetOtherLibsArg( "/NODEFAULTLIB:", defaultLibsToIgnore, it, end ) )
   {
    continue;
   }


   if ( GetOtherLibsArg( "/DEFAULTLIB:", defaultLibs, it, end ) )
   {
    continue;
   }


   if ( GetOtherLibsArg( "/LIBPATH:", libPaths, it, end, true ) )
   {
    continue;
   }


   if ( token.BeginsWith( '/' ) )
   {
    continue;
   }
  }


  if ( !msvc )
  {
# 428 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/BFF/Functions/FunctionExecutable.cpp"
   if ( GetOtherLibsArg( "-L", libPaths, it, end ) )
   {
    continue;
   }


   if ( GetOtherLibsArg( "-l", dashlLibs, it, end ) )
   {
    continue;
   }


   if ( token.BeginsWith( '-' ) )
   {
    continue;
   }
  }


  if ( token.BeginsWith( '%' ) ||
    token.BeginsWith( "'%" ) ||
    token.BeginsWith( "\"%" ) )
  {
   continue;
  }


  AStackString<> libName;
  Args::StripQuotes( token.Get(), token.GetEnd(), libName );
  if ( token.IsEmpty() == false )
  {
   libs.Append( libName );
  }
 }


 if ( ignoreAllDefaultLibs )
 {

  defaultLibs.Clear();
 }
 else
 {

  const AString * const endI = defaultLibsToIgnore.End();
  for ( const AString * itI = defaultLibsToIgnore.Begin(); itI != endI; ++itI )
  {
   const AString * const endD = defaultLibs.End();
   for ( AString * itD = defaultLibs.Begin(); itD != endD; ++itD )
   {
    if ( itI->CompareI( *itD ) == 0 )
    {
     defaultLibs.Erase( itD );
     break;
    }
   }
  }
 }

 if ( !msvc )
 {

  const AString * const endDL = dashlLibs.End();
  for ( const AString * itDL = dashlLibs.Begin(); itDL != endDL; ++itDL )
  {
   AStackString<> libName;
   libName += "lib";
   libName += *itDL;
   libName += ".a";
   libs.Append( libName );
  }
 }


 libs.Append( defaultLibs );


 libPaths.Append( envLibPaths );


 const AString * const endL = libs.End();
 for ( const AString * itL = libs.Begin(); itL != endL; ++itL )
 {
  bool found = false;


  if ( ( itL->GetLength() > 2 ) && ( (*itL)[ 1 ] == ':' ) )
  {

   if ( !GetOtherLibrary( iter, otherLibraries, AString::GetEmpty(), *itL, found ) )
   {
    return false;
   }
  }
  else
  {

   const AString * const endP = libPaths.End();
   for ( const AString * itP = libPaths.Begin(); itP != endP; ++itP )
   {
    if ( !GetOtherLibrary( iter, otherLibraries, *itP, *itL, found ) )
    {
     return false;
    }

    if ( found )
    {
     break;
    }


   }
  }
# 552 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/BFF/Functions/FunctionExecutable.cpp"
 }

 return true;
}



bool FunctionExecutable::GetOtherLibrary( const BFFIterator & iter, Dependencies & libs, const AString & path, const AString & lib, bool & found ) const
{
 found = false;

 AStackString<> potentialNodeName( path );
 if ( !potentialNodeName.IsEmpty() )
 {
  PathUtils::EnsureTrailingSlash( potentialNodeName );
 }
 potentialNodeName += lib;
 AStackString<> potentialNodeNameClean;
 NodeGraph::CleanPath( potentialNodeName, potentialNodeNameClean );


 NodeGraph & ng = FBuild::Get().GetDependencyGraph();
 Node * node = ng.FindNode( potentialNodeNameClean );
 if ( node )
 {

  if ( node->IsAFile() == false )
  {
   Error::Error_1103_NotAFile( iter, this, ".LinkerOptions", potentialNodeNameClean, node->GetType() );
   return false;
  }


  libs.Append( Dependency( node ) );
  found = true;
  return true;
 }


 if ( FileIO::FileExists( potentialNodeNameClean.Get() ) )
 {
  node = ng.CreateFileNode( potentialNodeNameClean );
  libs.Append( Dependency( node ) );
  found = true;
  do { if ( FLog::ShowInfo() ) { FLog::Info( "Additional library '%s' assumed to be '%s'\n", lib.Get(), potentialNodeNameClean.Get() ); } } while ( false ); ;
  return true;
 }

 return true;
}



           bool FunctionExecutable::GetOtherLibsArg( const char * arg,
              Array< AString > & list,
              const AString * & it,
              const AString * const & end,
              bool canonicalizePath )
{

 if ( it->BeginsWith( arg ) == false )
 {
  return false;
 }


 const char * valueStart = it->Get() + AString::StrLen( arg );
 const char * valueEnd = it->GetEnd();


 if ( valueStart == valueEnd )
 {
  ++it;


  if ( it == end )
  {

   return true;
  }


  valueStart = it->Get();
  valueEnd = it->GetEnd();
 }


 AStackString<> value;
 Args::StripQuotes( valueStart, valueEnd, value );


 if ( value.IsEmpty() == false )
 {
  if ( canonicalizePath )
  {
   AStackString<> cleanValue;
   NodeGraph::CleanPath( value, cleanValue );
   PathUtils::EnsureTrailingSlash( cleanValue );
   list.Append( cleanValue );
  }
  else
  {
   list.Append( value );
  }
 }

 return true;
}
# 122 "/home/ffulin/p4/tmp/Unity/Tools/FBuild/FBuildCore/Unity1.cpp" 2


# 1 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/BFF/Functions/Function.cpp" 1





# 1 "./Tools/FBuild/FBuildCore/PrecompiledHeader.h" 1
# 7 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/BFF/Functions/Function.cpp" 2
# 15 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/BFF/Functions/Function.cpp"
# 1 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/BFF/Functions/FunctionExec.h" 1


       
# 13 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/BFF/Functions/FunctionExec.h"
class FunctionExec : public Function
{
public:
 explicit FunctionExec();
 inline virtual ~FunctionExec() {}

protected:
 virtual bool AcceptsHeader() const;
 virtual bool Commit( const BFFIterator & funcStartIter ) const;
};
# 16 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/BFF/Functions/Function.cpp" 2
# 46 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/BFF/Functions/Function.cpp"
           Function * Function::s_FirstFunction = (0);



Function::Function( const char * name )
: m_NextFunction( (0) )
, m_Name( name )
, m_Seen( false )
, m_AliasForFunction( 256 )
{
 if ( s_FirstFunction == (0) )
 {
  s_FirstFunction = this;
  return;
 }
 Function * func = s_FirstFunction;
 while ( func )
 {
  if ( func->m_NextFunction == (0) )
  {
   func->m_NextFunction = this;
   return;
  }
  func = func->m_NextFunction;
 }
}



Function::~Function()
{
}



           const Function * Function::Find( const AString & name )
{
 Function * func = s_FirstFunction;
 while ( func )
 {
  if ( func->GetName() == name )
  {
   return func;
  }
  func = func->m_NextFunction;
 }
 return (0);
}



           void Function::Create()
{
 new ( "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/BFF/Functions/Function.cpp", 99 ) FunctionAlias;
 new ( "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/BFF/Functions/Function.cpp", 100 ) FunctionCompiler;
 new ( "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/BFF/Functions/Function.cpp", 101 ) FunctionCopy;
 new ( "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/BFF/Functions/Function.cpp", 102 ) FunctionCopyDir;
 new ( "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/BFF/Functions/Function.cpp", 103 ) FunctionCSAssembly;
 new ( "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/BFF/Functions/Function.cpp", 104 ) FunctionDLL;
 new ( "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/BFF/Functions/Function.cpp", 105 ) FunctionExec;
 new ( "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/BFF/Functions/Function.cpp", 106 ) FunctionExecutable;
 new ( "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/BFF/Functions/Function.cpp", 107 ) FunctionForEach;
 new ( "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/BFF/Functions/Function.cpp", 108 ) FunctionLibrary;
 new ( "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/BFF/Functions/Function.cpp", 109 ) FunctionPrint;
 new ( "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/BFF/Functions/Function.cpp", 110 ) FunctionSettings;
 new ( "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/BFF/Functions/Function.cpp", 111 ) FunctionTest;
 new ( "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/BFF/Functions/Function.cpp", 112 ) FunctionUnity;
 new ( "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/BFF/Functions/Function.cpp", 113 ) FunctionUsing;
 new ( "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/BFF/Functions/Function.cpp", 114 ) FunctionVCXProject;
 new ( "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/BFF/Functions/Function.cpp", 115 ) FunctionObjectList;
}



           void Function::Destroy()
{
 Function * func = s_FirstFunction;
 while ( func )
 {
  Function * nextFunc = func->m_NextFunction;
  delete func;
  func = nextFunc;
 }
 s_FirstFunction = (0);
}



            bool Function::AcceptsHeader() const
{
 return false;
}



            bool Function::NeedsHeader() const
{
 return false;
}



            bool Function::NeedsBody() const
{
 return true;
}



            bool Function::IsUnique() const
{
 return false;
}



            bool Function::ParseFunction( const BFFIterator & functionNameStart,
            const BFFIterator * functionBodyStartToken,
            const BFFIterator * functionBodyStopToken,
            const BFFIterator * functionHeaderStartToken,
            const BFFIterator * functionHeaderStopToken ) const
{
 m_AliasForFunction.Clear();
 if ( AcceptsHeader() &&
   functionHeaderStartToken && functionHeaderStopToken &&
   ( functionHeaderStartToken->GetDistTo( *functionHeaderStopToken ) > 1 ) )
 {

  BFFIterator start( *functionHeaderStartToken );
  do { if ( !( *start == BFFParser::BFF_FUNCTION_ARGS_OPEN ) ) { if ( AssertHandler::Failure( "*start == BFFParser::BFF_FUNCTION_ARGS_OPEN", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/BFF/Functions/Function.cpp", 175 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;
  start++;
  start.SkipWhiteSpace();
  const char c = *start;
  if ( ( c != '"' ) && ( c != '\'' ) )
  {
   Error::Error_1001_MissingStringStartToken( start, this );
   return false;
  }
  BFFIterator stop( start );
  stop.SkipString( c );
  do { if ( !( stop.GetCurrent() <= functionHeaderStopToken->GetCurrent() ) ) { if ( AssertHandler::Failure( "stop.GetCurrent() <= functionHeaderStopToken->GetCurrent()", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/BFF/Functions/Function.cpp", 186 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;
  if ( start.GetDistTo( stop ) <= 1 )
  {
   Error::Error_1003_EmptyStringNotAllowedInHeader( start, this );
   return false;
  }


  start++;
  if ( BFFParser::PerformVariableSubstitutions( start, stop, m_AliasForFunction ) == false )
  {
   return false;
  }
 }


 BFFParser subParser;
 BFFIterator subIter( *functionBodyStartToken );
 subIter++;
 subIter.SetMax( functionBodyStopToken->GetCurrent() );
 if ( subParser.Parse( subIter ) == false )
 {
  return false;
 }


 return Commit( functionNameStart );
}



            bool Function::Commit( const BFFIterator & funcStartIter ) const
{
 (void)funcStartIter;
 return true;
}



bool Function::GetString( const BFFIterator & iter, const BFFVariable * & var, const char * name, bool required ) const
{
 do { if ( !( name ) ) { if ( AssertHandler::Failure( "name", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/BFF/Functions/Function.cpp", 227 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;
 var = (0);

 const BFFVariable * v = BFFStackFrame::GetVar( name );

 if ( v == (0) )
 {
  if ( required )
  {
   Error::Error_1101_MissingProperty( iter, this, AStackString<>( name ) );
   return false;
  }
  return true;
 }

 if ( v->IsString() == false )
 {
  Error::Error_1050_PropertyMustBeOfType( iter, this, name, v->GetType(), BFFVariable::VAR_STRING );
  return false;
 }
 if ( v->GetString().IsEmpty() )
 {
  Error::Error_1004_EmptyStringPropertyNotAllowed( iter, this, name );
  return false;
 }

 var = v;
 return true;
}



bool Function::GetString( const BFFIterator & iter, AString & var, const char * name, bool required ) const
{
 const BFFVariable * stringVar;
 if ( !GetString( iter, stringVar, name, required ) )
 {
  return false;
 }
 if ( stringVar )
 {
  var = stringVar->GetString();
 }
 else
 {
  var.Clear();
 }
 return true;
}



bool Function::GetStringOrArrayOfStrings( const BFFIterator & iter, const BFFVariable * & var, const char * name, bool required ) const
{
 do { if ( !( name ) ) { if ( AssertHandler::Failure( "name", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/BFF/Functions/Function.cpp", 281 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;
 var = (0);

 const BFFVariable * v = BFFStackFrame::GetVar( name );

 if ( v == (0) )
 {
  if ( required )
  {
   Error::Error_1101_MissingProperty( iter, this, AStackString<>( name ) );
   return false;
  }
  return true;
 }



 Array< AString > paths;
 if ( v->IsString() || v->IsArrayOfStrings() )
 {
  var = v;
  return true;
 }

 Error::Error_1050_PropertyMustBeOfType( iter, this, name, v->GetType(), BFFVariable::VAR_STRING, BFFVariable::VAR_ARRAY_OF_STRINGS );
 return false;
}



bool Function::GetBool( const BFFIterator & iter, bool & var, const char * name, bool defaultValue, bool required ) const
{
 do { if ( !( name ) ) { if ( AssertHandler::Failure( "name", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/BFF/Functions/Function.cpp", 313 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;

 const BFFVariable * v = BFFStackFrame::GetVar( name );
 if ( v == (0) )
 {
  if ( required )
  {
   Error::Error_1101_MissingProperty( iter, this, AStackString<>( name ) );
   return false;
  }
  var = defaultValue;
  return true;
 }

 if ( v->IsBool() == false )
 {
  Error::Error_1050_PropertyMustBeOfType( iter, this, name, v->GetType(), BFFVariable::VAR_BOOL );
  return false;
 }

 var = v->GetBool();
 return true;
}



bool Function::GetInt( const BFFIterator & iter, int32_t & var, const char * name, int32_t defaultValue, bool required ) const
{
 do { if ( !( name ) ) { if ( AssertHandler::Failure( "name", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/BFF/Functions/Function.cpp", 341 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;

 const BFFVariable * v = BFFStackFrame::GetVar( name );
 if ( v == (0) )
 {
  if ( required )
  {
   Error::Error_1101_MissingProperty( iter, this, AStackString<>( name ) );
   return false;
  }
  var = defaultValue;
  return true;
 }

 if ( v->IsInt() == false )
 {
  Error::Error_1050_PropertyMustBeOfType( iter, this, name, v->GetType(), BFFVariable::VAR_INT );
  return false;
 }

 var = v->GetInt();
 return true;
}




bool Function::GetInt( const BFFIterator & iter, int32_t & var, const char * name, int32_t defaultValue, bool required, int minVal, int maxVal ) const
{
 if ( GetInt( iter, var, name, defaultValue, required ) == false )
 {
  return false;
 }


 if ( ( var < minVal ) || ( var > maxVal ) )
 {
  Error::Error_1054_IntegerOutOfRange( iter, this, name, minVal, maxVal );
  return false;
 }
 return true;
}



bool Function::GetNodeList( const BFFIterator & iter, const char * name, Dependencies & nodes, bool required,
       bool allowCopyDirNodes, bool allowUnityNodes ) const
{
 do { if ( !( name ) ) { if ( AssertHandler::Failure( "name", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/BFF/Functions/Function.cpp", 389 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;

 const BFFVariable * var = BFFStackFrame::GetVar( name );
 if ( !var )
 {

  if ( required )
  {
   Error::Error_1101_MissingProperty( iter, this, AStackString<>( name ) );
   return false;
  }
  return true;
 }

 if ( var->IsArrayOfStrings() )
 {

  const Array< AString > & nodeNames = var->GetArrayOfStrings();
  nodes.SetCapacity( nodes.GetSize() + nodeNames.GetSize() );
  for ( Array< AString >::Iter it = nodeNames.Begin();
    it != nodeNames.End();
    it++ )
  {
   if ( it->IsEmpty() )
   {
    Error::Error_1004_EmptyStringPropertyNotAllowed( iter, this, name );
    return false;
   }

   if ( !GetNodeListRecurse( iter, name, nodes, *it, allowCopyDirNodes, allowUnityNodes ) )
   {

    return false;
   }
  }
 }
 else if ( var->IsString() )
 {
  if ( var->GetString().IsEmpty() )
  {
   Error::Error_1004_EmptyStringPropertyNotAllowed( iter, this, name );
   return false;
  }

  if ( !GetNodeListRecurse( iter, name, nodes, var->GetString(), allowCopyDirNodes, allowUnityNodes ) )
  {

   return false;
  }
 }
 else
 {

  Error::Error_1050_PropertyMustBeOfType( iter, this, name, var->GetType(), BFFVariable::VAR_STRING, BFFVariable::VAR_ARRAY_OF_STRINGS );
  return false;
 }

 return true;
}



bool Function::GetDirectoryListNodeList( const BFFIterator & iter,
           const Array< AString > & paths,
           const Array< AString > & excludePaths,
           bool recurse,
           const AString & pattern,
           const char * inputVarName,
           Dependencies & nodes ) const
{
 NodeGraph & ng = FBuild::Get().GetDependencyGraph();

 const AString * const end = paths.End();
 for ( const AString * it = paths.Begin(); it != end; ++it )
 {
  const AString & path = *it;


  AStackString<> name;
  DirectoryListNode::FormatName( path, pattern, recurse, excludePaths, name );
  Node * node = ng.FindNode( name );
  if ( node == (0) )
  {
   node = ng.CreateDirectoryListNode( name,
              path,
              pattern,
              recurse,
              excludePaths );
  }
  else if ( node->GetType() != Node::DIRECTORY_LIST_NODE )
  {
   Error::Error_1102_UnexpectedType( iter, this, inputVarName, node->GetName(), node->GetType(), Node::DIRECTORY_LIST_NODE );
   return false;
  }

  nodes.Append( Dependency( node ) );
 }
 return true;
}



bool Function::GetNodeListRecurse( const BFFIterator & iter, const char * name, Dependencies & nodes, const AString & nodeName,
           bool allowCopyDirNodes, bool allowUnityNodes ) const
{
 NodeGraph & ng = FBuild::Get().GetDependencyGraph();


 Node * n = ng.FindNode( nodeName );
 if ( n == (0) )
 {

  n = ng.CreateFileNode( nodeName );
  nodes.Append( Dependency( n ) );
  return true;
 }


 if ( n->IsAFile() )
 {

  nodes.Append( Dependency( n ) );
  return true;
 }


 if ( n->GetType() == Node::OBJECT_LIST_NODE )
 {

  nodes.Append( Dependency( n ) );
  return true;
 }


 if ( allowCopyDirNodes )
 {

  if ( n->GetType() == Node::COPY_DIR_NODE )
  {

   nodes.Append( Dependency( n ) );
   return true;
  }
 }
 if ( allowUnityNodes )
 {

  if ( n->GetType() == Node::UNITY_NODE )
  {

   nodes.Append( Dependency( n ) );
   return true;
  }
 }


 if ( n->GetType() == Node::ALIAS_NODE )
 {
  AliasNode * an = n->CastTo< AliasNode >();
  const Dependencies & aNodes = an->GetAliasedNodes();
  for ( const Dependency * it = aNodes.Begin(); it != aNodes.End(); ++it )
  {

   const AString & subName = it->GetNode()->GetName();

   if ( !GetNodeListRecurse( iter, name, nodes, subName, allowCopyDirNodes, allowUnityNodes ) )
   {
    return false;
   }
  }
  return true;
 }


 Error::Error_1005_UnsupportedNodeType( iter, this, name, n->GetName(), n->GetType() );
 return false;
}



bool Function::GetStrings( const BFFIterator & iter, Array< AString > & strings, const char * name, bool required ) const
{
 const BFFVariable * var;
 if ( !GetStringOrArrayOfStrings( iter, var, name, required ) )
 {
  return false;
 }
 if ( !var )
 {
  do { if ( !( !required ) ) { if ( AssertHandler::Failure( "!required", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/BFF/Functions/Function.cpp", 578 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;
  return true;
 }

 if ( var->GetType() == BFFVariable::VAR_STRING )
 {
  strings.Append( var->GetString() );
 }
 else if ( var->GetType() == BFFVariable::VAR_ARRAY_OF_STRINGS )
 {
  const Array< AString > & vStrings = var->GetArrayOfStrings();
  strings.Append( vStrings );
 }
 else
 {
  do { if ( !( false ) ) { if ( AssertHandler::Failure( "false", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/BFF/Functions/Function.cpp", 593 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;
 }
 return true;
}



bool Function::GetFolderPaths(const BFFIterator & iter, Array< AString > & paths, const char * name, bool required) const
{
 if ( !GetStrings(iter, paths, name, required ) )
 {
  return false;
 }
 CleanFolderPaths( paths );
 return true;
}



bool Function::GetFileNode( const BFFIterator & iter, Node * & fileNode, const char * name, bool required ) const
{

 AStackString<> fileNodeName;
 if ( GetString( iter, fileNodeName, name, required ) == false )
 {
  return false;
 }


 if ( fileNodeName.IsEmpty() )
 {
  do { if ( !( required == false ) ) { if ( AssertHandler::Failure( "required == false", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/BFF/Functions/Function.cpp", 624 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;
  fileNode = (0);
  return true;
 }


 NodeGraph & ng = FBuild::Get().GetDependencyGraph();
 Node * n = ng.FindNode( fileNodeName );
 if ( n == (0) )
 {
  n = ng.CreateFileNode( fileNodeName );
 }
 else if ( n->IsAFile() == false )
 {
  Error::Error_1103_NotAFile( iter, this, name, n->GetName(), n->GetType() );
  return false;
 }
 fileNode = n;
 return true;
}



void Function::CleanFolderPaths( Array< AString > & folders ) const
{
 AStackString< 512 > tmp;

 AString * const end = folders.End();
 for ( AString * it = folders.Begin(); it != end; ++it )
 {

  NodeGraph::CleanPath( *it, tmp );


  PathUtils::EnsureTrailingSlash( tmp );


  *it = tmp;
 }
}


void Function::CleanFilePaths( Array< AString > & files ) const
{
 AStackString< 512 > tmp;

 AString * const end = files.End();
 for ( AString * it = files.Begin(); it != end; ++it )
 {

  NodeGraph::CleanPath( *it, tmp );


  *it = tmp;
 }
}



bool Function::ProcessAlias( const BFFIterator & iter, Node * nodeToAlias ) const
{
 Dependencies nodesToAlias( 1, false );
 nodesToAlias.Append( Dependency( nodeToAlias ) );
 return ProcessAlias( iter, nodesToAlias );
}



bool Function::ProcessAlias( const BFFIterator & iter, Dependencies & nodesToAlias ) const
{
 if ( m_AliasForFunction.IsEmpty() )
 {
  return true;
 }


 NodeGraph & ng = FBuild::Get().GetDependencyGraph();
 if ( ng.FindNode( m_AliasForFunction ) )
 {
  Error::Error_1100_AlreadyDefined( iter, this, m_AliasForFunction );
  return false;
 }


 do { if ( !( ng.CreateAliasNode( m_AliasForFunction, nodesToAlias ) ) ) { if ( AssertHandler::Failure( "ng.CreateAliasNode( m_AliasForFunction, nodesToAlias )", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/BFF/Functions/Function.cpp", 708 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;


 m_AliasForFunction.Clear();

 return true;
}
# 125 "/home/ffulin/p4/tmp/Unity/Tools/FBuild/FBuildCore/Unity1.cpp" 2


# 1 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/BFF/Functions/FunctionExec.cpp" 1





# 1 "./Tools/FBuild/FBuildCore/PrecompiledHeader.h" 1
# 7 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/BFF/Functions/FunctionExec.cpp" 2
# 16 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/BFF/Functions/FunctionExec.cpp"
FunctionExec::FunctionExec()
: Function( "Exec" )
{
}



            bool FunctionExec::AcceptsHeader() const
{
 return true;
}



            bool FunctionExec::Commit( const BFFIterator & funcStartIter ) const
{

 const BFFVariable * outputV;
 const BFFVariable * executableV;
 const BFFVariable * inputV;
 const BFFVariable * argsV;
 const BFFVariable * workingDirV;
 int32_t expectedReturnCode;
 if ( !GetString( funcStartIter, outputV, ".ExecOutput", true ) ||
   !GetString( funcStartIter, executableV, ".ExecExecutable", true ) ||
   !GetString( funcStartIter, inputV, ".ExecInput", true ) ||
   !GetString( funcStartIter, argsV, ".ExecArguments" ) ||
   !GetString( funcStartIter, workingDirV, ".ExecWorkingDir" ) ||
   !GetInt( funcStartIter, expectedReturnCode, ".ExecReturnCode", 0, false ) )
 {
  return false;
 }


 NodeGraph & ng = FBuild::Get().GetDependencyGraph();
 if ( ng.FindNode( outputV->GetString() ) != (0) )
 {
  Error::Error_1100_AlreadyDefined( funcStartIter, this, outputV->GetString() );
  return false;
 }


 Dependencies preBuildDependencies;
 if ( !GetNodeList( funcStartIter, ".PreBuildDependencies", preBuildDependencies, false ) )
 {
  return false;
 }


 Node * exeNode = ng.FindNode( executableV->GetString() );
 if ( exeNode == (0) )
 {
  exeNode = ng.CreateFileNode( executableV->GetString() );
 }
 else if ( exeNode->IsAFile() == false )
 {
  Error::Error_1103_NotAFile( funcStartIter, this, "ExecExecutable", exeNode->GetName(), exeNode->GetType() );
  return false;
 }


 Node * inputNode = ng.FindNode( inputV->GetString() );
 if ( inputNode == (0) )
 {
  inputNode = ng.CreateFileNode( inputV->GetString() );
 }
 else if ( inputNode->IsAFile() == false )
 {
  Error::Error_1103_NotAFile( funcStartIter, this, "ExecInput", exeNode->GetName(), exeNode->GetType() );
  return false;
 }


 const AString & arguments( argsV ? argsV->GetString() : AString::GetEmpty() );
 const AString & workingDir( workingDirV ? workingDirV->GetString(): AString::GetEmpty() );


 Node * outputNode = ng.CreateExecNode( outputV->GetString(),
             (FileNode *)inputNode,
             (FileNode *)exeNode,
             arguments,
             workingDir,
             expectedReturnCode,
             preBuildDependencies );

 return ProcessAlias( funcStartIter, outputNode );
}
# 128 "/home/ffulin/p4/tmp/Unity/Tools/FBuild/FBuildCore/Unity1.cpp" 2


# 1 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/FBuild.cpp" 1





# 1 "./Tools/FBuild/FBuildCore/PrecompiledHeader.h" 1
# 7 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/FBuild.cpp" 2






# 1 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Cache/ICache.h" 1


       





class AString;



class ICache
{
public:
 inline virtual ~ICache() {}

 virtual bool Init( const AString & cachePath ) = 0;
 virtual void Shutdown() = 0;
 virtual bool Publish( const AString & cacheId, const void * data, size_t dataSize ) = 0;
 virtual bool Retrieve( const AString & cacheId, void * & data, size_t & dataSize ) = 0;
 virtual void FreeMemory( void * data, size_t dataSize ) = 0;
};
# 14 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/FBuild.cpp" 2
# 1 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Cache/Cache.h" 1


       
# 14 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Cache/Cache.h"
class Cache : public ICache
{
public:
 explicit Cache();
 virtual ~Cache();

 virtual bool Init( const AString & cachePath );
 virtual void Shutdown();
 virtual bool Publish( const AString & cacheId, const void * data, size_t dataSize );
 virtual bool Retrieve( const AString & cacheId, void * & data, size_t & dataSize );
 virtual void FreeMemory( void * data, size_t dataSize );
private:
 void GetCacheFileName( const AString & cacheId, AString & path ) const;

 AString m_CachePath;
};
# 15 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/FBuild.cpp" 2
# 1 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Cache/CachePlugin.h" 1


       






# 1 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Cache/CachePluginInterface.h" 1


       
# 19 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Cache/CachePluginInterface.h"
typedef bool (*CacheInitFunc)( const char * cachePath );







typedef void (*CacheShutdownFunc)();
# 40 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Cache/CachePluginInterface.h"
typedef bool (*CachePublishFunc)( const char * cacheId, const void * data, unsigned long long dataSize );
# 52 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Cache/CachePluginInterface.h"
typedef bool (*CacheRetrieveFunc)( const char * cacheId, void * & data, unsigned long long & dataSize );
# 63 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Cache/CachePluginInterface.h"
typedef void (*CacheFreeMemoryFunc)( void * data, unsigned long long dataSize );
# 11 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Cache/CachePlugin.h" 2



class AString;



class CachePlugin : public ICache
{
public:
 explicit CachePlugin( const AString & dllName );
 virtual ~CachePlugin();

 virtual bool Init( const AString & cachePath );
 virtual void Shutdown();
 virtual bool Publish( const AString & cacheId, const void * data, size_t dataSize );
 virtual bool Retrieve( const AString & cacheId, void * & data, size_t & dataSize );
 virtual void FreeMemory( void * data, size_t dataSize );
private:
 void * GetFunction( const char * friendlyName, const char * mangledName ) const;




 CacheInitFunc m_InitFunc;
 CacheShutdownFunc m_ShutdownFunc;
 CachePublishFunc m_PublishFunc;
 CacheRetrieveFunc m_RetrieveFunc;
 CacheFreeMemoryFunc m_FreeMemoryFunc;
};
# 16 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/FBuild.cpp" 2


# 1 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/NodeProxy.h" 1


       
# 13 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/NodeProxy.h"
class NodeProxy : public Node
{
public:
 explicit NodeProxy( const AString & name );
 virtual ~NodeProxy();

 virtual bool IsAFile() const;

protected:
 virtual void Save( IOStream & stream ) const;
 virtual bool DetermineNeedToBuild( bool forceClean ) const;
};
# 19 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/FBuild.cpp" 2
# 31 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/FBuild.cpp"
# 1 "./Core/Process/SystemMutex.h" 1


       
# 13 "./Core/Process/SystemMutex.h"
class SystemMutex
{
public:
 SystemMutex( const char * );
 ~SystemMutex();

 bool TryLock();
    bool IsLocked() const;
 void Unlock();

private:



        int m_Handle;

 AString m_Name;
};
# 32 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/FBuild.cpp" 2
# 46 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/FBuild.cpp"
           bool FBuild::s_StopBuild( false );



FBuild::FBuild( const FBuildOptions & options )
 : m_Client( (0) )
 , m_Cache( (0) )
 , m_LastProgressOutputTime( 0.0f )
 , m_LastProgressCalcTime( 0.0f )
 , m_SmoothedProgressCurrent( 0.0f )
 , m_SmoothedProgressTarget( 0.0f )
 , m_WorkerList( 0, true )
 , m_EnvironmentString( (0) )
 , m_EnvironmentStringSize( 0 )
{







 m_DependencyGraph = new ( "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/FBuild.cpp", 68 ) NodeGraph();


 m_Options = options;


 do { if ( !( FileIO::GetCurrentDir( m_OldWorkingDir ) ) ) { if ( AssertHandler::Failure( "FileIO::GetCurrentDir( m_OldWorkingDir )", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/FBuild.cpp", 74 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;


 AStackString<> cachePath;
 if ( Env::GetEnvVariable( "FASTBUILD_CACHE_PATH", cachePath ) )
 {
  if ( cachePath.IsEmpty() == false )
  {
   SetCachePath( cachePath );
  }
 }


 FLog::SetShowInfo( m_Options.m_ShowInfo );
 FLog::SetShowErrors( m_Options.m_ShowErrors );
 FLog::SetShowProgress( m_Options.m_ShowProgress );

 Function::Create();
}



FBuild::~FBuild()
{
 Function::Destroy();

 delete m_DependencyGraph;
 delete m_Client;
 ::Free( m_EnvironmentString );

 if ( m_Cache )
 {
  m_Cache->Shutdown();
  delete m_Cache;
 }


 do { if ( !( !m_OldWorkingDir.IsEmpty() ) ) { if ( AssertHandler::Failure( "!m_OldWorkingDir.IsEmpty()", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/FBuild.cpp", 111 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;
 if ( !FileIO::SetCurrentDir( m_OldWorkingDir ) )
 {
  do { FLog::Error( "Failed to restore working dir: '%s' (error: %u)", m_OldWorkingDir.Get(), Env::GetLastErr() ); } while ( false ); ;
 }
}



bool FBuild::Initialize( const char * nodeGraphDBFile )
{

 if ( !FileIO::SetCurrentDir( m_Options.GetWorkingDir() ) )
 {
  do { FLog::Error( "Failed to set working dir: '%s' (error: %u)", m_Options.GetWorkingDir().Get(), Env::GetLastErr() ); } while ( false ); ;
  return false;
 }

 const char * bffFile = m_Options.m_ConfigFile.IsEmpty() ? GetDefaultBFFFileName()
                  : m_Options.m_ConfigFile.Get();
 if ( m_DependencyGraph->Initialize( bffFile, nodeGraphDBFile ) == false )
 {
  return false;
 }


 if ( m_Options.m_UseCacheRead || m_Options.m_UseCacheWrite )
 {
  if ( !m_CachePluginDLL.IsEmpty() )
  {
   m_Cache = new ( "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/FBuild.cpp", 141 ) CachePlugin( m_CachePluginDLL );
  }
  else
  {
   m_Cache = new ( "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/FBuild.cpp", 145 ) Cache();
  }

  if ( m_Cache->Init( m_CachePath ) == false )
  {
   m_Options.m_UseCacheRead = false;
   m_Options.m_UseCacheWrite = false;
  }
 }



 if ( m_Options.m_AllowDistributed )
 {
  Array< AString > workers;
  if ( m_WorkerList.IsEmpty() )
  {


   m_WorkerBrokerage.FindWorkers( workers );
  }
  else
  {
   workers = m_WorkerList;
  }

  if ( workers.IsEmpty() )
  {
   do { FLog::Warning( "No workers available - Distributed compilation disabled" ); } while ( false ); ;
   m_Options.m_AllowDistributed = false;
  }
  else
  {
   Tracing::OutputFormat( "Distributed Compilation : %u Workers in pool\n", workers.GetSize() );
   m_Client = new ( "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/FBuild.cpp", 179 ) Client( workers );
  }
 }

 return true;
}



bool FBuild::Build( const AString & target )
{
 do { if ( !( !target.IsEmpty() ) ) { if ( AssertHandler::Failure( "!target.IsEmpty()", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/FBuild.cpp", 190 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;

 Array< AString > targets( 1, false );
 targets.Append( target );
 return Build( targets );
}



bool FBuild::Build( const Array< AString > & targets )
{
 ProfileHelper ph201( __FUNCTION__ );

 do { if ( !( !targets.IsEmpty() ) ) { if ( AssertHandler::Failure( "!targets.IsEmpty()", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/FBuild.cpp", 203 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;


 const size_t numTargets = targets.GetSize();
 Dependencies nodes( numTargets, 0 );
 for ( size_t i=0; i<numTargets; ++i )
 {
  const AString & target = targets[ i ];


  Node * node = m_DependencyGraph->FindNodeInternal( target );
  if ( node == (0) )
  {

   node = m_DependencyGraph->FindNode( target );
  }

  if ( node == (0) )
  {
   do { FLog::Error( "Unknown build target '%s'", target.Get() ); } while ( false ); ;
   return false;
  }
  nodes.Append( Dependency( node ) );
 }


 NodeProxy proxy( AStackString< 32 >( "*proxy*" ) );
 proxy.m_StaticDependencies = nodes;


 bool result = Build( &proxy );


 for ( size_t i=0; i<targets.GetSize(); ++i )
 {
  bool nodeResult = ( nodes[ i ].GetNode()->GetState() == Node::UP_TO_DATE );
  Tracing::OutputFormat( "FBuild: %s: %s\n", nodeResult ? "OK" : "Error: BUILD FAILED", targets[ i ].Get() );
 }

 return result;
}



bool FBuild::SaveDependencyGraph( const char * nodeGraphDBFile ) const
{
 nodeGraphDBFile = nodeGraphDBFile ? nodeGraphDBFile : GetDependencyGraphFileName();

 do { if ( FLog::ShowInfo() ) { FLog::Info( "Saving DepGraph '%s'", nodeGraphDBFile ); } } while ( false ); ;

 Timer t;


 MemoryStream memoryStream( 32 * 1024 * 1024, 8 * 1024 * 1024 );
 m_DependencyGraph->Save( memoryStream );


 AStackString<> tmpFileName( nodeGraphDBFile );
 tmpFileName += ".tmp";


 FileStream fileStream;
 if ( fileStream.Open( tmpFileName.Get(), FileStream::WRITE_ONLY ) == false )
 {

  do { FLog::Error( "Failed to open DepGraph for saving '%s'", nodeGraphDBFile ); } while ( false ); ;
  return false;
 }


 if ( fileStream.Write( memoryStream.GetData(), memoryStream.GetSize() ) != memoryStream.GetSize() )
 {
  do { FLog::Error( "Saving DepGraph FAILED!" ); } while ( false ); ;
  return false;
 }
 fileStream.Close();


 if ( FileIO::FileMove( tmpFileName, AStackString<>( nodeGraphDBFile ) ) == false )
 {
  do { FLog::Error( "Failed to rename temp DB file '%s' (%i)", tmpFileName.Get(), Env::GetLastErr() ); } while ( false ); ;
  return false;
 }

 do { if ( FLog::ShowInfo() ) { FLog::Info( "Saving DepGraph Complete in %2.3fs", t.GetElapsed() ); } } while ( false ); ;
 return true;
}



bool FBuild::Build( Node * nodeToBuild )
{
 ProfileHelper ph295( __FUNCTION__ );

 do { if ( !( nodeToBuild ) ) { if ( AssertHandler::Failure( "nodeToBuild", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/FBuild.cpp", 297 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;

 s_StopBuild = false;


 m_JobQueue = new ( "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/FBuild.cpp", 302 ) JobQueue( m_Options.m_NumWorkerThreads );

 m_Timer.Start();
 m_LastProgressOutputTime = 0.0f;
 m_LastProgressCalcTime = 0.0f;
 m_SmoothedProgressCurrent = 0.0f;
 m_SmoothedProgressTarget = 0.0f;
 FLog::StartBuild();


 if ( m_Options.m_NumWorkerThreads == 0 )
 {
  WorkerThread::CreateThreadLocalTmpDir();
 }

 bool stopping( false );


 for ( ;; )
 {
  bool complete = ( nodeToBuild->GetState() == Node::UP_TO_DATE ) ||
      ( nodeToBuild->GetState() == Node::FAILED );

  if ( s_StopBuild || complete )
  {
   if ( stopping == false )
   {

    delete m_Client;
    m_Client = (0);




    m_JobQueue->SignalStopWorkers();
    stopping = true;
   }
  }

  if ( !stopping )
  {
   if ( m_Options.m_WrapperChild )
   {
                SystemMutex wrapperMutex( m_Options.GetMainProcessMutexName().Get() );
    if ( wrapperMutex.TryLock() )
    {

     s_StopBuild = true;
    }
   }
  }

  if ( !stopping )
  {

   m_DependencyGraph->DoBuildPass( nodeToBuild );
  }

  if ( m_Options.m_NumWorkerThreads == 0 )
  {

   WorkerThread::Update();
  }


  m_JobQueue->FinalizeCompletedJobs();


  if ( stopping && m_JobQueue->HaveWorkersStopped() )
  {
   break;
  }

  Thread::Sleep( 16 );


  UpdateBuildStatus( nodeToBuild, false );

  ProfileManager::Synchronize();
 }

 delete m_JobQueue;
 m_JobQueue = (0);


 UpdateBuildStatus( nodeToBuild, true );

 FLog::StopBuild();





 if ( m_Options.m_SaveDBOnCompletion )
 {
  SaveDependencyGraph();
 }


 float timeTaken = m_Timer.GetElapsed();
 m_BuildStats.m_TotalBuildTime = timeTaken;

 m_BuildStats.OnBuildStop( nodeToBuild );

 bool buildOK = ( nodeToBuild->GetState() == Node::UP_TO_DATE );


 if ( m_Options.m_ShowBuildTime )
 {
  uint32_t minutes = uint32_t( timeTaken / 60.0f );
  timeTaken -= ( minutes * 60.0f );
  float seconds = timeTaken;
  if ( minutes > 0 )
  {
   do { FLog::Build( "Time: %um %05.3fs\n", minutes, seconds ); } while ( false ); ;
  }
  else
  {
   do { FLog::Build( "Time: %05.3fs\n", seconds ); } while ( false ); ;
  }
 }

 return buildOK;
}



void FBuild::SetEnvironmentString( const char * envString, uint32_t size, const AString & libEnvVar )
{
 ::Free( m_EnvironmentString );
 m_EnvironmentString = (char *)::AllocFileLine( size + 1, "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/FBuild.cpp", 432 );
 m_EnvironmentStringSize = size;
 AString::Copy( envString, m_EnvironmentString, size );
 m_LibEnvVar = libEnvVar;
}



void FBuild::GetLibEnvVar( AString & value ) const
{

 if ( m_EnvironmentString )
 {

  value = m_LibEnvVar;
 }
 else
 {

  Env::GetEnvVariable( "LIB", value );
 }
}



           void FBuild::OnBuildError()
{
 if ( FBuild::Get().GetOptions().m_StopOnFirstError )
 {
  s_StopBuild = true;
 }
}



void FBuild::UpdateBuildStatus( const Node * node, bool forceUpdate )
{
 ProfileHelper ph469( __FUNCTION__ );

 if ( FBuild::Get().GetOptions().m_ShowProgress == false )
 {
  return;
 }

 const float OUTPUT_FREQUENCY( 1.0f );
 const float CALC_FREQUENCY( 5.0f );

 float timeNow = m_Timer.GetElapsed();

 bool doUpdate = ( ( timeNow - m_LastProgressOutputTime ) >= OUTPUT_FREQUENCY );
 doUpdate |= forceUpdate;

 if ( doUpdate == false )
 {
  return;
 }


 if ( ( timeNow - m_LastProgressCalcTime ) >= CALC_FREQUENCY )
 {
  FBuildStats & bs = m_BuildStats;
  bs.m_NodeTimeProgressms = 0;
  bs.m_NodeTimeTotalms = 0;
  m_DependencyGraph->UpdateBuildStatus( node, bs.m_NodeTimeProgressms, bs.m_NodeTimeTotalms );
  m_LastProgressCalcTime = m_Timer.GetElapsed();


  float doneRatio = (float)( (double)bs.m_NodeTimeProgressms / (double)bs.m_NodeTimeTotalms );


  float donePerc = Math::Min< float >( doneRatio * 100.0f, 99.9f );


  m_SmoothedProgressTarget = Math::Max< float >( donePerc, m_SmoothedProgressTarget );
 }

 m_SmoothedProgressCurrent = ( 0.5f * m_SmoothedProgressCurrent ) + ( m_SmoothedProgressTarget * 0.5f );


 uint32_t numJobs = 0;
 uint32_t numJobsActive = 0;
 uint32_t numJobsDist = 0;
 uint32_t numJobsDistActive = 0;
 if ( JobQueue::IsValid() )
 {
  JobQueue::Get().GetJobStats( numJobs, numJobsActive, numJobsDist, numJobsDistActive );
 }

 FLog::OutputProgress( timeNow, m_SmoothedProgressCurrent, numJobs, numJobsActive, numJobsDist, numJobsDistActive );
 m_LastProgressOutputTime = timeNow;
}



           const char * FBuild::GetDependencyGraphFileName()
{
 return "fbuild.fdb";
}



           const char * FBuild::GetDefaultBFFFileName()
{
 return "fbuild.bff";
}



void FBuild::SetCachePath( const AString & path )
{
 m_CachePath = path;
}



void FBuild::GetCacheFileName( uint64_t keyA, uint32_t keyB, uint64_t keyC, AString & path ) const
{

 static const int cacheVersion( 5 );


 path.Format( "%016llX_%08X_%016llX.%u", keyA, keyB, keyC, cacheVersion );
}
# 131 "/home/ffulin/p4/tmp/Unity/Tools/FBuild/FBuildCore/Unity1.cpp" 2


# 1 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/DLLNode.cpp" 1





# 1 "./Tools/FBuild/FBuildCore/PrecompiledHeader.h" 1
# 7 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/DLLNode.cpp" 2
# 18 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/DLLNode.cpp"
DLLNode::DLLNode( const AString & linkerOutputName,
      const Dependencies & inputLibraries,
      const Dependencies & otherLibraries,
      const AString & linker,
      const AString & linkerArgs,
      uint32_t flags,
      const Dependencies & assemblyResources,
      const AString & importLibName,
      Node * linkerStampExe,
      const AString & linkerStampExeArgs )
: LinkerNode( linkerOutputName, inputLibraries, otherLibraries, linker, linkerArgs, flags, assemblyResources, linkerStampExe, linkerStampExeArgs )
, m_ImportLibName( importLibName )
{
 m_Type = DLL_NODE;
}



DLLNode::~DLLNode()
{
}



void DLLNode::GetImportLibName( AString & importLibName ) const
{

 if ( m_ImportLibName.IsEmpty() == false )
 {
  importLibName = m_ImportLibName;
  return;
 }


 const char * lastDot = GetName().FindLast( '.' );
 lastDot = lastDot ? lastDot : GetName().GetEnd();
 importLibName.Assign( GetName().Get(), lastDot );


 importLibName += ".lib";
}



           Node * DLLNode::Load( IOStream & stream )
{

 AStackString<> name; if ( stream.Read( name ) == false ) { return (0); };
 AStackString<> linker; if ( stream.Read( linker ) == false ) { return (0); };
 AStackString<> linkerArgs; if ( stream.Read( linkerArgs ) == false ) { return (0); };
 Dependencies inputLibs( 0, true ); if ( inputLibs.Load( stream ) == false ) { return (0); };
 uint32_t flags; if ( stream.Read( flags ) == false ) { return (0); };
 Dependencies assemblyResources( 0, true ); if ( assemblyResources.Load( stream ) == false ) { return (0); };
 Dependencies otherLibs( 0, true ); if ( otherLibs.Load( stream ) == false ) { return (0); };
    Node * linkerStampExe = (0); if ( Node::LoadNode( stream, linkerStampExe ) == false ) { return (0); };
    AStackString<> linkerStampExeArgs; if ( stream.Read( linkerStampExeArgs ) == false ) { return (0); };


 AStackString<> importLibName; if ( stream.Read( importLibName ) == false ) { return (0); };

 NodeGraph & ng = FBuild::Get().GetDependencyGraph();
 DLLNode * dn = ng.CreateDLLNode( name, inputLibs, otherLibs, linker, linkerArgs, flags, assemblyResources, importLibName, linkerStampExe, linkerStampExeArgs );
 return dn;
}



            void DLLNode::Save( IOStream & stream ) const
{

 LinkerNode::Save( stream );


 stream.Write( m_ImportLibName );;
}
# 134 "/home/ffulin/p4/tmp/Unity/Tools/FBuild/FBuildCore/Unity1.cpp" 2


# 1 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/UnityNode.cpp" 1





# 1 "./Tools/FBuild/FBuildCore/PrecompiledHeader.h" 1
# 7 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/UnityNode.cpp" 2

# 1 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/UnityNode.h" 1


       
# 15 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/UnityNode.h"
class DirectoryListNode;



class UnityNode : public Node
{
public:
 explicit UnityNode( const AString & unityName,
      const Dependencies & dirNodes,
      const Array< AString > & files,
      const AString & outputPath,
      const AString & outputPattern,
      uint32_t numUnityFilesToCreate,
      const AString & precompiledHeader,
      const Array< AString > & pathsToExclude,
      const Array< AString > & filesToExclude,
      bool isolateWritableFiles,
      uint32_t maxIsolatedFiles,
      const Array< AString > & excludePatterns );
 virtual ~UnityNode();

 static inline Node::Type GetType() { return Node::UNITY_NODE; }

 inline const Array< AString > & GetUnityFileNames() const { return m_UnityFileNames; }
 inline const Array< AString > & GetIsolatedFileNames() const { return m_IsolatedFiles; }

 static Node * Load( IOStream & stream );
 virtual void Save( IOStream & stream ) const;
private:
 virtual BuildResult DoBuild( Job * job );

 virtual bool IsAFile() const { return false; }

 void GetFiles( Array< FileIO::FileInfo * > & files );

 Array< AString > m_Files;
 AString m_OutputPath;
 AString m_OutputPattern;
 uint32_t m_NumUnityFilesToCreate;
 Array< AString > m_UnityFileNames;
 AString m_PrecompiledHeader;
 Array< AString > m_PathsToExclude;
 Array< AString > m_FilesToExclude;
 bool m_IsolateWritableFiles;
 uint32_t m_MaxIsolatedFiles;
 Array< AString > m_ExcludePatterns;
 Array< AString > m_IsolatedFiles;

 Array< FileIO::FileInfo > m_FilesInfo;
};
# 9 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/UnityNode.cpp" 2
# 25 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/UnityNode.cpp"
UnityNode::UnityNode( const AString & unityName,
      const Dependencies & dirNodes,
      const Array< AString > & files,
      const AString & outputPath,
      const AString & outputPattern,
      uint32_t numUnityFilesToCreate,
      const AString & precompiledHeader,
      const Array< AString > & pathsToExclude,
      const Array< AString > & filesToExclude,
      bool isolateWritableFiles,
      uint32_t maxIsolatedFiles,
      const Array< AString > & excludePatterns )
: Node( unityName, Node::UNITY_NODE, Node::FLAG_NONE )
, m_Files( files )
, m_OutputPath( outputPath )
, m_OutputPattern( outputPattern )
, m_NumUnityFilesToCreate( numUnityFilesToCreate )
, m_UnityFileNames( numUnityFilesToCreate, false )
, m_PrecompiledHeader( precompiledHeader )
, m_PathsToExclude( pathsToExclude )
, m_FilesToExclude( filesToExclude )
, m_IsolateWritableFiles( isolateWritableFiles )
, m_MaxIsolatedFiles( maxIsolatedFiles )
, m_ExcludePatterns( excludePatterns )
, m_IsolatedFiles( 0, true )
{
 m_LastBuildTimeMs = 100;


 m_StaticDependencies.Append( dirNodes );

 do { if ( !( m_NumUnityFilesToCreate > 0 ) ) { if ( AssertHandler::Failure( "m_NumUnityFilesToCreate > 0", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/UnityNode.cpp", 56 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;


 do { if ( !( m_OutputPath.EndsWith( ( '/' ) ) ) ) { if ( AssertHandler::Failure( "m_OutputPath.EndsWith( NATIVE_SLASH )", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/UnityNode.cpp", 59 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;



 AStackString<> tmp;
 for ( size_t i=0; i< m_NumUnityFilesToCreate; ++i )
 {
  tmp.Format( "%u", i + 1 );

  AStackString<> unityFileName( m_OutputPath );
  unityFileName += m_OutputPattern;
  unityFileName.Replace( "*", tmp.Get() );

  m_UnityFileNames.Append( unityFileName );
 }
}



UnityNode::~UnityNode()
{
}



            Node::BuildResult UnityNode::DoBuild( Job * )
{
 bool hasOutputMessage = false;






 if ( EnsurePathExistsForFile( m_OutputPath ) == false )
 {
  return NODE_RESULT_FAILED;
 }


 Array< FileIO::FileInfo * > files( 4096, true );
 GetFiles( files );




 const size_t numFiles = files.GetSize();
 float numFilesPerUnity = (float)numFiles / m_NumUnityFilesToCreate;
 float remainingInThisUnity( 0.0 );

 uint32_t numFilesWritten( 0 );

 size_t index = 0;



 for ( size_t i=0; i<m_NumUnityFilesToCreate; ++i )
 {

  remainingInThisUnity += numFilesPerUnity;


  AStackString<4096> output( "// Auto-generated Unity file - do not modify\r\n\r\n" );


  if ( !m_PrecompiledHeader.IsEmpty() )
  {
   output += "#include \"";
   output += m_PrecompiledHeader;
   output += "\"\r\n\r\n";
  }





  Array< FileIO::FileInfo * > filesInThisUnity( 256, true );
  uint32_t numIsolated( 0 );
  const bool lastUnity = ( i == ( m_NumUnityFilesToCreate - 1 ) );
  while ( ( remainingInThisUnity > 0.0f ) || lastUnity )
  {
   remainingInThisUnity -= 1.0f;


   if ( index >= numFiles )
   {
    break;
   }

   filesInThisUnity.Append( files[index ] );


   if ( m_IsolateWritableFiles )
   {

    if ( files[ index ]->IsReadOnly() == false )
    {
     numIsolated++;
    }
   }


   index++;
   numFilesWritten++;
  }


  const FileIO::FileInfo * const * end = filesInThisUnity.End();
  for ( FileIO::FileInfo ** it = filesInThisUnity.Begin(); it != end; ++it )
  {
   const FileIO::FileInfo * file = *it;


   AStackString<> buffer( file->m_Name.Get() );
   buffer.Replace( ( '\\' ), ( '/' ) );

                output += "//";

   output += "#pragma message( \"";
   output += buffer;
   output += "\" )\r\n";


   if ( m_IsolateWritableFiles && ( ( m_MaxIsolatedFiles == 0 ) || ( numIsolated <= m_MaxIsolatedFiles ) ) )
   {

    if ( file->IsReadOnly() == false )
    {

     output += "//";
     m_IsolatedFiles.Append( file->m_Name );
    }
   }


   output += "#include \"";
   output += file->m_Name;
   output += "\"\r\n\r\n";
  }
  output += "\r\n";


  const AString & unityName = m_UnityFileNames[ i ];


  bool needToWrite = false;
  FileStream f;
  if ( FBuild::Get().GetOptions().m_ForceCleanBuild )
  {
   needToWrite = true;
  }
  else
  {
   if ( f.Open( unityName.Get(), FileStream::READ_ONLY ) )
   {
    const size_t fileSize( (size_t)f.GetFileSize() );
    if ( output.GetLength() != fileSize )
    {

     needToWrite = true;
    }
    else
    {

     AutoPtr< char > mem( (char *)::AllocFileLine( fileSize, "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/UnityNode.cpp", 223 ) );
     if ( f.Read( mem.Get(), fileSize ) != fileSize )
     {

      needToWrite = true;
     }
     else
     {
      if ( AString::StrNCmp( mem.Get(), output.Get(), fileSize ) != 0 )
      {

       needToWrite = true;
      }
     }
    }
    f.Close();
   }
   else
   {

    needToWrite = true;
   }
  }


  if ( needToWrite )
  {
   if ( hasOutputMessage == false )
   {
    do { FLog::Build( "Uni: %s\n", GetName().Get() ); } while ( false ); ;
    hasOutputMessage = true;
   }

   if ( f.Open( unityName.Get(), FileStream::WRITE_ONLY ) == false )
   {
    do { FLog::Error( "Failed to create Unity file '%s'", unityName.Get() ); } while ( false ); ;
    return NODE_RESULT_FAILED;
   }

   if ( f.Write( output.Get(), output.GetLength() ) != output.GetLength() )
   {
    do { FLog::Error( "Error writing Unity file '%s'", unityName.Get() ); } while ( false ); ;
    return NODE_RESULT_FAILED;
   }

   f.Close();
  }
 }


 do { if ( !( numFilesWritten == numFiles ) ) { if ( AssertHandler::Failure( "numFilesWritten == numFiles", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/UnityNode.cpp", 273 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;

 return NODE_RESULT_OK;
}



           Node * UnityNode::Load( IOStream & stream )
{
 AStackString<> name; if ( stream.Read( name ) == false ) { return (0); };
 AStackString<> outputPath; if ( stream.Read( outputPath ) == false ) { return (0); };
 AStackString<> outputPattern; if ( stream.Read( outputPattern ) == false ) { return (0); };
 uint32_t numFiles; if ( stream.Read( numFiles ) == false ) { return (0); };
 Dependencies staticDeps( 1, true ); if ( staticDeps.Load( stream ) == false ) { return (0); };
 Array< AString > files; if ( stream.Read( files ) == false ) { return (0); }
 AStackString<> precompiledHeader; if ( stream.Read( precompiledHeader ) == false ) { return (0); };
 Array< AString > pathsToExclude; if ( stream.Read( pathsToExclude ) == false ) { return (0); };
 Array< AString > filesToExclude; if ( stream.Read( filesToExclude ) == false ) { return (0); };
 bool isolateWritableFiles; if ( stream.Read( isolateWritableFiles ) == false ) { return (0); };
 uint32_t maxIsolatedFiles; if ( stream.Read( maxIsolatedFiles ) == false ) { return (0); };
 Array< AString > excludePatterns; if ( stream.Read( excludePatterns ) == false ) { return (0); };

 NodeGraph & ng = FBuild::Get().GetDependencyGraph();
 UnityNode * n = ng.CreateUnityNode( name,
         staticDeps,
         files,
         outputPath,
         outputPattern,
         numFiles,
         precompiledHeader,
         pathsToExclude,
         filesToExclude,
         isolateWritableFiles,
         maxIsolatedFiles,
         excludePatterns );
 return n;
}



            void UnityNode::Save( IOStream & stream ) const
{
 stream.Write( m_Name );;
 stream.Write( m_OutputPath );;
 stream.Write( m_OutputPattern );;
 stream.Write( m_NumUnityFilesToCreate );;
 m_StaticDependencies.Save( stream );;
 stream.Write( m_Files );;
 stream.Write( m_PrecompiledHeader );;
 stream.Write( m_PathsToExclude );;
 stream.Write( m_FilesToExclude );;
 stream.Write( m_IsolateWritableFiles );;
 stream.Write( m_MaxIsolatedFiles );;
 stream.Write( m_ExcludePatterns );;
}



void UnityNode::GetFiles( Array< FileIO::FileInfo * > & files )
{

 const Dependency * const sEnd = m_StaticDependencies.End();
 for ( const Dependency * sIt = m_StaticDependencies.Begin(); sIt != sEnd; ++sIt )
 {
  DirectoryListNode * dirNode = sIt->GetNode()->CastTo< DirectoryListNode >();
  const FileIO::FileInfo * const filesEnd = dirNode->GetFiles().End();


  for ( FileIO::FileInfo * filesIt = dirNode->GetFiles().Begin(); filesIt != filesEnd; ++filesIt )
  {
   bool keep = true;


   const AString * fit = m_FilesToExclude.Begin();
   const AString * const fend = m_FilesToExclude.End();
   for ( ; fit != fend; ++fit )
   {
    if ( filesIt->m_Name.EndsWithI( *fit ) )
    {
     keep = false;
     break;
    }
   }


   if ( keep )
   {
    const AString * pit = m_PathsToExclude.Begin();
    const AString * const pend = m_PathsToExclude.End();
    for ( ; pit != pend; ++pit )
    {
     if ( filesIt->m_Name.BeginsWithI( *pit ) )
     {
      keep = false;
      break;
     }
    }
   }


   if ( keep )
   {
    const AString * pit = m_ExcludePatterns.Begin();
    const AString * const pend = m_ExcludePatterns.End();
    for ( ; pit != pend; ++pit )
    {
     if ( PathUtils::IsWildcardMatch( pit->Get(), filesIt->m_Name.Get() ) )
     {
      keep = false;
      break;
     }
    }
   }

   if ( keep )
   {
    files.Append( filesIt );
   }
  }
 }


 size_t numFiles = m_Files.GetSize();
 if ( numFiles )
 {


  m_FilesInfo.SetSize( numFiles );
  for ( size_t i=0; i<numFiles; ++i )
  {


   if ( FileIO::GetFileInfo( m_Files[ i ], m_FilesInfo[ i ] ) )
   {

    files.Append( &m_FilesInfo[ i ] );
   }
  }
 }
}
# 137 "/home/ffulin/p4/tmp/Unity/Tools/FBuild/FBuildCore/Unity1.cpp" 2


# 1 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/CopyDirNode.cpp" 1





# 1 "./Tools/FBuild/FBuildCore/PrecompiledHeader.h" 1
# 7 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/CopyDirNode.cpp" 2

# 1 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/CopyDirNode.h" 1


       
# 16 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/CopyDirNode.h"
class CopyDirNode : public Node
{
public:
 explicit CopyDirNode( const AString & name,
        Dependencies & staticDeps,
        const AString & destPath,
        const Dependencies & preBuildDeps );
 virtual ~CopyDirNode();

 static inline Node::Type GetType() { return Node::COPY_DIR_NODE; }
 virtual bool IsAFile() const;

 static Node * Load( IOStream & stream );
 virtual void Save( IOStream & stream ) const;

private:
 virtual bool DoDynamicDependencies( bool forceClean );
 virtual BuildResult DoBuild( Job * job );

 AString m_DestPath;
};
# 9 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/CopyDirNode.cpp" 2
# 21 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/CopyDirNode.cpp"
CopyDirNode::CopyDirNode( const AString & name,
        Dependencies & staticDeps,
        const AString & destPath,
        const Dependencies & preBuildDeps )
: Node( name, Node::COPY_DIR_NODE, Node::FLAG_NONE )
, m_DestPath( destPath )
{
 m_StaticDependencies.Append( staticDeps );
 m_PreBuildDependencies = preBuildDeps;
}



CopyDirNode::~CopyDirNode()
{
}



            bool CopyDirNode::IsAFile() const
{
 return false;
}



            bool CopyDirNode::DoDynamicDependencies( bool forceClean )
{
 (void)forceClean;

 do { if ( !( !m_StaticDependencies.IsEmpty() ) ) { if ( AssertHandler::Failure( "!m_StaticDependencies.IsEmpty()", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/CopyDirNode.cpp", 51 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;

 NodeGraph & ng = FBuild::Get().GetDependencyGraph();


 const Dependency * const depEnd = m_StaticDependencies.End();
 for ( const Dependency * dep = m_StaticDependencies.Begin();
    dep != depEnd;
    ++dep )
 {

  DirectoryListNode * dln = dep->GetNode()->CastTo< DirectoryListNode >();
  const Array< FileIO::FileInfo > & files = dln->GetFiles();
  const FileIO::FileInfo * const fEnd = files.End();
  for ( const FileIO::FileInfo * fIt = files.Begin();
     fIt != fEnd;
     ++fIt )
  {



   const AString & srcFile = fIt->m_Name;


   const AStackString<> srcFileRel( srcFile.Get() + dln->GetPath().GetLength() );


   Node * srcFileNode = ng.FindNode( srcFile );
   if ( srcFileNode == (0) )
   {
    srcFileNode = ng.CreateFileNode( srcFile );
   }
   else if ( srcFileNode->IsAFile() == false )
   {
    do { FLog::Error( "CopyDir() Node '%s' is not a FileNode (type: %s)", srcFile.Get(), srcFileNode->GetTypeName() ); } while ( false ); ;
    return false;
   }


   const AStackString<> dstFile( m_DestPath );
   (AString &)dstFile += (AString &)srcFileRel;


   Node * n = ng.FindNode( dstFile );
   if ( n == (0) )
   {
    n = ng.CreateCopyNode( dstFile, srcFileNode, m_PreBuildDependencies );
   }
   else if ( n->GetType() != Node::COPY_NODE )
   {
    do { FLog::Error( "Node '%s' is not a CopyNode (type: %s)", n->GetName().Get(), n->GetTypeName() ); } while ( false ); ;
    return false;
   }
   else
   {
    CopyNode * cn = n->CastTo< CopyNode >();
    if ( srcFileNode != cn->GetSourceNode() )
    {
     do { FLog::Error( "Conflicting objects found during CopyDir:\n" " File A: %s\n" " File B: %s\n" " Both copy to: %s\n", srcFile.Get(), cn->GetSourceNode()->GetName().Get(), dstFile.Get() ); } while ( false );





                       ;
     return false;
    }
   }

   m_DynamicDependencies.Append( Dependency( n ) );
  }
 }
 return true;
}



            Node::BuildResult CopyDirNode::DoBuild( Job * )
{

 uint64_t timeStamp = 0;
 const Dependency * const end = m_DynamicDependencies.End();
 for ( const Dependency * it = m_DynamicDependencies.Begin(); it != end; ++it )
 {
  CopyNode * cn = it->GetNode()->CastTo< CopyNode >();
  timeStamp = Math::Max< uint64_t >( timeStamp, cn->GetStamp() );
 }
 m_Stamp = timeStamp;

 return NODE_RESULT_OK;
}



           Node * CopyDirNode::Load( IOStream & stream )
{
 AStackString<> name; if ( stream.Read( name ) == false ) { return (0); };
 Dependencies staticDeps( 4, true ); if ( staticDeps.Load( stream ) == false ) { return (0); };
 AStackString<> destPath; if ( stream.Read( destPath ) == false ) { return (0); };
 Dependencies preBuildDeps( 0, true ); if ( preBuildDeps.Load( stream ) == false ) { return (0); };

 NodeGraph & ng = FBuild::Get().GetDependencyGraph();
 CopyDirNode * n = ng.CreateCopyDirNode( name, staticDeps, destPath, preBuildDeps );
 do { if ( !( n ) ) { if ( AssertHandler::Failure( "n", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/CopyDirNode.cpp", 154 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;
 return n;
}



            void CopyDirNode::Save( IOStream & stream ) const
{
 stream.Write( m_Name );;
 m_StaticDependencies.Save( stream );;
 stream.Write( m_DestPath );;
 m_PreBuildDependencies.Save( stream );;
}
# 140 "/home/ffulin/p4/tmp/Unity/Tools/FBuild/FBuildCore/Unity1.cpp" 2


# 1 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/NodeProxy.cpp" 1





# 1 "./Tools/FBuild/FBuildCore/PrecompiledHeader.h" 1
# 7 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/NodeProxy.cpp" 2





NodeProxy::NodeProxy( const AString & name )
 : Node( name, Node::PROXY_NODE, 0 )
{
}



NodeProxy::~NodeProxy()
{
}



            bool NodeProxy::IsAFile() const
{
 do { if ( !( false ) ) { if ( AssertHandler::Failure( "false", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/NodeProxy.cpp", 27 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;
 return false;
}



            void NodeProxy::Save( IOStream & ) const
{
 do { if ( !( false ) ) { if ( AssertHandler::Failure( "false", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/NodeProxy.cpp", 35 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;
}



            bool NodeProxy::DetermineNeedToBuild( bool ) const
{
 do { if ( !( false ) ) { if ( AssertHandler::Failure( "false", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/NodeProxy.cpp", 42 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;
 return false;
}
# 143 "/home/ffulin/p4/tmp/Unity/Tools/FBuild/FBuildCore/Unity1.cpp" 2


# 1 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/TestNode.cpp" 1





# 1 "./Tools/FBuild/FBuildCore/PrecompiledHeader.h" 1
# 7 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/TestNode.cpp" 2
# 22 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/TestNode.cpp"
TestNode::TestNode( const AString & testOutput,
     FileNode * testExecutable,
     const AString & arguments,
     const AString & workingDir )
 : FileNode( testOutput, Node::FLAG_NO_DELETE_ON_FAIL )
 , m_Executable( testExecutable )
 , m_Arguments( arguments )
 , m_WorkingDir( workingDir )
{
 do { if ( !( testExecutable ) ) { if ( AssertHandler::Failure( "testExecutable", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/TestNode.cpp", 31 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;
 m_StaticDependencies.Append( Dependency( testExecutable ) );
 m_Type = TEST_NODE;
}



TestNode::~TestNode()
{
}



            Node::BuildResult TestNode::DoBuild( Job * job )
{

 const char * workingDir = m_WorkingDir.IsEmpty() ? (0) : m_WorkingDir.Get();

 EmitCompilationMessage( workingDir );


 Process p;
 bool spawnOK = p.Spawn( m_Executable->GetName().Get(),
       m_Arguments.Get(),
       workingDir,
       FBuild::Get().GetEnvironmentString() );

 if ( !spawnOK )
 {
  do { FLog::Error( "Failed to spawn process for '%s'", GetName().Get() ); } while ( false ); ;
  return NODE_RESULT_FAILED;
 }


 AutoPtr< char > memOut;
 AutoPtr< char > memErr;
 uint32_t memOutSize = 0;
 uint32_t memErrSize = 0;
 p.ReadAllData( memOut, &memOutSize, memErr, &memErrSize );

 do { if ( !( !p.IsRunning() ) ) { if ( AssertHandler::Failure( "!p.IsRunning()", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/TestNode.cpp", 71 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;

 int result = p.WaitForExit();
 if ( result != 0 )
 {

  Node::DumpOutput( job, memOut.Get(), memOutSize );
  Node::DumpOutput( job, memErr.Get(), memErrSize );
 }


 FileStream fs;
 if ( fs.Open( GetName().Get(), FileStream::WRITE_ONLY ) == false )
 {
  do { FLog::Error( "Failed to open test output file '%s'", GetName().Get() ); } while ( false ); ;
  return NODE_RESULT_FAILED;
 }
 if ( ( memOut.Get() && ( fs.Write( memOut.Get(), memOutSize ) != memOutSize ) ) ||
   ( memErr.Get() && ( fs.Write( memErr.Get(), memErrSize ) != memErrSize ) ) )
 {
  do { FLog::Error( "Failed to write test output file '%s'", GetName().Get() ); } while ( false ); ;
  return NODE_RESULT_FAILED;
 }
 fs.Close();


 if ( result != 0 )
 {
  do { FLog::Error( "Test failed (error %i) '%s'", result, GetName().Get() ); } while ( false ); ;
  return NODE_RESULT_FAILED;
 }



 m_Stamp = FileIO::GetFileLastWriteTime( m_Name );
 return NODE_RESULT_OK;
}



void TestNode::EmitCompilationMessage( const char * workingDir ) const
{
 AStackString<> output;
 output += "Running Test: ";
 output += GetName();
 output += '\n';
 if ( FLog::ShowInfo() || FBuild::Get().GetOptions().m_ShowCommandLines )
 {
  output += m_Executable->GetName();
  output += ' ';
  output += m_Arguments;
  output += '\n';
  if ( workingDir )
  {
   output += "Working Dir: ";
   output += workingDir;
   output += '\n';
  }
 }
 do { FLog::Build( "%s", output.Get() ); } while ( false ); ;
}



            void TestNode::Save( IOStream & stream ) const
{
 stream.Write( m_Name );;
 stream.Write( m_Executable->GetName() );;
 stream.Write( m_Arguments );;
 stream.Write( m_WorkingDir );;
}



           Node * TestNode::Load( IOStream & stream )
{
 AStackString<> fileName; if ( stream.Read( fileName ) == false ) { return (0); };
 AStackString<> executable; if ( stream.Read( executable ) == false ) { return (0); };
 AStackString<> arguments; if ( stream.Read( arguments ) == false ) { return (0); };
 AStackString<> workingDir; if ( stream.Read( workingDir ) == false ) { return (0); };

 NodeGraph & ng = FBuild::Get().GetDependencyGraph();

 Node * execNode = ng.FindNode( executable );
 do { if ( !( execNode ) ) { if ( AssertHandler::Failure( "execNode", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/TestNode.cpp", 155 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;
 do { if ( !( execNode->IsAFile() ) ) { if ( AssertHandler::Failure( "execNode->IsAFile()", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/TestNode.cpp", 156 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;

 TestNode * n = ng.CreateTestNode( fileName,
           (FileNode *)execNode,
           arguments,
           workingDir );
 do { if ( !( n ) ) { if ( AssertHandler::Failure( "n", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/TestNode.cpp", 162 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;
 return n;
}
# 146 "/home/ffulin/p4/tmp/Unity/Tools/FBuild/FBuildCore/Unity1.cpp" 2


# 1 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/ExeNode.cpp" 1





# 1 "./Tools/FBuild/FBuildCore/PrecompiledHeader.h" 1
# 7 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/ExeNode.cpp" 2
# 18 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/ExeNode.cpp"
ExeNode::ExeNode( const AString & linkerOutputName,
      const Dependencies & inputLibraries,
      const Dependencies & otherLibraries,
      const AString & linker,
      const AString & linkerArgs,
      uint32_t flags,
      const Dependencies & assemblyResources,
      Node * linkerStampExe,
      const AString & linkerStampExeArgs )
: LinkerNode( linkerOutputName, inputLibraries, otherLibraries, linker, linkerArgs, flags, assemblyResources, linkerStampExe, linkerStampExeArgs )
{
 m_Type = EXE_NODE;
}



ExeNode::~ExeNode()
{
}



           Node * ExeNode::Load( IOStream & stream )
{

 AStackString<> name; if ( stream.Read( name ) == false ) { return (0); };
 AStackString<> linker; if ( stream.Read( linker ) == false ) { return (0); };
 AStackString<> linkerArgs; if ( stream.Read( linkerArgs ) == false ) { return (0); };
 Dependencies inputLibs( 0, true ); if ( inputLibs.Load( stream ) == false ) { return (0); };
 uint32_t flags; if ( stream.Read( flags ) == false ) { return (0); };
 Dependencies assemblyResources( 0, true ); if ( assemblyResources.Load( stream ) == false ) { return (0); };
 Dependencies otherLibs( 0, true ); if ( otherLibs.Load( stream ) == false ) { return (0); };
    Node * linkerStampExe = (0); if ( Node::LoadNode( stream, linkerStampExe ) == false ) { return (0); };
    AStackString<> linkerStampExeArgs; if ( stream.Read( linkerStampExeArgs ) == false ) { return (0); };

 NodeGraph & ng = FBuild::Get().GetDependencyGraph();
 ExeNode * en = ng.CreateExeNode( name, inputLibs, otherLibs, linker, linkerArgs, flags, assemblyResources, linkerStampExe, linkerStampExeArgs );
 return en;
}
# 149 "/home/ffulin/p4/tmp/Unity/Tools/FBuild/FBuildCore/Unity1.cpp" 2


# 1 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/ObjectListNode.cpp" 1





# 1 "./Tools/FBuild/FBuildCore/PrecompiledHeader.h" 1
# 7 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/ObjectListNode.cpp" 2
# 25 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/ObjectListNode.cpp"
ObjectListNode::ObjectListNode( const AString & listName,
        const Dependencies & inputNodes,
        CompilerNode * compiler,
        const AString & compilerArgs,
        const AString & compilerArgsDeoptimized,
        const AString & compilerOutputPath,
        ObjectNode * precompiledHeader,
        const Dependencies & compilerForceUsing,
        const Dependencies & preBuildDependencies,
        bool deoptimizeWritableFiles,
        bool deoptimizeWritableFilesWithToken )
: Node( listName, Node::OBJECT_LIST_NODE, Node::FLAG_NONE )
, m_CompilerForceUsing( compilerForceUsing )
, m_DeoptimizeWritableFiles( deoptimizeWritableFiles )
, m_DeoptimizeWritableFilesWithToken( deoptimizeWritableFilesWithToken )
{
 m_LastBuildTimeMs = 10000;


 do { if ( !( !inputNodes.IsEmpty() ) ) { if ( AssertHandler::Failure( "!inputNodes.IsEmpty()", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/ObjectListNode.cpp", 44 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;
 m_StaticDependencies = inputNodes;


 m_PrecompiledHeader = precompiledHeader;


 m_Compiler = compiler;
 m_CompilerArgs = compilerArgs;
 m_CompilerArgsDeoptimized = compilerArgsDeoptimized;
 m_CompilerOutputPath = compilerOutputPath;

 m_PreBuildDependencies = preBuildDependencies;
}



ObjectListNode::~ObjectListNode()
{
}



            bool ObjectListNode::IsAFile() const
{
 return false;
}



            bool ObjectListNode::DoDynamicDependencies( bool forceClean )
{
 (void)forceClean;


 m_DynamicDependencies.Clear();



 Node * pchCPP = (0);
 if ( m_PrecompiledHeader )
 {
  do { if ( !( m_PrecompiledHeader->GetType() == Node::OBJECT_NODE ) ) { if ( AssertHandler::Failure( "m_PrecompiledHeader->GetType() == Node::OBJECT_NODE", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/ObjectListNode.cpp", 86 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;
  pchCPP = m_PrecompiledHeader->GetPrecompiledHeaderCPPFile();
 }

 NodeGraph & ng = FBuild::Get().GetDependencyGraph();


 for ( Dependencies::Iter i = m_StaticDependencies.Begin();
    i != m_StaticDependencies.End();
    i++ )
 {

  if ( i->GetNode()->GetType() == Node::DIRECTORY_LIST_NODE )
  {

   DirectoryListNode * dln = i->GetNode()->CastTo< DirectoryListNode >();
   const Array< FileIO::FileInfo > & files = dln->GetFiles();
   m_DynamicDependencies.SetCapacity( m_DynamicDependencies.GetSize() + files.GetSize() );
   for ( Array< FileIO::FileInfo >::Iter fIt = files.Begin();
     fIt != files.End();
     fIt++ )
   {

    Node * n = ng.FindNode( fIt->m_Name );
    if ( n == (0) )
    {
     n = ng.CreateFileNode( fIt->m_Name );
    }
    else if ( n->IsAFile() == false )
    {
     do { FLog::Error( "Library() .CompilerInputFile '%s' is not a FileNode (type: %s)", n->GetName().Get(), n->GetTypeName() ); } while ( false ); ;
     return false;
    }



    if ( pchCPP && ( n == pchCPP ) )
    {
     continue;
    }


    if ( CreateDynamicObjectNode( n ) == false )
    {
     return false;
    }
   }
  }
  else if ( i->GetNode()->GetType() == Node::FILE_NODE )
  {

   if ( CreateDynamicObjectNode( i->GetNode() ) == false )
   {
    return false;
   }
  }
  else if ( i->GetNode()->GetType() == Node::UNITY_NODE )
  {

   UnityNode * un = i->GetNode()->CastTo< UnityNode >();


   const Array< AString > & unityFiles = un->GetUnityFileNames();
   for ( Array< AString >::Iter it = unityFiles.Begin();
      it != unityFiles.End();
      it++ )
   {
    Node * n = ng.FindNode( *it );
    if ( n == (0) )
    {
     n = ng.CreateFileNode( *it );
    }
    else if ( n->IsAFile() == false )
    {
     do { FLog::Error( "Library() .CompilerInputUnity '%s' is not a FileNode (type: %s)", n->GetName().Get(), n->GetTypeName() ); } while ( false ); ;
     return false;
    }


    if ( CreateDynamicObjectNode( n, true ) == false )
    {
     return false;
    }
   }


   const Array< AString > & isolatedFiles = un->GetIsolatedFileNames();
   for ( Array< AString >::Iter it = isolatedFiles.Begin();
      it != isolatedFiles.End();
      it++ )
   {
    Node * n = ng.FindNode( *it );
    if ( n == (0) )
    {
     n = ng.CreateFileNode( *it );
    }
    else if ( n->IsAFile() == false )
    {
     do { FLog::Error( "Library() Isolated '%s' is not a FileNode (type: %s)", n->GetName().Get(), n->GetTypeName() ); } while ( false ); ;
     return false;
    }


    if ( CreateDynamicObjectNode( n, false, true ) == false )
    {
     return false;
    }
   }
  }
  else
  {
   do { if ( !( false ) ) { if ( AssertHandler::Failure( "false", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/ObjectListNode.cpp", 197 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;
  }
 }





 if ( m_DynamicDependencies.GetSize() == 0 )
 {
  do { FLog::Error( "No files found to build '%s'", GetName().Get() ); } while ( false ); ;
  return false;
 }





 if ( m_PrecompiledHeader )
 {
  m_DynamicDependencies.Append( Dependency( m_PrecompiledHeader ) );
 }

 return true;
}



            Node::BuildResult ObjectListNode::DoBuild( Job * )
{

 uint64_t timeStamp = 0;
 const Dependency * const end = m_DynamicDependencies.End();
 for ( const Dependency * it = m_DynamicDependencies.Begin(); it != end; ++it )
 {
  ObjectNode * on = it->GetNode()->CastTo< ObjectNode >();
  timeStamp = Math::Max< uint64_t >( timeStamp, on->GetStamp() );
 }
 m_Stamp = timeStamp;

 return NODE_RESULT_OK;
}



void ObjectListNode::GetInputFiles( AString & fullArgs, const AString & pre, const AString & post ) const
{

 for ( Dependencies::Iter i = m_DynamicDependencies.Begin();
    i != m_DynamicDependencies.End();
    i++ )
 {
  const Node * n = i->GetNode();


  if ( n->GetType() == Node::OBJECT_NODE )
  {

   const ObjectNode * on = n->CastTo< ObjectNode >();
   if ( on->IsCreatingPCH() )
   {
    if ( on->IsMSVC() )
    {
     fullArgs += pre;
     fullArgs += on->GetName();
     fullArgs += on->GetObjExtension();
     fullArgs += post;
     fullArgs += ' ';
     continue;
    }
    else
    {

     continue;
    }
   }
  }


  fullArgs += pre;
  fullArgs += n->GetName();
  fullArgs += post;
  fullArgs += ' ';
 }
}



bool ObjectListNode::CreateDynamicObjectNode( Node * inputFile, bool isUnityNode, bool isIsolatedFromUnityNode )
{
 const AString & fileName = inputFile->GetName();



 const char * lastSlash = fileName.FindLast( ( '/' ) );
 lastSlash = lastSlash ? ( lastSlash + 1 ) : fileName.Get();
 const char * lastDot = fileName.FindLast( '.' );
 lastDot = lastDot && ( lastDot > lastSlash ) ? lastDot : fileName.GetEnd();
 AStackString<> fileNameOnly( lastSlash, lastDot );
 AStackString<> objFile( m_CompilerOutputPath );
 objFile += fileNameOnly;
 objFile += GetObjExtension();



 NodeGraph & ng = FBuild::Get().GetDependencyGraph();
 Node * on = ng.FindNode( objFile );
 if ( on == (0) )
 {

  uint32_t flags = ObjectNode::DetermineFlags( m_Compiler, m_CompilerArgs );
  if ( isUnityNode )
  {
   flags |= ObjectNode::FLAG_UNITY;
  }
  if ( isIsolatedFromUnityNode )
  {
   flags |= ObjectNode::FLAG_ISOLATED_FROM_UNITY;
  }

  on = ng.CreateObjectNode( objFile, inputFile, m_Compiler, m_CompilerArgs, m_CompilerArgsDeoptimized, m_PrecompiledHeader, flags, m_CompilerForceUsing, m_DeoptimizeWritableFiles, m_DeoptimizeWritableFilesWithToken );
 }
 else if ( on->GetType() != Node::OBJECT_NODE )
 {
  do { FLog::Error( "Node '%s' is not an ObjectNode (type: %s)", on->GetName().Get(), on->GetTypeName() ); } while ( false ); ;
  return false;
 }
 else
 {
  ObjectNode * other = on->CastTo< ObjectNode >();
  if ( inputFile != other->GetSourceFile() )
  {
   do { FLog::Error( "Conflicting objects found:\n" " File A: %s\n" " File B: %s\n" " Both compile to: %s\n", inputFile->GetName().Get(), other->GetSourceFile()->GetName().Get(), objFile.Get() ); } while ( false );





                     ;
   return false;
  }
 }
 m_DynamicDependencies.Append( Dependency( on ) );
 return true;
}



           Node * ObjectListNode::Load( IOStream & stream )
{
 AStackString<> name; if ( stream.Read( name ) == false ) { return (0); };
 CompilerNode * compilerNode = (0); if ( Node::LoadNode( stream, compilerNode ) == false ) { return (0); };
 AStackString<> compilerArgs; if ( stream.Read( compilerArgs ) == false ) { return (0); };
 AStackString<> compilerArgsDeoptimized; if ( stream.Read( compilerArgsDeoptimized ) == false ) { return (0); };
 AStackString<> compilerOutputPath; if ( stream.Read( compilerOutputPath ) == false ) { return (0); };
 Dependencies staticDeps( 16, true ); if ( staticDeps.Load( stream ) == false ) { return (0); };
 Node * precompiledHeader = (0); if ( Node::LoadNode( stream, precompiledHeader ) == false ) { return (0); };
 AStackString<> objExtensionOverride; if ( stream.Read( objExtensionOverride ) == false ) { return (0); };
 Dependencies compilerForceUsing( 0, true ); if ( compilerForceUsing.Load( stream ) == false ) { return (0); };
 Dependencies preBuildDependencies( 0, true ); if ( preBuildDependencies.Load( stream ) == false ) { return (0); };
 bool deoptimizeWritableFiles; if ( stream.Read( deoptimizeWritableFiles ) == false ) { return (0); };
 bool deoptimizeWritableFilesWithToken; if ( stream.Read( deoptimizeWritableFilesWithToken ) == false ) { return (0); };

 NodeGraph & ng = FBuild::Get().GetDependencyGraph();
 ObjectListNode * n = ng.CreateObjectListNode( name,
        staticDeps,
        compilerNode,
        compilerArgs,
        compilerArgsDeoptimized,
        compilerOutputPath,
        precompiledHeader ? precompiledHeader->CastTo< ObjectNode >() : (0),
        compilerForceUsing,
        preBuildDependencies,
        deoptimizeWritableFiles,
        deoptimizeWritableFilesWithToken );
 n->m_ObjExtensionOverride = objExtensionOverride;
# 382 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/ObjectListNode.cpp"
 return n;
}



            void ObjectListNode::Save( IOStream & stream ) const
{
 stream.Write( m_Name );;
 Node::SaveNode( stream, m_Compiler );;
 stream.Write( m_CompilerArgs );;
 stream.Write( m_CompilerArgsDeoptimized );;
 stream.Write( m_CompilerOutputPath );;
 m_StaticDependencies.Save( stream );;
 Node::SaveNode( stream, m_PrecompiledHeader );;
 stream.Write( m_ObjExtensionOverride );;
 m_CompilerForceUsing.Save( stream );;
 m_PreBuildDependencies.Save( stream );;
 stream.Write( m_DeoptimizeWritableFiles );;
 stream.Write( m_DeoptimizeWritableFilesWithToken );;






}



const char * ObjectListNode::GetObjExtension() const
{
 if ( m_ObjExtensionOverride.IsEmpty() )
 {
  return ".obj";
 }
 return m_ObjExtensionOverride.Get();
}
# 152 "/home/ffulin/p4/tmp/Unity/Tools/FBuild/FBuildCore/Unity1.cpp" 2


# 1 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/Dependencies.cpp" 1






# 1 "./Tools/FBuild/FBuildCore/PrecompiledHeader.h" 1
# 8 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/Dependencies.cpp" 2
# 35 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/Dependencies.cpp"
void Dependencies::Save( IOStream & stream ) const
{
 size_t numDeps = GetSize();
 stream.Write( (uint32_t)numDeps );

 Iter end = End();
 for ( Iter it = Begin(); it != end; ++it )
 {
  const Dependency & dep = *it;


  uint32_t index = dep.GetNode()->GetIndex();
  stream.Write( index );


  bool isWeak = dep.IsWeak();
  stream.Write( isWeak );
 }
}



bool Dependencies::Load( IOStream & stream )
{
 uint32_t numDeps;
 if ( stream.Read( numDeps ) == false )
 {
  return false;
 }
 if ( GetCapacity() < GetSize() + numDeps )
 {
  SetCapacity( GetSize() + numDeps );
 }
 NodeGraph & ng = FBuild::Get().GetDependencyGraph();
 for ( uint32_t i=0; i<numDeps; ++i )
 {

  uint32_t index( ( (uint32_t)0xFFFFFFFF ) );
  if ( stream.Read( index ) == false )
  {
   return false;
  }


  Node * node = ng.GetNodeByIndex( index );
  do { if ( !( node ) ) { if ( AssertHandler::Failure( "node", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/Dependencies.cpp", 80 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;


  bool isWeak( false );
  if ( stream.Read( isWeak ) == false )
  {
   return false;
  }


  Append( Dependency( node, isWeak ) );
 }
 return true;
}
# 155 "/home/ffulin/p4/tmp/Unity/Tools/FBuild/FBuildCore/Unity1.cpp" 2


# 1 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/LinkerNode.cpp" 1





# 1 "./Tools/FBuild/FBuildCore/PrecompiledHeader.h" 1
# 7 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/LinkerNode.cpp" 2
# 28 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/LinkerNode.cpp"
LinkerNode::LinkerNode( const AString & linkerOutputName,
       const Dependencies & inputLibraries,
       const Dependencies & otherLibraries,
       const AString & linker,
       const AString & linkerArgs,
       uint32_t flags,
       const Dependencies & assemblyResources,
       Node * linkerStampExe,
       const AString & linkerStampExeArgs )
: FileNode( linkerOutputName, Node::FLAG_NONE )
, m_Flags( flags )
, m_AssemblyResources( assemblyResources )
, m_OtherLibraries( otherLibraries )
, m_LinkerStampExe( linkerStampExe )
, m_LinkerStampExeArgs( linkerStampExeArgs )
{
 m_LastBuildTimeMs = 20000;


 size_t numStaticDeps = inputLibraries.GetSize() + assemblyResources.GetSize() + otherLibraries.GetSize();
 if ( linkerStampExe )
 {
  numStaticDeps++;
 }
 m_StaticDependencies.SetCapacity( numStaticDeps );


 m_StaticDependencies.Append( inputLibraries );
 m_StaticDependencies.Append( assemblyResources );
 m_StaticDependencies.Append( otherLibraries );


 if ( linkerStampExe )
 {
  m_StaticDependencies.Append( Dependency( linkerStampExe ) );
 }


 m_Linker = linker;
 m_LinkerArgs = linkerArgs;
}



LinkerNode::~LinkerNode()
{
}



            Node::BuildResult LinkerNode::DoBuild( Job * )
{
 DoPreLinkCleanup();


 AStackString< 4 * (1024) > fullArgs;
 GetFullArgs( fullArgs );


 const char * workingDir = (0);

 const char * environment = FBuild::Get().GetEnvironmentString();

 EmitCompilationMessage( fullArgs );


 ResponseFile rf;
 AStackString<> responseFileArgs;
 const bool useResponseFile = GetFlag( LINK_FLAG_MSVC ) || GetFlag( LINK_FLAG_GCC ) || GetFlag( LINK_FLAG_SNC ) || GetFlag( LINK_FLAG_ORBIS_LD ) || GetFlag( LINK_FLAG_GREENHILLS_ELXR ) || GetFlag( LINK_FLAG_CODEWARRIOR_LD );
 if ( useResponseFile )
 {

  if ( GetFlag( LINK_FLAG_ORBIS_LD ) )
  {
   rf.SetEscapeSlashes();
  }


  if ( !rf.Create( fullArgs ) )
  {
   return NODE_RESULT_FAILED;
  }


  responseFileArgs.Format( "@\"%s\"", rf.GetResponseFilePath().Get() );
 }


 uint32_t attempt( 0 );

 for (;;)
 {
  ++attempt;


  Process p;
  bool spawnOK = p.Spawn( m_Linker.Get(),
        useResponseFile ? responseFileArgs.Get() : fullArgs.Get(),
        workingDir,
        environment );

  if ( !spawnOK )
  {
   do { FLog::Error( "Failed to spawn process for %s creation for '%s'", GetDLLOrExe(), GetName().Get() ); } while ( false ); ;
   return NODE_RESULT_FAILED;
  }


  AutoPtr< char > memOut;
  AutoPtr< char > memErr;
  uint32_t memOutSize = 0;
  uint32_t memErrSize = 0;
  p.ReadAllData( memOut, &memOutSize, memErr, &memErrSize );

  do { if ( !( !p.IsRunning() ) ) { if ( AssertHandler::Failure( "!p.IsRunning()", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/LinkerNode.cpp", 142 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;

  int result = p.WaitForExit();


  if ( result != 0 )
  {

   if ( GetFlag( LINK_FLAG_MSVC ) && ( result == 1000 ) && ( attempt == 1 ) )
   {
    do { FLog::Warning( "FBuild: Warning: Linker crashed (LNK1000), retrying '%s'", GetName().Get() ); } while ( false ); ;
    continue;
   }

   if ( memOut.Get() ) { do { FLog::ErrorDirect( memOut.Get() ); } while ( false ); ; }
   if ( memErr.Get() ) { do { FLog::ErrorDirect( memErr.Get() ); } while ( false ); ; }


   do { FLog::Error( "Failed to build %s (error %i) '%s'", GetDLLOrExe(), result, GetName().Get() ); } while ( false ); ;
   return NODE_RESULT_FAILED;
  }
  else
  {
   break;
  }
 }


 if ( m_LinkerStampExe )
 {
  EmitStampMessage();

  Process stampProcess;
  bool spawnOk = stampProcess.Spawn( m_LinkerStampExe->GetName().Get(),
             m_LinkerStampExeArgs.Get(),
             (0),
             (0) );
  if ( spawnOk == false )
  {
   do { FLog::Error( "Failed to spawn process '%s' for '%s' stamping of '%s'", m_LinkerStampExe->GetName().Get(), GetDLLOrExe(), GetName().Get() ); } while ( false ); ;
   return NODE_RESULT_FAILED;
  }


  AutoPtr< char > memOut;
  AutoPtr< char > memErr;
  uint32_t memOutSize = 0;
  uint32_t memErrSize = 0;
  stampProcess.ReadAllData( memOut, &memOutSize, memErr, &memErrSize );
  do { if ( !( !stampProcess.IsRunning() ) ) { if ( AssertHandler::Failure( "!stampProcess.IsRunning()", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/LinkerNode.cpp", 191 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;


  int result = stampProcess.WaitForExit();


  if ( result != 0 )
  {
   if ( memOut.Get() ) { do { FLog::ErrorDirect( memOut.Get() ); } while ( false ); ; }
   if ( memErr.Get() ) { do { FLog::ErrorDirect( memErr.Get() ); } while ( false ); ; }
   do { FLog::Error( "Failed to stamp %s '%s' (error %i - '%s')", GetDLLOrExe(), GetName().Get(), result, m_LinkerStampExe->GetName().Get() ); } while ( false ); ;
   return NODE_RESULT_FAILED;
  }


 }


 m_Stamp = FileIO::GetFileLastWriteTime( m_Name );
 do { if ( !( m_Stamp ) ) { if ( AssertHandler::Failure( "m_Stamp", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/LinkerNode.cpp", 210 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;

 return NODE_RESULT_OK;
}



void LinkerNode::DoPreLinkCleanup() const
{

 if ( GetFlag( LINK_FLAG_MSVC ) == false )
 {
  return;
 }

 bool deleteFiles = false;
 if ( GetFlag( LINK_FLAG_INCREMENTAL ) )
 {
  if ( FBuild::Get().GetOptions().m_ForceCleanBuild )
  {
   deleteFiles = true;
  }
 }
 else
 {


  deleteFiles = true;
 }

 if ( deleteFiles )
 {

  FileIO::FileDelete( GetName().Get() );


  const char * lastDot = GetName().FindLast( '.' );
  AStackString<> ilkName( GetName().Get(), lastDot ? lastDot : GetName().GetEnd() );
  ilkName += ".ilk";
  FileIO::FileDelete( ilkName.Get() );


  AStackString<> pdbName( GetName().Get(), lastDot ? lastDot : GetName().GetEnd() );
  pdbName += ".pdb";
  FileIO::FileDelete( pdbName.Get() );
 }
}



void LinkerNode::GetFullArgs( AString & fullArgs ) const
{

 Array< AString > tokens( 1024, true );
 m_LinkerArgs.Tokenize( tokens );

 const AString * const end = tokens.End();
 for ( const AString * it = tokens.Begin(); it!=end; ++it )
 {
  const AString & token = *it;


  const char * found = token.Find( "%1" );
  if ( found )
  {
   AStackString<> pre( token.Get(), found );
   AStackString<> post( found + 2, token.GetEnd() );
   GetInputFiles( fullArgs, pre, post );
   fullArgs += ' ';
   continue;
  }


  found = token.Find( "%2" );
  if ( found )
  {
   fullArgs += AStackString<>( token.Get(), found );
   fullArgs += m_Name;
   fullArgs += AStackString<>( found + 2, token.GetEnd() );
   fullArgs += ' ';
   continue;
  }


  if ( GetFlag( LINK_FLAG_MSVC ) )
  {
   found = token.Find( "%3" );
   if ( found )
   {
    AStackString<> pre( token.Get(), found );
    AStackString<> post( found + 2, token.GetEnd() );
    GetAssemblyResourceFiles( fullArgs, pre, post );
    fullArgs += ' ';
    continue;
   }
  }


  fullArgs += token;
  fullArgs += ' ';
 }
}



void LinkerNode::GetInputFiles( AString & fullArgs, const AString & pre, const AString & post ) const
{

 const Dependency * end = m_StaticDependencies.End() - ( m_AssemblyResources.GetSize() + m_OtherLibraries.GetSize() );
 if ( m_LinkerStampExe )
 {
  --end;
 }
 for ( Dependencies::Iter i = m_StaticDependencies.Begin();
    i != end;
    i++ )
 {
  Node * n( i->GetNode() );
  GetInputFiles( n, fullArgs, pre, post );
 }
}



void LinkerNode::GetInputFiles( Node * n, AString & fullArgs, const AString & pre, const AString & post ) const
{
 if ( n->GetType() == Node::LIBRARY_NODE )
 {
  bool linkObjectsInsteadOfLibs = GetFlag( LINK_OBJECTS );

  if ( linkObjectsInsteadOfLibs )
  {
   LibraryNode * ln = n->CastTo< LibraryNode >();
   ln->GetInputFiles( fullArgs, pre, post );
  }
  else
  {

   fullArgs += pre;
   fullArgs += n->GetName();
   fullArgs += post;
  }
 }
 else if ( n->GetType() == Node::OBJECT_LIST_NODE )
 {
  ObjectListNode * ol = n->CastTo< ObjectListNode >();
  ol->GetInputFiles( fullArgs, pre, post );
 }
 else if ( n->GetType() == Node::DLL_NODE )
 {

  DLLNode * dllNode = n->CastTo< DLLNode >();
  AStackString<> importLibName;
  dllNode->GetImportLibName( importLibName );
  fullArgs += pre;
  fullArgs += importLibName;
  fullArgs += post;
 }
 else if ( n->GetType() == Node::COPY_NODE )
 {
  CopyNode * copyNode = n->CastTo< CopyNode >();
  Node * srcNode = copyNode->GetSourceNode();
  GetInputFiles( srcNode, fullArgs, pre, post );
 }
 else
 {

  fullArgs += pre;
  fullArgs += n->GetName();
  fullArgs += post;
 }

 fullArgs += ' ';
}



void LinkerNode::GetAssemblyResourceFiles( AString & fullArgs, const AString & pre, const AString & post ) const
{
 const Dependency * const end = m_AssemblyResources.End();
 for ( Dependencies::Iter i = m_AssemblyResources.Begin();
    i != end;
    i++ )
 {
  Node * n( i->GetNode() );

  if ( n->GetType() == Node::OBJECT_LIST_NODE )
  {
   ObjectListNode * oln = n->CastTo< ObjectListNode >();
   oln->GetInputFiles( fullArgs, pre, post );
   continue;
  }

  if ( n->GetType() == Node::LIBRARY_NODE )
  {
   LibraryNode * ln = n->CastTo< LibraryNode >();
   ln->GetInputFiles( fullArgs, pre, post );
   continue;
  }

  fullArgs += pre;
  fullArgs += n->GetName();
  fullArgs += post;
  fullArgs += ' ';
 }
}



           uint32_t LinkerNode::DetermineFlags( const AString & linkerName, const AString & args )
{
 uint32_t flags = 0;


 if ( ( linkerName.EndsWithI( "link.exe" ) ) ||
   ( linkerName.EndsWithI( "link" ) ) )
 {
  flags |= LinkerNode::LINK_FLAG_MSVC;
 }
 else if ( ( linkerName.EndsWithI( "gcc.exe" ) ) ||
     ( linkerName.EndsWithI( "gcc" ) ) )
 {
  flags |= LinkerNode::LINK_FLAG_GCC;
 }
 else if ( ( linkerName.EndsWithI( "ps3ppuld.exe" ) ) ||
     ( linkerName.EndsWithI( "ps3ppuld" ) ) )
 {
  flags |= LinkerNode::LINK_FLAG_SNC;
 }
 else if ( ( linkerName.EndsWithI( "orbis-ld.exe" ) ) ||
     ( linkerName.EndsWithI( "orbis-ld" ) ) )
 {
  flags |= LinkerNode::LINK_FLAG_ORBIS_LD;
 }
 else if ( ( linkerName.EndsWithI( "elxr.exe" ) ) ||
     ( linkerName.EndsWithI( "elxr" ) ) )
 {
  flags |= LinkerNode::LINK_FLAG_GREENHILLS_ELXR;
 }
 else if ( ( linkerName.EndsWithI( "mwldeppc.exe" ) ) ||
     ( linkerName.EndsWithI( "mwldeppc." ) ) )
 {
  flags |= LinkerNode::LINK_FLAG_CODEWARRIOR_LD;
 }

 if ( flags & ( LINK_FLAG_GCC | LINK_FLAG_SNC | LINK_FLAG_ORBIS_LD ) )
 {

  Array< AString > tokens;
  args.Tokenize( tokens );

        const AString * const end = tokens.End();
  for ( const AString * it=tokens.Begin(); it!=end; ++it )
  {
   const AString & token = *it;
   if ( ( token == "-shared" ) || ( token == "-dynamiclib" ) )
   {
    flags |= LinkerNode::LINK_FLAG_DLL;
    continue;
   }
        }
    }

 if ( flags & LINK_FLAG_MSVC )
 {

  Array< AString > tokens;
  args.Tokenize( tokens );

  bool debugFlag = false;
  bool incrementalFlag = false;
  bool incrementalNoFlag = false;
  bool optREFFlag = false;
  bool optICFFlag = false;
  bool optLBRFlag = false;
  bool orderFlag = false;

  const AString * const end = tokens.End();
  for ( const AString * it=tokens.Begin(); it!=end; ++it )
  {
   const AString & token = *it;
   if ( token == "/DLL" )
   {
    flags |= LinkerNode::LINK_FLAG_DLL;
    continue;
   }

   if ( token == "/DEBUG" )
   {
    debugFlag = true;
    continue;
   }

   if ( token == "/INCREMENTAL")
   {
    incrementalFlag = true;
    continue;
   }

   if ( token == "/INCREMENTAL:NO")
   {
    incrementalNoFlag = true;
    continue;
   }

   if ( token == "/OPT:REF")
   {
    optREFFlag = true;
    continue;
   }

   if ( token == "/OPT:ICF")
   {
    optICFFlag = true;
    continue;
   }

   if ( token == "/OPT:LBR")
   {
    optLBRFlag = true;
    continue;
   }

   if ( token.BeginsWith( "/ORDER" ) )
   {
    orderFlag = true;
    continue;
   }
  }


  bool usingIncrementalLinking = false;


  if ( debugFlag || incrementalFlag )
  {
   usingIncrementalLinking = true;
  }


  if ( incrementalNoFlag || optREFFlag || optICFFlag || optLBRFlag || orderFlag )
  {
   usingIncrementalLinking = false;
  }

  if ( usingIncrementalLinking )
  {
   flags |= LINK_FLAG_INCREMENTAL;
  }
 }

 return flags;
}



void LinkerNode::EmitCompilationMessage( const AString & fullArgs ) const
{
 AStackString<> output;
 output += GetDLLOrExe();
 output += ": ";
 output += GetName();
 output += '\n';
 if ( FLog::ShowInfo() || FBuild::Get().GetOptions().m_ShowCommandLines )
 {
  output += m_Linker;
  output += ' ';
  output += fullArgs;
  output += '\n';
 }
 do { FLog::Build( "%s", output.Get() ); } while ( false ); ;
}



void LinkerNode::EmitStampMessage() const
{
 do { if ( !( m_LinkerStampExe ) ) { if ( AssertHandler::Failure( "m_LinkerStampExe", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/LinkerNode.cpp", 587 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;

 AStackString<> output;
 output += "Stamp: ";
 output += GetName();
 output += '\n';
 if ( FLog::ShowInfo() || FBuild::Get().GetOptions().m_ShowCommandLines )
 {
  output += m_LinkerStampExe->GetName();
  output += ' ';
  output += m_LinkerStampExeArgs;
  output += '\n';
 }
 do { FLog::Build( "%s", output.Get() ); } while ( false ); ;
}



            void LinkerNode::Save( IOStream & stream ) const
{

 size_t count = m_StaticDependencies.GetSize() - ( m_AssemblyResources.GetSize() + m_OtherLibraries.GetSize() );
 if ( m_LinkerStampExe )
 {
  count--;
 }
 Dependencies staticDeps( m_StaticDependencies.Begin(), m_StaticDependencies.Begin() + count );

 stream.Write( m_Name );;
 stream.Write( m_Linker );;
 stream.Write( m_LinkerArgs );;
 staticDeps.Save( stream );;
 stream.Write( m_Flags );;
 m_AssemblyResources.Save( stream );;
 m_OtherLibraries.Save( stream );;
    Node::SaveNode( stream, m_LinkerStampExe );;
    stream.Write( m_LinkerStampExeArgs );;
}
# 158 "/home/ffulin/p4/tmp/Unity/Tools/FBuild/FBuildCore/Unity1.cpp" 2


# 1 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/NodeGraph.cpp" 1





# 1 "./Tools/FBuild/FBuildCore/PrecompiledHeader.h" 1
# 7 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/NodeGraph.cpp" 2
# 54 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/NodeGraph.cpp"
           uint32_t NodeGraph::s_BuildPassTag( 0 );



NodeGraph::NodeGraph()
: m_AllNodes( 1024, true )
, m_NextNodeIndex( 0 )
, m_UsedFiles( 16, true )
{
 memset( m_NodeMap, 0, sizeof( Node * ) * NODEMAP_TABLE_SIZE );
}



NodeGraph::~NodeGraph()
{
 Array< Node * >::Iter i = m_AllNodes.Begin();
 Array< Node * >::Iter end = m_AllNodes.End();
 for ( ; i != end; ++i )
 {
  delete ( *i );
 }
}



bool NodeGraph::Initialize( const char * bffFile,
       const char * nodeGraphDBFile )
{
 do { if ( !( bffFile ) ) { if ( AssertHandler::Failure( "bffFile", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/NodeGraph.cpp", 83 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;

 do { if ( !( m_UsedFiles.IsEmpty() ) ) { if ( AssertHandler::Failure( "m_UsedFiles.IsEmpty()", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/NodeGraph.cpp", 85 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;

 bool needReparsing = false;
 bool ok = Load( nodeGraphDBFile, needReparsing );
 if ( !ok )
 {
  do { FLog::Error( "Error reading BFF '%s' (corrupt?)", nodeGraphDBFile ); } while ( false ); ;
  return false;
 }


 if ( needReparsing )
 {

  m_UsedFiles.Clear();


  do { if ( FLog::ShowInfo() ) { FLog::Info( "Loading BFF '%s'", bffFile ); } } while ( false ); ;
  FileStream bffStream;
  if ( bffStream.Open( bffFile ) == false )
  {

   do { FLog::Error( "Failed to open BFF '%s'", bffFile ); } while ( false ); ;
   return false;
  }
  const uint64_t rootBFFTimeStamp = FileIO::GetFileLastWriteTime( AStackString<>( bffFile ) );


  uint32_t size = (uint32_t)bffStream.GetFileSize();
  AutoPtr< char > data( (char *)::AllocFileLine( size + 1, "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/NodeGraph.cpp", 114 ) );
  if ( bffStream.Read( data.Get(), size ) != size )
  {
   do { FLog::Error( "Error reading BFF '%s'", bffFile ); } while ( false ); ;
   return false;
  }


  BFFParser bffParser;
  data.Get()[ size ] = '\0';
  return bffParser.Parse( data.Get(), size, bffFile, rootBFFTimeStamp );
 }

 return true;
}



bool NodeGraph::Load( const char * nodeGraphDBFile, bool & needReparsing )
{
 FileStream fs;
 if ( fs.Open( nodeGraphDBFile, FileStream::READ_ONLY ) == false )
 {
  do { if ( FLog::ShowInfo() ) { FLog::Info( "BFF file '%s' missing or unopenable (clean build will result).", nodeGraphDBFile ); } } while ( false ); ;
  needReparsing = true;
  return true;
 }

 size_t size = (size_t)fs.GetFileSize();
 AutoPtr< void > mem( ::AllocFileLine( size, "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/NodeGraph.cpp", 143 ) );
 if ( fs.Read( mem.Get(), size ) != size )
 {
  return false;
 }


 ConstMemoryStream nodeGraphStream( mem.Get(), size );
 if ( !Load( nodeGraphStream, needReparsing ) )
 {
  do { FLog::Error( "Database is corrupt." ); } while ( false );
  return false;
 }

 return true;
}



bool NodeGraph::Load( IOStream & stream, bool & needReparsing )
{
 bool compatibleDB = true;
 if ( ReadHeaderAndUsedFiles( stream, m_UsedFiles, compatibleDB ) == false )
 {
  return false;
 }


 if ( !compatibleDB )
 {
  do { FLog::Warning( "Database version has changed (clean build will occur)." ); } while ( false ); ;
  needReparsing = true;
  return true;
 }


 for ( size_t i=0; i<m_UsedFiles.GetSize(); ++i )
 {
  const AString & fileName = m_UsedFiles[ i ].m_FileName;
  const uint64_t timeStamp = FileIO::GetFileLastWriteTime( fileName );
  if ( timeStamp != m_UsedFiles[ i ].m_TimeStamp )
  {
   do { FLog::Warning( "BFF file '%s' has changed (reparsing will occur).", fileName.Get() ); } while ( false ); ;
   needReparsing = true;
   return true;
  }
 }


 {

  AStackString<> cachePath;
  if ( stream.Read( cachePath ) == false )
  {
   return false;
  }
  if ( cachePath.IsEmpty() == false )
  {
   FunctionSettings::SetCachePath( cachePath );
   FBuild::Get().SetCachePath( cachePath );
  }


  AStackString<> cachePluginDLL;
  if ( stream.Read( cachePluginDLL ) == false )
  {
   return false;
  }
  FBuild::Get().SetCachePluginDLL( cachePluginDLL );


  uint32_t envStringSize = 0;
  if ( stream.Read( envStringSize ) == false )
  {
   return false;
  }
  if ( envStringSize > 0 )
  {
   AutoPtr< char > envString( (char *)::AllocFileLine( envStringSize, "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/NodeGraph.cpp", 221 ) );
   if ( stream.Read( envString.Get(), envStringSize ) == false )
   {
    return false;
   }
   AStackString<> libEnvVar;
   if ( stream.Read( libEnvVar ) == false )
   {
    return false;
   }
   FBuild::Get().SetEnvironmentString( envString.Get(), envStringSize, libEnvVar );
  }


  uint32_t libEnvVarHashInDB( 0 );
  if ( stream.Read( libEnvVarHashInDB ) == false )
  {
   return false;
  }
  else
  {
   const uint32_t libEnvVarHash = GetLibEnvVarHash();
   if ( libEnvVarHashInDB != libEnvVarHash )
   {

    do { FLog::Warning( "'%s' Environment variable has changed - BFF will be re-parsed\n", "LIB" ); } while ( false ); ;
    needReparsing = true;
    return true;
   }
  }


  Array< AString > workerList( 0, true );
  if ( stream.Read( workerList ) == false )
  {
   return false;
  }
  FBuild::Get().SetWorkerList( workerList );
 }

 do { if ( !( m_AllNodes.GetSize() == 0 ) ) { if ( AssertHandler::Failure( "m_AllNodes.GetSize() == 0", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/NodeGraph.cpp", 261 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;


 uint32_t numNodes;
 if ( stream.Read( numNodes ) == false )
 {
  return false;
 }

 m_AllNodes.SetSize( numNodes );
 memset( m_AllNodes.Begin(), 0, numNodes * sizeof( Node * ) );
 for ( uint32_t i=0; i<numNodes; ++i )
 {
  if ( LoadNode( stream ) == false )
  {
   return false;
  }
 }


 for ( size_t i=0; i<numNodes; ++i )
 {
  do { if ( !( m_AllNodes[ i ] ) ) { if ( AssertHandler::Failure( "m_AllNodes[ i ]", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/NodeGraph.cpp", 283 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;
  do { if ( !( m_AllNodes[ i ]->GetIndex() == i ) ) { if ( AssertHandler::Failure( "m_AllNodes[ i ]->GetIndex() == i", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/NodeGraph.cpp", 284 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;
 }

 return true;
}



bool NodeGraph::LoadNode( IOStream & stream )
{

 uint32_t nodeIndex( ( (uint32_t)0xFFFFFFFF ) );
 if ( stream.Read( nodeIndex ) == false )
 {
  return false;
 }


 do { if ( !( m_AllNodes[ nodeIndex ] == (0) ) ) { if ( AssertHandler::Failure( "m_AllNodes[ nodeIndex ] == nullptr", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/NodeGraph.cpp", 302 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;
 m_NextNodeIndex = nodeIndex;


 Node * n = Node::Load( stream );
 if ( n == (0) )
 {
  return false;
 }


 do { if ( !( m_AllNodes[ nodeIndex ] == n ) ) { if ( AssertHandler::Failure( "m_AllNodes[ nodeIndex ] == n", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/NodeGraph.cpp", 313 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;
 do { if ( !( n->GetIndex() == nodeIndex ) ) { if ( AssertHandler::Failure( "n->GetIndex() == nodeIndex", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/NodeGraph.cpp", 314 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;


 uint32_t lastTimeToBuild;
 if ( stream.Read( lastTimeToBuild ) == false )
 {
  return false;
 }
 n->SetLastBuildTime( lastTimeToBuild );

 return true;
}



void NodeGraph::Save( IOStream & stream ) const
{

 NodeGraphHeader header;
 stream.Write( (const void *)&header, sizeof( header ) );


 uint32_t numUsedFiles = (uint32_t)m_UsedFiles.GetSize();
 stream.Write( numUsedFiles );

 for ( uint32_t i=0; i<numUsedFiles; ++i )
 {
  const AString & fileName = m_UsedFiles[ i ].m_FileName;
  uint32_t fileNameLen( fileName.GetLength() );
  stream.Write( fileNameLen );
  stream.Write( fileName.Get(), fileNameLen );
  uint64_t timeStamp( m_UsedFiles[ i ].m_TimeStamp );
  stream.Write( timeStamp );
 }


 {

  stream.Write( FunctionSettings::GetCachePath() );
  stream.Write( FBuild::Get().GetCachePluginDLL() );


  const uint32_t envStringSize = FBuild::Get().GetEnvironmentStringSize();
  stream.Write( envStringSize );
  if ( envStringSize > 0 )
  {
   const char * envString = FBuild::Get().GetEnvironmentString();
   stream.Write( envString, envStringSize );

   AStackString<> libEnvVar;
   FBuild::Get().GetLibEnvVar( libEnvVar );
   stream.Write( libEnvVar );
  }


  const uint32_t libEnvVarHash = GetLibEnvVarHash();
  stream.Write( libEnvVarHash );


  const Array< AString > & workerList = FBuild::Get().GetWorkerList();
  stream.Write( workerList );
 }


 size_t numNodes = m_AllNodes.GetSize();
 stream.Write( (uint32_t)numNodes );


 Array< bool > savedNodeFlags( numNodes, false );
 savedNodeFlags.SetSize( numNodes );
 memset( savedNodeFlags.Begin(), 0, numNodes );
 for ( size_t i=0; i<numNodes; ++i )
 {
  SaveRecurse( stream, m_AllNodes[ i ], savedNodeFlags );
 }


 for ( size_t i=0; i<numNodes; ++i )
 {
  do { if ( !( savedNodeFlags[ i ] == true ) ) { if ( AssertHandler::Failure( "savedNodeFlags[ i ] == true", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/NodeGraph.cpp", 393 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;
 }
}



           void NodeGraph::SaveRecurse( IOStream & stream, Node * node, Array< bool > & savedNodeFlags )
{

 uint32_t nodeIndex = node->GetIndex();
 do { if ( !( nodeIndex != ( (uint32_t)0xFFFFFFFF ) ) ) { if ( AssertHandler::Failure( "nodeIndex != INVALID_NODE_INDEX", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/NodeGraph.cpp", 403 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;
 if ( savedNodeFlags[ nodeIndex ] )
 {
  return;
 }


 SaveRecurse( stream, node->GetPreBuildDependencies(), savedNodeFlags );
 SaveRecurse( stream, node->GetStaticDependencies(), savedNodeFlags );
 SaveRecurse( stream, node->GetDynamicDependencies(), savedNodeFlags );


 do { if ( !( savedNodeFlags[ nodeIndex ] == false ) ) { if ( AssertHandler::Failure( "savedNodeFlags[ nodeIndex ] == false", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/NodeGraph.cpp", 415 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;


 stream.Write( nodeIndex );


 Node::Save( stream, node );


 uint32_t lastBuildTime = node->GetLastBuildTime();
 stream.Write( lastBuildTime );

 savedNodeFlags[ nodeIndex ] = true;
}



           void NodeGraph::SaveRecurse( IOStream & stream, const Dependencies & dependencies, Array< bool > & savedNodeFlags )
{
 const Dependency * const end = dependencies.End();
 for ( const Dependency * it = dependencies.Begin(); it != end; ++it )
 {
  Node * n = it->GetNode();
  SaveRecurse( stream, n, savedNodeFlags );
 }
}



Node * NodeGraph::FindNode( const AString & nodeName ) const
{

 Node * n = FindNodeInternal( nodeName );
 if ( n )
 {
  return n;
 }


 AStackString< 1024 > fullPath;
 CleanPath( nodeName, fullPath );
 return FindNodeInternal( fullPath );
}



Node * NodeGraph::GetNodeByIndex( uint32_t index ) const
{
 Node * n = m_AllNodes[ index ];
 do { if ( !( n ) ) { if ( AssertHandler::Failure( "n", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/NodeGraph.cpp", 464 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;
 return n;
}



CopyNode * NodeGraph::CreateCopyNode( const AString & dstFileName,
           Node * sourceFile,
           const Dependencies & preBuildDependencies )
{
 do { if ( !( Thread::IsMainThread() ) ) { if ( AssertHandler::Failure( "Thread::IsMainThread()", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/NodeGraph.cpp", 474 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;
 do { if ( !( sourceFile->IsAFile() ) ) { if ( AssertHandler::Failure( "sourceFile->IsAFile()", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/NodeGraph.cpp", 475 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;

 AStackString< 1024 > fullPathDst;
 CleanPath( dstFileName, fullPathDst );

 CopyNode * node = new ( "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/NodeGraph.cpp", 480 ) CopyNode( fullPathDst, (FileNode *)sourceFile, preBuildDependencies );
 AddNode( node );
 return node;
}



CopyDirNode * NodeGraph::CreateCopyDirNode( const AString & nodeName,
           Dependencies & staticDeps,
           const AString & destPath,
           const Dependencies & preBuildDependencies )
{
 do { if ( !( Thread::IsMainThread() ) ) { if ( AssertHandler::Failure( "Thread::IsMainThread()", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/NodeGraph.cpp", 492 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;

 CopyDirNode * node = new ( "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/NodeGraph.cpp", 494 ) CopyDirNode( nodeName, staticDeps, destPath, preBuildDependencies );
 AddNode( node );
 return node;
}



ExecNode * NodeGraph::CreateExecNode( const AString & dstFileName,
           FileNode * sourceFile,
           FileNode * executable,
           const AString & arguments,
           const AString & workingDir,
           int32_t expectedReturnCode,
           const Dependencies & preBuildDependencies )
{
 do { if ( !( Thread::IsMainThread() ) ) { if ( AssertHandler::Failure( "Thread::IsMainThread()", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/NodeGraph.cpp", 509 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;

 AStackString< 512 > fullPath;
 CleanPath( dstFileName, fullPath );

 ExecNode * node = new ( "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/NodeGraph.cpp", 514 ) ExecNode( fullPath, sourceFile, executable, arguments, workingDir, expectedReturnCode, preBuildDependencies );
 AddNode( node );
 return node;
}



FileNode * NodeGraph::CreateFileNode( const AString & fileName, bool cleanPath )
{
 do { if ( !( Thread::IsMainThread() ) ) { if ( AssertHandler::Failure( "Thread::IsMainThread()", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/NodeGraph.cpp", 523 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;

 FileNode * node;

 if ( cleanPath )
 {
  AStackString< 512 > fullPath;
  CleanPath( fileName, fullPath );
  node = new ( "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/NodeGraph.cpp", 531 ) FileNode( fullPath );
 }
 else
 {
  node = new ( "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/NodeGraph.cpp", 535 ) FileNode( fileName );
 }

 AddNode( node );
 return node;
}



DirectoryListNode * NodeGraph::CreateDirectoryListNode( const AString & name,
                 const AString & path,
                 const AString & wildCard,
                 bool recursive,
                 const Array< AString > & excludePaths )
{
 do { if ( !( Thread::IsMainThread() ) ) { if ( AssertHandler::Failure( "Thread::IsMainThread()", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/NodeGraph.cpp", 550 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;




 DirectoryListNode * node = new ( "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/NodeGraph.cpp", 555 ) DirectoryListNode( name, path, wildCard, recursive, excludePaths );
 AddNode( node );
 return node;
}



LibraryNode * NodeGraph::CreateLibraryNode( const AString & libraryName,
              const Dependencies & inputNodes,
           CompilerNode * compiler,
           const AString & compilerArgs,
           const AString & compilerArgsDeoptimized,
           const AString & compilerOutputPath,
           const AString & linker,
           const AString & linkerArgs,
           uint32_t flags,
           ObjectNode * precompiledHeader,
           const Dependencies & compilerForceUsing,
           const Dependencies & preBuildDependencies,
           const Dependencies & additionalInputs,
           bool deoptimizeWritableFiles,
           bool deoptimizeWritableFilesWithToken )
{
 do { if ( !( Thread::IsMainThread() ) ) { if ( AssertHandler::Failure( "Thread::IsMainThread()", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/NodeGraph.cpp", 578 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;

 AStackString< 1024 > fullPath;
 CleanPath( libraryName, fullPath );

 LibraryNode * node = new (
# 597 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/NodeGraph.cpp"
 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/NodeGraph.cpp"
# 583 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/NodeGraph.cpp"
                      ,
# 597 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/NodeGraph.cpp"
 597
# 583 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/NodeGraph.cpp"
                      ) LibraryNode( fullPath, inputNodes, compiler, compilerArgs, compilerArgsDeoptimized, compilerOutputPath, linker, linkerArgs, flags, precompiledHeader, compilerForceUsing, preBuildDependencies, additionalInputs, deoptimizeWritableFiles, deoptimizeWritableFilesWithToken )
# 597 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/NodeGraph.cpp"
                                                ;
 AddNode( node );
 return node;
}



ObjectNode * NodeGraph::CreateObjectNode( const AString & objectName,
            Node * inputNode,
            Node * compilerNode,
            const AString & compilerArgs,
            const AString & compilerArgsDeoptimized,
            Node * precompiledHeader,
            uint32_t flags,
            const Dependencies & compilerForceUsing,
            bool deoptimizeWritableFiles,
            bool deoptimizeWritableFilesWithToken )
{
 do { if ( !( Thread::IsMainThread() ) ) { if ( AssertHandler::Failure( "Thread::IsMainThread()", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/NodeGraph.cpp", 615 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;

 AStackString< 512 > fullPath;
 CleanPath( objectName, fullPath );

 ObjectNode * node = new ( "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/NodeGraph.cpp", 620 ) ObjectNode( fullPath, inputNode, compilerNode, compilerArgs, compilerArgsDeoptimized, precompiledHeader, flags, compilerForceUsing, deoptimizeWritableFiles, deoptimizeWritableFilesWithToken );
 AddNode( node );
 return node;
}



AliasNode * NodeGraph::CreateAliasNode( const AString & aliasName,
          const Dependencies & targets )
{
 do { if ( !( Thread::IsMainThread() ) ) { if ( AssertHandler::Failure( "Thread::IsMainThread()", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/NodeGraph.cpp", 630 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;

 AliasNode * node = new ( "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/NodeGraph.cpp", 632 ) AliasNode( aliasName, targets );
 AddNode( node );
 return node;
}



DLLNode * NodeGraph::CreateDLLNode( const AString & linkerOutputName,
         const Dependencies & inputLibraries,
            const Dependencies & otherLibraries,
         const AString & linker,
         const AString & linkerArgs,
         uint32_t flags,
         const Dependencies & assemblyResources,
         const AString & importLibName,
         Node * linkerStampExe,
         const AString & linkerStampExeArgs )
{
 do { if ( !( Thread::IsMainThread() ) ) { if ( AssertHandler::Failure( "Thread::IsMainThread()", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/NodeGraph.cpp", 650 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;
 do { if ( !( inputLibraries.IsEmpty() == false ) ) { if ( AssertHandler::Failure( "inputLibraries.IsEmpty() == false", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/NodeGraph.cpp", 651 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;

 AStackString< 1024 > fullPath;
 CleanPath( linkerOutputName, fullPath );

 DLLNode * node = new (
# 665 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/NodeGraph.cpp"
 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/NodeGraph.cpp"
# 656 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/NodeGraph.cpp"
                  ,
# 665 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/NodeGraph.cpp"
 665
# 656 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/NodeGraph.cpp"
                  ) DLLNode( fullPath, inputLibraries, otherLibraries, linker, linkerArgs, flags, assemblyResources, importLibName, linkerStampExe, linkerStampExeArgs )
# 665 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/NodeGraph.cpp"
                                ;
 AddNode( node );
 return node;
}



ExeNode * NodeGraph::CreateExeNode( const AString & linkerOutputName,
         const Dependencies & inputLibraries,
            const Dependencies & otherLibraries,
         const AString & linker,
         const AString & linkerArgs,
         uint32_t flags,
         const Dependencies & assemblyResources,
         Node * linkerStampExe,
         const AString & linkerStampExeArgs )
{
 do { if ( !( Thread::IsMainThread() ) ) { if ( AssertHandler::Failure( "Thread::IsMainThread()", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/NodeGraph.cpp", 682 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;

 AStackString< 1024 > fullPath;
 CleanPath( linkerOutputName, fullPath );

 ExeNode * node = new (







 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/NodeGraph.cpp"
# 687 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/NodeGraph.cpp"
                  ,







 695
# 687 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/NodeGraph.cpp"
                  ) ExeNode( fullPath, inputLibraries, otherLibraries, linker, linkerArgs, flags, assemblyResources, linkerStampExe, linkerStampExeArgs )







                                ;
 AddNode( node );
 return node;
}



UnityNode * NodeGraph::CreateUnityNode( const AString & unityName,
          const Dependencies & dirNodes,
          const Array< AString > & files,
          const AString & outputPath,
          const AString & outputPattern,
          uint32_t numUnityFilesToCreate,
          const AString & precompiledHeader,
          const Array< AString > & pathsToExclude,
          const Array< AString > & filesToExclude,
          bool isolateWritableFiles,
          uint32_t maxIsolatedFiles,
          const Array< AString > & excludePatterns )
{
 do { if ( !( Thread::IsMainThread() ) ) { if ( AssertHandler::Failure( "Thread::IsMainThread()", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/NodeGraph.cpp", 715 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;

 UnityNode * node = new (
# 728 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/NodeGraph.cpp"
 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/NodeGraph.cpp"
# 717 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/NodeGraph.cpp"
                    ,
# 728 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/NodeGraph.cpp"
 728
# 717 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/NodeGraph.cpp"
                    ) UnityNode( unityName, dirNodes, files, outputPath, outputPattern, numUnityFilesToCreate, precompiledHeader, pathsToExclude, filesToExclude, isolateWritableFiles, maxIsolatedFiles, excludePatterns )
# 728 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/NodeGraph.cpp"
                             ;
 AddNode( node );
 return node;
}

CSNode * NodeGraph::CreateCSNode( const AString & compilerOutput,
          const Dependencies & inputNodes,
          const AString & compiler,
          const AString & compilerOptions,
          const Dependencies & extraRefs )
{
 do { if ( !( Thread::IsMainThread() ) ) { if ( AssertHandler::Failure( "Thread::IsMainThread()", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/NodeGraph.cpp", 739 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;
 do { if ( !( inputNodes.IsEmpty() == false ) ) { if ( AssertHandler::Failure( "inputNodes.IsEmpty() == false", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/NodeGraph.cpp", 740 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;

 AStackString< 1024 > fullPath;
 CleanPath( compilerOutput, fullPath );

 CSNode * node = new (



 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/NodeGraph.cpp"
# 745 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/NodeGraph.cpp"
                 ,



 749
# 745 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/NodeGraph.cpp"
                 ) CSNode( fullPath, inputNodes, compiler, compilerOptions, extraRefs )



                     ;
 AddNode( node );
 return node;
}



TestNode * NodeGraph::CreateTestNode( const AString & testOutput,
           FileNode * testExecutable,
           const AString & arguments,
           const AString & workingDir )
{
 do { if ( !( Thread::IsMainThread() ) ) { if ( AssertHandler::Failure( "Thread::IsMainThread()", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/NodeGraph.cpp", 761 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;

 AStackString< 1024 > fullPath;
 CleanPath( testOutput, fullPath );

 TestNode * node = new (


 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/NodeGraph.cpp"
# 766 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/NodeGraph.cpp"
                   ,


 769
# 766 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/NodeGraph.cpp"
                   ) TestNode( fullPath, testExecutable, arguments, workingDir )


                       ;
 AddNode( node );
 return node;
}



CompilerNode * NodeGraph::CreateCompilerNode( const AString & executable,
             const Dependencies & extraFiles,
             bool allowDistribution )
{
 do { if ( !( Thread::IsMainThread() ) ) { if ( AssertHandler::Failure( "Thread::IsMainThread()", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/NodeGraph.cpp", 780 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;

 AStackString< 1024 > fullPath;
 CleanPath( executable, fullPath );

 CompilerNode * node = new ( "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/NodeGraph.cpp", 785 ) CompilerNode( fullPath, extraFiles, allowDistribution );
 AddNode( node );
 return node;
}



VCXProjectNode * NodeGraph::CreateVCXProjectNode( const AString & projectOutput,
              const Array< AString > & projectBasePaths,
              const Dependencies & paths,
              const Array< AString > & pathsToExclude,
              const Array< AString > & allowedFileExtensions,
              const Array< AString > & files,
              const Array< AString > & filesToExclude,
              const AString & rootNamespace,
              const AString & projectGuid,
              const AString & defaultLanguage,
              const AString & applicationEnvironment,
              const Array< VSProjectConfig > & configs,
              const Array< VSProjectFileType > & fileTypes,
              const Array< AString > & references,
              const Array< AString > & projectReferences )
{
 do { if ( !( Thread::IsMainThread() ) ) { if ( AssertHandler::Failure( "Thread::IsMainThread()", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/NodeGraph.cpp", 808 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;

 AStackString< 1024 > fullPath;
 CleanPath( projectOutput, fullPath );

 VCXProjectNode * node = new (
# 827 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/NodeGraph.cpp"
 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/NodeGraph.cpp"
# 813 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/NodeGraph.cpp"
                         ,
# 827 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/NodeGraph.cpp"
 827
# 813 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/NodeGraph.cpp"
                         ) VCXProjectNode( fullPath, projectBasePaths, paths, pathsToExclude, allowedFileExtensions, files, filesToExclude, rootNamespace, projectGuid, defaultLanguage, applicationEnvironment, configs, fileTypes, references, projectReferences )
# 827 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/NodeGraph.cpp"
                                 ;
 AddNode( node );
 return node;
}



ObjectListNode * NodeGraph::CreateObjectListNode( const AString & listName,
              const Dependencies & inputNodes,
              CompilerNode * compiler,
              const AString & compilerArgs,
              const AString & compilerArgsDeoptimized,
              const AString & compilerOutputPath,
              ObjectNode * precompiledHeader,
              const Dependencies & compilerForceUsing,
              const Dependencies & preBuildDependencies,
              bool deoptimizeWritableFiles,
              bool deoptimizeWritableFilesWithToken )
{
 do { if ( !( Thread::IsMainThread() ) ) { if ( AssertHandler::Failure( "Thread::IsMainThread()", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/NodeGraph.cpp", 846 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;

 ObjectListNode * node = new (
# 858 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/NodeGraph.cpp"
 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/NodeGraph.cpp"
# 848 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/NodeGraph.cpp"
                         ,
# 858 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/NodeGraph.cpp"
 858
# 848 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/NodeGraph.cpp"
                         ) ObjectListNode( listName, inputNodes, compiler, compilerArgs, compilerArgsDeoptimized, compilerOutputPath, precompiledHeader, compilerForceUsing, preBuildDependencies, deoptimizeWritableFiles, deoptimizeWritableFilesWithToken )
# 858 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/NodeGraph.cpp"
                                                ;
 AddNode( node );
 return node;

}



void NodeGraph::AddNode( Node * node )
{
 do { if ( !( Thread::IsMainThread() ) ) { if ( AssertHandler::Failure( "Thread::IsMainThread()", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/NodeGraph.cpp", 868 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;

 do { if ( !( node ) ) { if ( AssertHandler::Failure( "node", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/NodeGraph.cpp", 870 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;

 do { if ( !( FindNodeInternal( node->GetName() ) == (0) ) ) { if ( AssertHandler::Failure( "FindNodeInternal( node->GetName() ) == nullptr", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/NodeGraph.cpp", 872 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;


 const uint32_t crc = CRC32::CalcLower( node->GetName() );
 const size_t key = ( crc & 0xFFFF );
 node->m_Next = m_NodeMap[ key ];
 m_NodeMap[ key ] = node;


 if ( m_NextNodeIndex == m_AllNodes.GetSize() )
 {

  m_AllNodes.Append( node );
 }
 else
 {

  do { if ( !( m_AllNodes[ m_NextNodeIndex ] == (0) ) ) { if ( AssertHandler::Failure( "m_AllNodes[ m_NextNodeIndex ] == nullptr", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/NodeGraph.cpp", 889 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;
  m_AllNodes[ m_NextNodeIndex ] = node;
 }


 node->SetIndex( m_NextNodeIndex );
 m_NextNodeIndex = (uint32_t)m_AllNodes.GetSize();
}



void NodeGraph::DoBuildPass( Node * nodeToBuild )
{
 s_BuildPassTag++;

 if ( nodeToBuild->GetType() == Node::PROXY_NODE )
 {
  const size_t total = nodeToBuild->GetStaticDependencies().GetSize();
  size_t failedCount = 0;
  size_t upToDateCount = 0;
  const Dependency * const end = nodeToBuild->GetStaticDependencies().End();
  for ( const Dependency * it = nodeToBuild->GetStaticDependencies().Begin(); it != end; ++it )
  {
   Node * n = it->GetNode();
   if ( n->GetState() == Node::FAILED )
   {
    failedCount++;
    continue;
   }
   else if ( n->GetState() == Node::UP_TO_DATE )
   {
    upToDateCount++;
    continue;
   }
   if ( n->GetState() != Node::BUILDING )
   {
    BuildRecurse( n );
   }
  }


  if ( ( upToDateCount + failedCount ) == total )
  {

   nodeToBuild->SetState( failedCount ? Node::FAILED : Node::UP_TO_DATE );
  }
 }
 else
 {
  if ( nodeToBuild->GetState() != Node::BUILDING )
  {
   BuildRecurse( nodeToBuild );
  }
 }
}



           void NodeGraph::BuildRecurse( Node * nodeToBuild )
{
 do { if ( !( nodeToBuild ) ) { if ( AssertHandler::Failure( "nodeToBuild", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/NodeGraph.cpp", 949 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;


 do { if ( !( nodeToBuild->GetState() != Node::BUILDING ) ) { if ( AssertHandler::Failure( "nodeToBuild->GetState() != Node::BUILDING", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/NodeGraph.cpp", 952 ) ) { __asm__ __volatile__("int $3"); } } } while ( false );


 if ( nodeToBuild->GetState() == Node::NOT_PROCESSED )
 {

  bool allDependenciesUpToDate = CheckDependencies( nodeToBuild, nodeToBuild->GetPreBuildDependencies() );
  if ( allDependenciesUpToDate == false )
  {
   return;
  }

  nodeToBuild->SetState( Node::PRE_DEPS_READY );
 }

 do { if ( !( ( nodeToBuild->GetState() == Node::PRE_DEPS_READY ) || ( nodeToBuild->GetState() == Node::STATIC_DEPS_READY ) || ( nodeToBuild->GetState() == Node::DYNAMIC_DEPS_DONE ) ) ) { if ( AssertHandler::Failure( "( nodeToBuild->GetState() == Node::PRE_DEPS_READY ) || ( nodeToBuild->GetState() == Node::STATIC_DEPS_READY ) || ( nodeToBuild->GetState() == Node::DYNAMIC_DEPS_DONE )",

 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/NodeGraph.cpp"
# 967 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/NodeGraph.cpp"
 ,

 969
# 967 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/NodeGraph.cpp"
 ) ) { __asm__ __volatile__("int $3"); } } } while ( false );

                                                           ;


 if ( nodeToBuild->GetState() == Node::PRE_DEPS_READY )
 {

  bool allDependenciesUpToDate = CheckDependencies( nodeToBuild, nodeToBuild->GetStaticDependencies() );
  if ( allDependenciesUpToDate == false )
  {
   return;
  }

  nodeToBuild->SetState( Node::STATIC_DEPS_READY );
 }

 do { if ( !( ( nodeToBuild->GetState() == Node::STATIC_DEPS_READY ) || ( nodeToBuild->GetState() == Node::DYNAMIC_DEPS_DONE ) ) ) { if ( AssertHandler::Failure( "( nodeToBuild->GetState() == Node::STATIC_DEPS_READY ) || ( nodeToBuild->GetState() == Node::DYNAMIC_DEPS_DONE )",
 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/NodeGraph.cpp"
# 984 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/NodeGraph.cpp"
 ,
 985
# 984 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/NodeGraph.cpp"
 ) ) { __asm__ __volatile__("int $3"); } } } while ( false );
                                                           ;

 if ( nodeToBuild->GetState() != Node::DYNAMIC_DEPS_DONE )
 {

  bool forceClean = FBuild::Get().GetOptions().m_ForceCleanBuild;
  if ( nodeToBuild->DoDynamicDependencies( forceClean ) == false )
  {
   nodeToBuild->SetState( Node::FAILED );
   return;
  }

  nodeToBuild->SetState( Node::DYNAMIC_DEPS_DONE );
 }

 do { if ( !( nodeToBuild->GetState() == Node::DYNAMIC_DEPS_DONE ) ) { if ( AssertHandler::Failure( "nodeToBuild->GetState() == Node::DYNAMIC_DEPS_DONE", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/NodeGraph.cpp", 1000 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;


 {

  bool allDependenciesUpToDate = CheckDependencies( nodeToBuild, nodeToBuild->GetDynamicDependencies() );
  if ( allDependenciesUpToDate == false )
  {
   return;
  }
 }



 bool forceClean = FBuild::Get().GetOptions().m_ForceCleanBuild;
 nodeToBuild->SetStatFlag( Node::STATS_PROCESSED );
 if ( nodeToBuild->DetermineNeedToBuild( forceClean ) )
 {
  JobQueue::Get().QueueJob( nodeToBuild );
 }
 else
 {
  nodeToBuild->SetState( Node::UP_TO_DATE );
 }
}



           bool NodeGraph::CheckDependencies( Node * nodeToBuild, const Dependencies & dependencies )
{
 do { if ( !( nodeToBuild->GetType() != Node::PROXY_NODE ) ) { if ( AssertHandler::Failure( "nodeToBuild->GetType() != Node::PROXY_NODE", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/NodeGraph.cpp", 1030 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;

 const uint32_t passTag = s_BuildPassTag;

 bool allDependenciesUpToDate = true;

 Dependencies::Iter i = dependencies.Begin();
 Dependencies::Iter end = dependencies.End();
 for ( ; i < end; ++i )
 {
  Node * n = i->GetNode();

  Node::State state = n->GetState();


  if ( state < Node::BUILDING )
  {

   if ( n->GetBuildPassTag() != passTag )
   {

    n->SetBuildPassTag( passTag );

    BuildRecurse( n );
   }
  }


  state = n->GetState();
  if ( state == Node::UP_TO_DATE )
  {
   continue;
  }

  allDependenciesUpToDate = false;


  if ( state == Node::FAILED )
  {

   nodeToBuild->SetState( Node::FAILED );
   break;
  }


 }

 return allDependenciesUpToDate;
}



           void NodeGraph::CleanPath( const AString & name, AString & fullPath )
{
 do { if ( !( &name != &fullPath ) ) { if ( AssertHandler::Failure( "&name != &fullPath", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/NodeGraph.cpp", 1084 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;

 char * dst;


    bool isFullPath = PathUtils::IsFullPath( name );
 if ( !isFullPath )
 {

  const AString & workingDir = FBuild::Get().GetWorkingDir();


        do { if ( !( workingDir.Find( ( '\\' ) ) == (0) ) ) { if ( AssertHandler::Failure( "workingDir.Find( OTHER_SLASH ) == nullptr", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/NodeGraph.cpp", 1096 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;
        do { if ( !( workingDir.Find( ( "//" ) ) == (0) ) ) { if ( AssertHandler::Failure( "workingDir.Find( NATIVE_DOUBLE_SLASH ) == nullptr", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/NodeGraph.cpp", 1097 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;


  fullPath = workingDir;
  fullPath += ( '/' );


  uint32_t len = fullPath.GetLength();


  fullPath.SetLength( fullPath.GetLength() + name.GetLength() );


  dst = fullPath.Get() + len;
 }
 else
 {

  fullPath.SetLength( name.GetLength() );


  dst = fullPath.Get();
 }


 const char * src = name.Get();
 const char * const srcEnd = name.GetEnd();


 char lastChar = ( '/' );



 while ( src < srcEnd )
 {
  const char thisChar = *src;


  if ( ( thisChar == ( '/' ) ) || ( thisChar == ( '\\' ) ) )
  {

   *dst = ( '/' );
   dst++;


   while ( ( *src == ( '/' ) ) || ( *src == ( '\\' ) ) )
   {
    src++;
   }
   lastChar = ( '/' );
   continue;
  }
  else if ( thisChar == '.' )
  {
   if ( lastChar == ( '/' ) )
   {

    char nextChar = *( src + 1 );
    if ( ( nextChar == ( '/' ) ) || ( nextChar == ( '\\' ) ) )
    {
     src++;
     while ( ( *src == ( '/' ) ) || ( *src == ( '\\' ) ) )
     {
      ++src;
     }
     continue;
    }


    if ( nextChar == '.' )
    {
     nextChar = *( src + 2 );
     if ( ( nextChar == ( '/' ) ) || ( nextChar == ( '\\' ) ) )
     {
      src+=2;
      while ( ( *src == ( '/' ) ) || ( *src == ( '\\' ) ) )
      {
       ++src;
      }

      if ( dst > fullPath.Get() + 3 )
      {
       --dst;





                                while ( dst > fullPath.Get() + 1 )

       {
        --dst;
        if ( *dst == ( '/' ) )
        {
         ++dst;
         break;
        }
       }
      }

      continue;
     }
    }
   }
  }


  *dst++ = *src++;
  lastChar = thisChar;
 }


 fullPath.SetLength( (uint16_t)( dst - fullPath.Get() ) );
 do { if ( !( AString::StrLen( fullPath.Get() ) == fullPath.GetLength() ) ) { if ( AssertHandler::Failure( "AString::StrLen( fullPath.Get() ) == fullPath.GetLength()", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/NodeGraph.cpp", 1210 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;


    do { if ( !( fullPath.Find( ( '\\' ) ) == (0) ) ) { if ( AssertHandler::Failure( "fullPath.Find( OTHER_SLASH ) == nullptr", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/NodeGraph.cpp", 1213 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;
    do { if ( !( fullPath.Find( ( "//" ) ) == (0) ) ) { if ( AssertHandler::Failure( "fullPath.Find( NATIVE_DOUBLE_SLASH ) == nullptr", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/NodeGraph.cpp", 1214 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;
}



void NodeGraph::AddUsedFile( const AString & fileName, uint64_t timeStamp )
{
 const size_t numFiles = m_UsedFiles.GetSize();
 for ( size_t i=0 ;i<numFiles; ++i )
 {
  if ( PathUtils::ArePathsEqual( m_UsedFiles[i].m_FileName, fileName ) )
  {
   do { if ( !( m_UsedFiles[ i ].m_Once == false ) ) { if ( AssertHandler::Failure( "m_UsedFiles[ i ].m_Once == false", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/NodeGraph.cpp", 1226 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;
   return;
  }
 }
 m_UsedFiles.Append( UsedFile( fileName, timeStamp ) );
}



bool NodeGraph::IsOneUseFile( const AString & fileName ) const
{
 const size_t numFiles = m_UsedFiles.GetSize();
 do { if ( !( numFiles ) ) { if ( AssertHandler::Failure( "numFiles", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/NodeGraph.cpp", 1238 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;
 for ( size_t i=0 ;i<numFiles; ++i )
 {
  if ( PathUtils::ArePathsEqual( m_UsedFiles[i].m_FileName, fileName ) )
  {
   return m_UsedFiles[ i ].m_Once;
  }
 }



 return false;
}



void NodeGraph::SetCurrentFileAsOneUse()
{
 do { if ( !( !m_UsedFiles.IsEmpty() ) ) { if ( AssertHandler::Failure( "!m_UsedFiles.IsEmpty()", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/NodeGraph.cpp", 1256 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;
 m_UsedFiles[ m_UsedFiles.GetSize() - 1 ].m_Once = true;
}



Node * NodeGraph::FindNodeInternal( const AString & fullPath ) const
{
 do { if ( !( Thread::IsMainThread() ) ) { if ( AssertHandler::Failure( "Thread::IsMainThread()", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/NodeGraph.cpp", 1264 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;

 const uint32_t crc = CRC32::CalcLower( fullPath );
 const size_t key = ( crc & 0xFFFF );

 Node * n = m_NodeMap[ key ];
 while ( n )
 {
  if ( n->GetNameCRC() == crc )
  {
   if ( n->GetName().CompareI( fullPath ) == 0 )
   {
    return n;
   }
  }
  n = n->m_Next;
 }
 return (0);
}



           void NodeGraph::UpdateBuildStatus( const Node * node,
             uint32_t & nodesBuiltTime,
             uint32_t & totalNodeTime )
{
 s_BuildPassTag++;
 UpdateBuildStatusRecurse( node, nodesBuiltTime, totalNodeTime );
}



           void NodeGraph::UpdateBuildStatusRecurse( const Node * node,
              uint32_t & nodesBuiltTime,
              uint32_t & totalNodeTime )
{

 uint32_t nodeTime = node->GetLastBuildTime();
 totalNodeTime += nodeTime;
 nodesBuiltTime += ( node->GetState() == Node::UP_TO_DATE ) ? nodeTime : 0;


 uint32_t accumulatedProgress = node->GetProgressAccumulator();
 if ( accumulatedProgress > 0 )
 {
  nodesBuiltTime += accumulatedProgress;
  totalNodeTime += accumulatedProgress;
  return;
 }


 const uint32_t buildPassTag = s_BuildPassTag;
 if ( node->GetBuildPassTag() == buildPassTag )
 {
  return;
 }
 node->SetBuildPassTag( buildPassTag );



 uint32_t progress = 0;
 uint32_t total = 0;

 UpdateBuildStatusRecurse( node->GetPreBuildDependencies(), progress, total );
 UpdateBuildStatusRecurse( node->GetStaticDependencies(), progress, total );
 UpdateBuildStatusRecurse( node->GetDynamicDependencies(), progress, total );

 nodesBuiltTime += progress;
 totalNodeTime += total;



 if ( node->GetState() >= Node::BUILDING )
 {
  node->SetProgressAccumulator(total);
 }
}



           void NodeGraph::UpdateBuildStatusRecurse( const Dependencies & dependencies,
              uint32_t & nodesBuiltTime,
              uint32_t & totalNodeTime )
{
 for ( Dependencies::Iter i = dependencies.Begin();
  i != dependencies.End();
  i++ )
 {
  UpdateBuildStatusRecurse( i->GetNode(), nodesBuiltTime, totalNodeTime );
 }
}



bool NodeGraph::ReadHeaderAndUsedFiles( IOStream & nodeGraphStream, Array< UsedFile > & files, bool & compatibleDB ) const
{

 NodeGraphHeader ngh;
 if ( ( nodeGraphStream.Read( &ngh, sizeof( ngh ) ) != sizeof( ngh ) ) ||
   ( ngh.IsValid() == false ) )
 {
  return false;
 }


 if ( ngh.IsCompatibleVersion() == false )
 {
  compatibleDB = false;
  return true;
 }

 uint32_t numFiles = 0;
 if ( !nodeGraphStream.Read( numFiles ) )
 {
  return false;
 }

 for ( uint32_t i=0; i<numFiles; ++i )
 {
  uint32_t fileNameLen( 0 );
  if ( !nodeGraphStream.Read( fileNameLen ) )
  {
   return false;
  }
  AStackString<> fileName;
  fileName.SetLength( fileNameLen );
  if ( nodeGraphStream.Read( fileName.Get(), fileNameLen ) != fileNameLen )
  {
   return false;
  }
  uint64_t timeStamp;
  if ( !nodeGraphStream.Read( timeStamp ) )
  {
   return false;
  }

  files.Append( UsedFile( fileName, timeStamp ) );
 }

 return true;
}



uint32_t NodeGraph::GetLibEnvVarHash() const
{

 AStackString<> libVar;
 FBuild::Get().GetLibEnvVar( libVar );
 if ( libVar.IsEmpty() )
 {
  return 0;
 }

 return Murmur3::Calc32( libVar );
}
# 161 "/home/ffulin/p4/tmp/Unity/Tools/FBuild/FBuildCore/Unity1.cpp" 2


# 1 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/VCXProjectNode.cpp" 1





# 1 "./Tools/FBuild/FBuildCore/PrecompiledHeader.h" 1
# 7 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/VCXProjectNode.cpp" 2
# 29 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/VCXProjectNode.cpp"
VCXProjectNode::VCXProjectNode( const AString & projectOutput,
        const Array< AString > & projectBasePaths,
        const Dependencies & paths,
        const Array< AString > & pathsToExclude,
        const Array< AString > & allowedFileExtensions,
        const Array< AString > & files,
        const Array< AString > & filesToExclude,
        const AString & rootNamespace,
        const AString & projectGuid,
        const AString & defaultLanguage,
        const AString & applicationEnvironment,
        const Array< VSProjectConfig > & configs,
        const Array< VSProjectFileType > & fileTypes,
           const Array< AString > & references,
        const Array< AString > & projectReferences )
: FileNode( projectOutput, Node::FLAG_NONE )
, m_ProjectBasePaths( projectBasePaths )
, m_PathsToExclude( pathsToExclude )
, m_AllowedFileExtensions( allowedFileExtensions )
, m_Files( files )
, m_FilesToExclude( filesToExclude )
, m_RootNamespace( rootNamespace )
, m_ProjectGuid( projectGuid )
, m_DefaultLanguage( defaultLanguage )
, m_ApplicationEnvironment( applicationEnvironment )
, m_Configs( configs )
, m_FileTypes( fileTypes )
, m_References( references )
, m_ProjectReferences( projectReferences )
{
 m_LastBuildTimeMs = 100;
 m_Type = Node::VCXPROJECT_NODE;


 m_StaticDependencies.Append( paths );
}



VCXProjectNode::~VCXProjectNode()
{
}



            Node::BuildResult VCXProjectNode::DoBuild( Job * )
{
 VSProjectGenerator pg;
 pg.SetBasePaths( m_ProjectBasePaths );
 pg.SetAllowedFileExtensions( m_AllowedFileExtensions );


 const char * p1 = m_Name.FindLast( ( '/' ) );
 p1 = p1 ? p1 : m_Name.Get();
 AStackString<> projectName( p1 );
 pg.SetProjectName( projectName );


 pg.SetRootNamespace( m_RootNamespace );
 pg.SetProjectGuid( m_ProjectGuid );
 pg.SetDefaultLanguage( m_DefaultLanguage );
 pg.SetApplicationEnvironment( m_ApplicationEnvironment );


 pg.SetReferences( m_References );
 pg.SetProjectReferences( m_ProjectReferences );


 Array< FileIO::FileInfo * > files( 1024, true );
 GetFiles( files );
 for ( FileIO::FileInfo ** it=files.Begin(); it!=files.End(); ++it )
 {
  const AString & fileName = ( *it )->m_Name;
  AddFile( pg, fileName );
 }


 for ( const AString * it=m_Files.Begin(); it!=m_Files.End(); ++it )
 {
  const AString & fileName = ( *it );
  pg.AddFile( fileName, false );
 }


 const AString & project = pg.GenerateVCXProj( m_Name, m_Configs, m_FileTypes );
 if ( Save( project, m_Name ) == false )
 {
  return NODE_RESULT_FAILED;
 }


 const AString & filters = pg.GenerateVCXProjFilters( m_Name );
 AStackString<> filterFile( m_Name );
 filterFile += ".filters";
 if ( Save( filters, filterFile ) == false )
 {
  return NODE_RESULT_FAILED;
 }

 return NODE_RESULT_OK;
}



void VCXProjectNode::AddFile( VSProjectGenerator & pg, const AString & fileName ) const
{
 const AString * const end = m_FilesToExclude.End();
 for( const AString * it=m_FilesToExclude.Begin(); it!=end; ++it )
 {
  if ( fileName.EndsWithI( *it ) )
  {
   return;
  }
 }

 pg.AddFile( fileName, true );
}



bool VCXProjectNode::Save( const AString & content, const AString & fileName ) const
{
 bool needToWrite = false;

 FileStream old;
 if ( FBuild::Get().GetOptions().m_ForceCleanBuild )
 {
  needToWrite = true;
 }
 else if ( old.Open( fileName.Get(), FileStream::READ_ONLY ) == false )
 {
  needToWrite = true;
 }
 else
 {

  size_t oldFileSize = (size_t)old.GetFileSize();
  if ( oldFileSize != content.GetLength() )
  {
   needToWrite = true;
  }
  else
  {

   AutoPtr< char > mem( ( char *)::AllocFileLine( oldFileSize, "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/VCXProjectNode.cpp", 173 ) );
   if ( old.Read( mem.Get(), oldFileSize ) != oldFileSize )
   {
    do { FLog::Error( "VCXProject - Failed to read '%s'", fileName.Get() ); } while ( false ); ;
    return false;
   }


   if ( memcmp( mem.Get(), content.Get(), oldFileSize ) != 0 )
   {
    needToWrite = true;
   }
  }


  old.Close();
 }


 if ( needToWrite == false )
 {
  return true;
 }

 do { FLog::Build( "VCXProj: %s\n", fileName.Get() ); } while ( false ); ;



 if ( EnsurePathExistsForFile( fileName ) == false )
 {
  do { FLog::Error( "VCXProject - Invalid path for '%s' (error: %u)", fileName.Get(), Env::GetLastErr() ); } while ( false ); ;
  return false;
 }


 FileStream f;
 if ( !f.Open( fileName.Get(), FileStream::WRITE_ONLY ) )
 {
  do { FLog::Error( "VCXProject - Failed to open '%s' for write (error: %u)", fileName.Get(), Env::GetLastErr() ); } while ( false ); ;
  return false;
 }
 if ( f.Write( content.Get(), content.GetLength() ) != content.GetLength() )
 {
  do { FLog::Error( "VCXProject - Error writing to '%s' (error: %u)", fileName.Get(), Env::GetLastErr() ); } while ( false ); ;
  return false;
 }
 f.Close();

 return true;
}



           Node * VCXProjectNode::Load( IOStream & stream )
{
 AStackString<> name; if ( stream.Read( name ) == false ) { return (0); };
 Array< AString > projectBasePaths; if ( stream.Read( projectBasePaths ) == false ) { return (0); };
 Dependencies staticDeps( 1, true ); if ( staticDeps.Load( stream ) == false ) { return (0); };
 Array< AString > pathsToExclude; if ( stream.Read( pathsToExclude ) == false ) { return (0); };
 Array< AString > allowedFileExtensions; if ( stream.Read( allowedFileExtensions ) == false ) { return (0); };
 Array< AString > files; if ( stream.Read( files ) == false ) { return (0); };
 Array< AString > filesToExclude; if ( stream.Read( filesToExclude ) == false ) { return (0); };
 AStackString<> rootNamespace; if ( stream.Read( rootNamespace ) == false ) { return (0); };
 AStackString<> projectGuid; if ( stream.Read( projectGuid ) == false ) { return (0); };
 AStackString<> defaultLanguage; if ( stream.Read( defaultLanguage ) == false ) { return (0); };
 AStackString<> applicationEnvironment; if ( stream.Read( applicationEnvironment ) == false ) { return (0); };
 Array< AString > references; if ( stream.Read( references ) == false ) { return (0); };
 Array< AString > projectReferences; if ( stream.Read( projectReferences ) == false ) { return (0); };

 Array< VSProjectConfig > configs;
 VSProjectConfig::Load( stream, configs );

 Array< VSProjectFileType > fileTypes;
 VSProjectFileType::Load( stream, fileTypes );

 NodeGraph & ng = FBuild::Get().GetDependencyGraph();
 VCXProjectNode * n = ng.CreateVCXProjectNode( name,
         projectBasePaths,
         staticDeps,
         pathsToExclude,
         allowedFileExtensions,
         files,
         filesToExclude,
         rootNamespace,
         projectGuid,
         defaultLanguage,
         applicationEnvironment,
         configs,
         fileTypes,
         references,
         projectReferences );
 return n;
}



            void VCXProjectNode::Save( IOStream & stream ) const
{
 stream.Write( m_Name );;
 stream.Write( m_ProjectBasePaths );;
 m_StaticDependencies.Save( stream );;
 stream.Write( m_PathsToExclude );;
 stream.Write( m_AllowedFileExtensions );;
 stream.Write( m_Files );;
 stream.Write( m_FilesToExclude );;
 stream.Write( m_RootNamespace );;
 stream.Write( m_ProjectGuid );;
 stream.Write( m_DefaultLanguage );;
 stream.Write( m_ApplicationEnvironment );;
 stream.Write( m_References );;
 stream.Write( m_ProjectReferences );;
 VSProjectConfig::Save( stream, m_Configs );
 VSProjectFileType::Save( stream, m_FileTypes );
}



void VCXProjectNode::GetFiles( Array< FileIO::FileInfo * > & files ) const
{

 const Dependency * const sEnd = m_StaticDependencies.End();
 for ( const Dependency * sIt = m_StaticDependencies.Begin(); sIt != sEnd; ++sIt )
 {
  DirectoryListNode * dirNode = sIt->GetNode()->CastTo< DirectoryListNode >();
  const FileIO::FileInfo * const filesEnd = dirNode->GetFiles().End();


  for ( FileIO::FileInfo * filesIt = dirNode->GetFiles().Begin(); filesIt != filesEnd; ++filesIt )
  {
   bool keep = true;
# 317 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/VCXProjectNode.cpp"
   if ( keep )
   {
    const AString * pit = m_PathsToExclude.Begin();
    const AString * const pend = m_PathsToExclude.End();
    for ( ; pit != pend; ++pit )
    {
     if ( filesIt->m_Name.BeginsWithI( *pit ) )
     {
      keep = false;
      break;
     }
    }
   }

   if ( keep )
   {
    files.Append( filesIt );
   }
  }
 }
}
# 164 "/home/ffulin/p4/tmp/Unity/Tools/FBuild/FBuildCore/Unity1.cpp" 2


# 1 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/CompilerNode.cpp" 1





# 1 "./Tools/FBuild/FBuildCore/PrecompiledHeader.h" 1
# 7 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/CompilerNode.cpp" 2
# 18 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/CompilerNode.cpp"
CompilerNode::CompilerNode( const AString & exe,
          const Dependencies & extraFiles,
       bool allowDistribution )
 : FileNode( exe, Node::FLAG_NO_DELETE_ON_FAIL )
{
 m_StaticDependencies = extraFiles;
 m_Type = Node::COMPILER_NODE;
 m_AllowDistribution = allowDistribution;
}



CompilerNode::~CompilerNode()
{
}



            Node::BuildResult CompilerNode::DoBuild( Job * job )
{

 FileNode::DoBuild( job );

 if ( !m_Manifest.Generate( this, m_StaticDependencies ) )
 {
  return Node::NODE_RESULT_FAILED;
 }

 m_Stamp = m_Manifest.GetTimeStamp();
 return Node::NODE_RESULT_OK;
}



           Node * CompilerNode::Load( IOStream & stream )
{
 AStackString<> exeName; if ( stream.Read( exeName ) == false ) { return (0); };
 Dependencies staticDeps( 16, true ); if ( staticDeps.Load( stream ) == false ) { return (0); };
 bool allowDistribution; if ( stream.Read( allowDistribution ) == false ) { return (0); };

 NodeGraph & ng = FBuild::Get().GetDependencyGraph();
 CompilerNode * n = ng.CreateCompilerNode( exeName, staticDeps, allowDistribution );
 n->m_Manifest.Deserialize( stream );
 return n;
}



            void CompilerNode::Save( IOStream & stream ) const
{
 stream.Write( m_Name );;
 m_StaticDependencies.Save( stream );;
 stream.Write( m_AllowDistribution );;
 m_Manifest.Serialize( stream );
}
# 167 "/home/ffulin/p4/tmp/Unity/Tools/FBuild/FBuildCore/Unity1.cpp" 2


# 1 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/Node.cpp" 1





# 1 "./Tools/FBuild/FBuildCore/PrecompiledHeader.h" 1
# 7 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/Node.cpp" 2
# 46 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/Node.cpp"
           const char * const Node::s_NodeTypeNames[] =
{
 "Proxy",
 "Copy",
 "Directory",
 "Exec",
 "File",
 "Library",
 "Object",
 "Alias",
 "Exe",
 "Unity",
 "C#",
 "Test",
 "Compiler",
 "DLL",
 "VCXProj",
 "ObjectList",
 "CopyDirNode"
};



Node::Node( const AString & name, Type type, uint32_t controlFlags )
 : m_State( NOT_PROCESSED )
 , m_BuildPassTag( 0 )
 , m_ControlFlags( controlFlags )
 , m_StatsFlags( 0 )
 , m_Stamp( 0 )
 , m_Type( type )
 , m_Next( (0) )
 , m_LastBuildTimeMs( 0 )
 , m_ProcessingTime( 0 )
 , m_ProgressAccumulator( 0 )
 , m_Name( name )
 , m_Index( ( (uint32_t)0xFFFFFFFF ) )
{
 m_NameCRC = CRC32::CalcLower( name );


 do { compile_time_assert_failure< ( sizeof( s_NodeTypeNames ) / sizeof(const char *) == NUM_NODE_TYPES ) > (); } while ( false ); ;
}



Node::~Node()
{
}



            bool Node::DoDynamicDependencies( bool )
{
 return true;
}



bool Node::DetermineNeedToBuild( bool forceClean ) const
{
 if ( forceClean )
 {
  return true;
 }



 if ( m_Stamp == 0 )
 {

  if ( GetType() != Node::FILE_NODE )
  {
   do { if ( FLog::ShowInfo() ) { FLog::Info( "Need to build '%s' (first time)", GetName().Get() ); } } while ( false ); ;
  }
  return true;
 }

 if ( IsAFile() )
 {
  uint64_t lastWriteTime = FileIO::GetFileLastWriteTime( m_Name );

  if ( lastWriteTime == 0 )
  {

   do { if ( FLog::ShowInfo() ) { FLog::Info( "Need to build '%s' (missing)", GetName().Get() ); } } while ( false ); ;
   return true;
  }

  if ( lastWriteTime != m_Stamp )
  {


   do { if ( FLog::ShowInfo() ) { FLog::Info( "Need to build '%s' (externally modified - stamp = %llu, disk = %llu)", GetName().Get(), m_Stamp, lastWriteTime ); } } while ( false ); ;
   return true;
  }
 }


 const Dependencies & staticDeps = GetStaticDependencies();
 for ( Dependencies::ConstIter it = staticDeps.Begin();
    it != staticDeps.End();
    it++ )
 {
  Node * n = it->GetNode();


  if ( n->GetType() == Node::DIRECTORY_LIST_NODE )
  {
   continue;
  }


  if ( n->GetType() == Node::UNITY_NODE )
  {
   continue;
  }

  if ( n->GetType() == Node::UNITY_NODE )
  {
   continue;
  }


  if ( it->IsWeak() )
  {
   continue;
  }


  do { if ( !( n->IsAFile() || ( n->GetType() == Node::OBJECT_LIST_NODE ) ) ) { if ( AssertHandler::Failure( "n->IsAFile() || ( n->GetType() == Node::OBJECT_LIST_NODE )", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/Node.cpp", 175 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;

  if ( n->GetStamp() == 0 )
  {

   do { if ( FLog::ShowInfo() ) { FLog::Info( "Need to build '%s' (dep missing: '%s')", GetName().Get(), n->GetName().Get() ); } } while ( false ); ;
   return true;
  }

  if ( n->GetStamp() > m_Stamp )
  {

   do { if ( FLog::ShowInfo() ) { FLog::Info( "Need to build '%s' (dep is newer: '%s' this = %llu, dep = %llu)", GetName().Get(), n->GetName().Get(), m_Stamp, n->GetStamp() ); } } while ( false ); ;
   return true;
  }
 }


 const Dependencies & dynamicDeps = GetDynamicDependencies();
 for ( Dependencies::ConstIter it = dynamicDeps.Begin();
    it != dynamicDeps.End();
    it++ )
 {
  Node * n = it->GetNode();


  do { if ( !( n->IsAFile() || ( n->GetType() == Node::OBJECT_LIST_NODE ) ) ) { if ( AssertHandler::Failure( "n->IsAFile() || ( n->GetType() == Node::OBJECT_LIST_NODE )", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/Node.cpp", 201 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;


  if ( it->IsWeak() )
  {
   continue;
  }


  if ( n->GetStamp() == 0 )
  {

   do { if ( FLog::ShowInfo() ) { FLog::Info( "Need to build '%s' (dep missing: '%s')", GetName().Get(), n->GetName().Get() ); } } while ( false ); ;
   return true;
  }

  if ( n->GetStamp() > m_Stamp )
  {

   do { if ( FLog::ShowInfo() ) { FLog::Info( "Need to build '%s' (dep is newer: '%s' this = %llu, dep = %llu)", GetName().Get(), n->GetName().Get(), m_Stamp, n->GetStamp() ); } } while ( false ); ;
   return true;
  }
 }



 do { if ( FLog::ShowInfo() ) { FLog::Info( "Up-To-Date '%s'", GetName().Get() ); } } while ( false ); ;
 return false;
}



            Node::BuildResult Node::DoBuild( Job * )
{
 do { if ( !( false ) ) { if ( AssertHandler::Failure( "false", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/Node.cpp", 235 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;
 return Node::NODE_RESULT_FAILED;
}



            Node::BuildResult Node::DoBuild2( Job * , bool )
{
 do { if ( !( false ) ) { if ( AssertHandler::Failure( "false", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/Node.cpp", 243 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;
 return Node::NODE_RESULT_FAILED;
}



            bool Node::Finalize()
{

 return true;
}



void Node::SaveNode( IOStream & fileStream, const Node * node ) const
{

 if ( node == (0) )
 {
  fileStream.Write( AString::GetEmpty() );
 }
 else
 {

  fileStream.Write( node->GetName() );
 }
}



           bool Node::LoadNode( IOStream & stream, Node * & node )
{

 AStackString< 512 > nodeName;
 if ( stream.Read( nodeName ) == false )
 {
        node = (0);
  return false;
 }


 if ( nodeName.IsEmpty() )
 {
  node = (0);
  return true;
 }


 NodeGraph & ng = FBuild::Get().GetDependencyGraph();
 Node * n = ng.FindNode( nodeName );
 if ( n == (0) )
 {
        node = (0);
  return false;
 }
 node = n;

 return true;
}



           bool Node::LoadNode( IOStream & stream, CompilerNode * & compilerNode )
{
 Node * node;
 if ( !LoadNode( stream, node ) )
 {
  return false;
 }
 if ( node->GetType() != Node::COMPILER_NODE )
 {
  return false;
 }
 compilerNode = node->CastTo< CompilerNode >();
 return true;
}



           bool Node::LoadNode( IOStream & stream, FileNode * & fileNode )
{
 Node * node;
 if ( !LoadNode( stream, node ) )
 {
  return false;
 }
 if ( !node->IsAFile() )
 {
  return false;
 }
 fileNode = node->CastTo< FileNode >();
 return ( fileNode != (0) );
}



           bool Node::EnsurePathExistsForFile( const AString & name )
{
 const char * lastSlash = name.FindLast( ( '/' ) );
 do { if ( !( PathUtils::IsFullPath( name ) ) ) { if ( AssertHandler::Failure( "PathUtils::IsFullPath( name )", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/Node.cpp", 342 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;
 AStackString<> pathOnly( name.Get(), lastSlash );
 if ( FileIO::EnsurePathExists( pathOnly ) == false )
 {
  do { FLog::Error( "Failed to create path '%s'", pathOnly.Get() ); } while ( false ); ;
  return false;
 }
 return true;
}



           Node * Node::Load( IOStream & stream )
{

 uint32_t nodeType;
 if ( stream.Read( nodeType ) == false )
 {
  return (0);
 }


 uint64_t stamp( 0 );
 if ( nodeType != Node::FILE_NODE )
 {
  if ( stream.Read( stamp ) == false )
  {
   return (0);
  }
 }


 Node * n = (0);
 switch ( (Node::Type)nodeType )
 {
  case Node::PROXY_NODE: do { if ( !( false ) ) { if ( AssertHandler::Failure( "false", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/Node.cpp", 377 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ; break;
  case Node::COPY_NODE: n = CopyNode::Load( stream ); break;
  case Node::DIRECTORY_LIST_NODE: n = DirectoryListNode::Load( stream ); break;
  case Node::EXEC_NODE: n = ExecNode::Load( stream ); break;
  case Node::FILE_NODE: n = FileNode::Load( stream ); break;
  case Node::LIBRARY_NODE: n = LibraryNode::Load( stream ); break;
  case Node::OBJECT_NODE: n = ObjectNode::Load( stream ); break;
  case Node::ALIAS_NODE: n = AliasNode::Load( stream ); break;
  case Node::EXE_NODE: n = ExeNode::Load( stream ); break;
  case Node::CS_NODE: n = CSNode::Load( stream ); break;
  case Node::UNITY_NODE: n = UnityNode::Load( stream ); break;
  case Node::TEST_NODE: n = TestNode::Load( stream ); break;
  case Node::COMPILER_NODE: n = CompilerNode::Load( stream ); break;
  case Node::DLL_NODE: n = DLLNode::Load( stream ); break;
  case Node::VCXPROJECT_NODE: n = VCXProjectNode::Load( stream ); break;
  case Node::OBJECT_LIST_NODE: n = ObjectListNode::Load( stream ); break;
  case Node::COPY_DIR_NODE: n = CopyDirNode::Load( stream ); break;
  case Node::NUM_NODE_TYPES: do { if ( !( false ) ) { if ( AssertHandler::Failure( "false", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/Node.cpp", 394 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ; break;
 }

 do { if ( !( n ) ) { if ( AssertHandler::Failure( "n", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/Node.cpp", 397 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;
 if ( n )
 {

  n->m_Stamp = stamp;
 }

 return n;
}



           void Node::Save( IOStream & stream, const Node * node )
{
 do { if ( !( node ) ) { if ( AssertHandler::Failure( "node", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/Node.cpp", 411 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;


 uint32_t nodeType = (uint32_t)node->GetType();
 stream.Write( nodeType );


 if ( nodeType != Node::FILE_NODE )
 {
  uint64_t stamp = node->GetStamp();
  stream.Write( stamp );
 }


 node->Save( stream );
}



           Node * Node::LoadRemote( IOStream & stream )
{

 uint32_t nodeType;
 if ( stream.Read( nodeType ) == false )
 {
  return (0);
 }


 Node * n = (0);
 switch ( (Node::Type)nodeType )
 {
  case Node::OBJECT_NODE: n = ObjectNode::LoadRemote( stream ); break;
  default: do { if ( !( false ) ) { if ( AssertHandler::Failure( "false", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/Node.cpp", 444 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ; break;
 }

 return n;
}



           void Node::SaveRemote( IOStream & stream, const Node * node )
{
 do { if ( !( node ) ) { if ( AssertHandler::Failure( "node", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/Node.cpp", 454 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;


 do { if ( !( node->GetType() == Node::OBJECT_NODE ) ) { if ( AssertHandler::Failure( "node->GetType() == Node::OBJECT_NODE", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/Node.cpp", 457 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;


 uint32_t nodeType = (uint32_t)node->GetType();
 stream.Write( nodeType );


 node->SaveRemote( stream );
}



            void Node::SaveRemote( IOStream & ) const
{



 do { if ( !( false ) ) { if ( AssertHandler::Failure( "false", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/Node.cpp", 474 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;
}



void Node::ReplaceDummyName( const AString & newName )
{
 m_Name = newName;
}



           void Node::DumpOutput( Job * job,
          const char * data,
          uint32_t dataSize,
          const Array< AString > * exclusions )
{
 if ( ( data == (0) ) || ( dataSize == 0 ) )
 {
  return;
 }


 AString buffer( (1024 * 1024) );

 const char * end = data + dataSize;
 while( data < end )
 {

  const char * lineStart = data;
  const char * lineEnd = lineStart;
  while ( lineEnd < end )
  {
   if ( ( *lineEnd == '\r' ) || ( *lineEnd == '\n' ) )
   {
    break;
   }
   lineEnd++;
  }
  if ( lineStart != lineEnd )
  {

   AStackString< 1024 > copy( lineStart, lineEnd );


   bool skip = false;
   if ( exclusions )
   {
    const AString * iter = exclusions->Begin();
    const AString * const endIter = exclusions->End();
    while ( iter != endIter )
    {
     if ( copy.BeginsWith( *iter ) )
     {
      skip = true;
      break;
     }
     iter++;
    }
   }
   if ( !skip )
   {
    copy += '\n';



    if ( FBuild::IsValid() && FBuild::Get().GetOptions().m_FixupErrorPaths )
    {
     FixupPathForVSIntegration( copy );
    }


    if ( buffer.GetLength() + copy.GetLength() > buffer.GetReserved() )
    {
     buffer.SetReserved( buffer.GetReserved() + (1024 * 1024) );
    }
    buffer += copy;
   }
  }
  data = ( lineEnd + 1 );
 }


 do { FLog::ErrorDirect( buffer.Get() ); } while ( false ); ;


 if ( job && ( !job->IsLocal() ) )
 {
  job->Error( "%s", buffer.Get() );
 }
}



           void Node::FixupPathForVSIntegration( AString & line )
{






 const char * tag = line.Find( ": warning:" );
 tag = tag ? tag : line.Find( ": note:" );
 tag = tag ? tag : line.Find( ": error:" );
 tag = tag ? tag : line.Find( ": fatal error:" );
 tag = tag ? tag : line.Find( ": remark:" );
 if ( tag )
 {
  FixupPathForVSIntegration_GCC( line, tag );
  return;
 }







 tag = tag ? tag : line.Find( ": error " );
 tag = tag ? tag : line.Find( ": warning " );
 tag = tag ? tag : line.Find( ": note " );
 tag = tag ? tag : line.Find( ": remark " );
 if ( tag )
 {
  FixupPathForVSIntegration_SNC( line, tag );
  return;
 }


}



           void Node::FixupPathForVSIntegration_GCC( AString & line, const char * tag )
{
 AStackString<> beforeTag( line.Get(), tag );
 Array< AString > tokens;
 beforeTag.Tokenize( tokens, ':' );
 const size_t numTokens = tokens.GetSize();
 if ( numTokens < 3 )
 {
  return;
 }


 int row, column;
 if ( ( sscanf( tokens[ numTokens - 1 ].Get(), "%i", &column ) != 1 ) ||
   ( sscanf( tokens[ numTokens - 2 ].Get(), "%i", &row ) != 1 ) )
 {
  return;
 }


 AStackString<> fixed;


 if ( tokens[ 0 ].GetLength() == 1 )
 {
  do { if ( !( numTokens >= 4 ) ) { if ( AssertHandler::Failure( "numTokens >= 4", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/Node.cpp", 633 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;
  fixed = tokens[ 0 ];
 }
 else
 {
  NodeGraph::CleanPath( tokens[ 0 ], fixed );
 }


 for ( size_t i=1; i<( numTokens-2 ); ++i )
 {
  if ( i != 0 )
  {
   fixed += ':';
  }
  fixed += tokens[ i ];
 }


 fixed += '(';
 fixed += tokens[ numTokens - 2 ];
 fixed += ',';
 fixed += tokens[ numTokens - 1 ];
 fixed += ')';


 fixed += tag;

 line = fixed;
}



           void Node::FixupPathForVSIntegration_SNC( AString & line, const char * tag )
{
 AStackString<> beforeTag( line.Get(), tag );

 const char * openBracket = beforeTag.Find( '(' );
 if( openBracket == (0) )
 {
  return;
 }

 AStackString<> path( beforeTag.Get(), openBracket );
 AStackString<> fixed;
 NodeGraph::CleanPath( path, fixed );


 fixed += openBracket;


 fixed += tag;

 line = fixed;
}
# 170 "/home/ffulin/p4/tmp/Unity/Tools/FBuild/FBuildCore/Unity1.cpp" 2


# 1 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/FileNode.cpp" 1





# 1 "./Tools/FBuild/FBuildCore/PrecompiledHeader.h" 1
# 7 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/FileNode.cpp" 2
# 19 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/FileNode.cpp"
FileNode::FileNode( const AString & fileName, uint32_t controlFlags )
: Node( fileName, Node::FILE_NODE, controlFlags )
{
 do { if ( !( fileName.EndsWith( "\\" ) == false ) ) { if ( AssertHandler::Failure( "fileName.EndsWith( \"\\\\\" ) == false", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/FileNode.cpp", 22 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;
 do { if ( !( ( fileName.FindLast( ':' ) == (0) ) || ( fileName.FindLast( ':' ) == ( fileName.Get() + 1 ) ) ) ) { if ( AssertHandler::Failure( "( fileName.FindLast( ':' ) == nullptr ) || ( fileName.FindLast( ':' ) == ( fileName.Get() + 1 ) )",
 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/FileNode.cpp"
# 23 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/FileNode.cpp"
 ,
 24
# 23 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/FileNode.cpp"
 ) ) { __asm__ __volatile__("int $3"); } } } while ( false );
                                                           ;

 m_LastBuildTimeMs = 1;
}



FileNode::~FileNode()
{
}



            Node::BuildResult FileNode::DoBuild( Job * )
{
 m_Stamp = FileIO::GetFileLastWriteTime( m_Name );
 return NODE_RESULT_OK;
}



           Node * FileNode::Load( IOStream & stream )
{
 AStackString<> fileName; if ( stream.Read( fileName ) == false ) { return (0); };

 NodeGraph & ng = FBuild::Get().GetDependencyGraph();
 Node * n = ng.CreateFileNode( fileName );
 do { if ( !( n ) ) { if ( AssertHandler::Failure( "n", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/FileNode.cpp", 51 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;
 return n;
}



            void FileNode::Save( IOStream & stream ) const
{
 stream.Write( m_Name );;
}
# 173 "/home/ffulin/p4/tmp/Unity/Tools/FBuild/FBuildCore/Unity1.cpp" 2


# 1 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/CSNode.cpp" 1





# 1 "./Tools/FBuild/FBuildCore/PrecompiledHeader.h" 1
# 7 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/CSNode.cpp" 2
# 25 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/CSNode.cpp"
CSNode::CSNode( const AString & compilerOutput,
    const Dependencies & inputNodes,
    const AString & compiler,
    const AString & compilerArgs,
    const Dependencies & extraRefs )
: FileNode( compilerOutput, Node::FLAG_NONE )
, m_ExtraRefs( extraRefs )
{
 do { if ( !( !inputNodes.IsEmpty() ) ) { if ( AssertHandler::Failure( "!inputNodes.IsEmpty()", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/CSNode.cpp", 33 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;

 m_StaticDependencies.SetCapacity( inputNodes.GetSize() + extraRefs.GetSize() );
 m_StaticDependencies.Append( inputNodes );
 m_StaticDependencies.Append( extraRefs );


 m_CompilerPath = compiler;
 m_CompilerArgs = compilerArgs;

 m_Type = CS_NODE;
 m_LastBuildTimeMs = 5000;
}



CSNode::~CSNode()
{
}



            bool CSNode::DoDynamicDependencies( bool )
{
 do { if ( !( m_DynamicDependencies.GetSize() == 0 ) ) { if ( AssertHandler::Failure( "m_DynamicDependencies.GetSize() == 0", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/CSNode.cpp", 57 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;

 NodeGraph & ng = FBuild::Get().GetDependencyGraph();


 m_DynamicDependencies.SetCapacity( m_StaticDependencies.GetSize() );



 size_t numDeps = m_StaticDependencies.GetSize() - m_ExtraRefs.GetSize();
 for ( size_t i=0; i<numDeps; ++i )
 {
  Node * n = m_StaticDependencies[ i ].GetNode();

  if ( n->IsAFile() )
  {
   m_DynamicDependencies.Append( Dependency( n ) );
   continue;
  }

  if ( n->GetType() == Node::DIRECTORY_LIST_NODE )
  {

   DirectoryListNode * dln = n->CastTo< DirectoryListNode >();
   const Array< FileIO::FileInfo > & files = dln->GetFiles();
   m_DynamicDependencies.SetCapacity( m_DynamicDependencies.GetSize() + files.GetSize() );
   for ( Array< FileIO::FileInfo >::Iter fIt = files.Begin();
     fIt != files.End();
     fIt++ )
   {

    Node * sn = ng.FindNode( fIt->m_Name );
    if ( sn == (0) )
    {
     sn = ng.CreateFileNode( fIt->m_Name );
    }
    else if ( sn->IsAFile() == false )
    {
     do { FLog::Error( "CSAssembly() .CompilerInputFile '%s' is not a FileNode (type: %s)", n->GetName().Get(), n->GetTypeName() ); } while ( false ); ;
     return false;
    }

    m_DynamicDependencies.Append( Dependency( sn ) );
   }
   continue;
  }

  do { FLog::Error( "'%s' is not a supported node type (type: %s)", n->GetName().Get(), n->GetTypeName() ); } while ( false ); ;
  return false;
 }

 return true;
}



            Node::BuildResult CSNode::DoBuild( Job * job )
{

 AStackString< 4 * (1024) > fullArgs;
 GetFullArgs( fullArgs );


 const char * workingDir = (0);

 const char * environment = FBuild::Get().GetEnvironmentString();

 EmitCompilationMessage( fullArgs );


 ResponseFile rf;
 AStackString<> responseFileArgs;
 if ( !rf.Create( fullArgs ) )
 {
  return NODE_RESULT_FAILED;
 }


 responseFileArgs.Format( "@\"%s\"", rf.GetResponseFilePath().Get() );


 Process p;
 if ( p.Spawn( m_CompilerPath.Get(), responseFileArgs.Get(),
      workingDir, environment ) == false )
 {
  do { FLog::Error( "Failed to spawn process to build '%s'", GetName().Get() ); } while ( false ); ;
  return NODE_RESULT_FAILED;
 }


 AutoPtr< char > memOut;
 AutoPtr< char > memErr;
 uint32_t memOutSize = 0;
 uint32_t memErrSize = 0;
 p.ReadAllData( memOut, &memOutSize, memErr, &memErrSize );


 do { if ( !( !p.IsRunning() ) ) { if ( AssertHandler::Failure( "!p.IsRunning()", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/CSNode.cpp", 154 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;
 int result = p.WaitForExit();
 bool ok = ( result == 0 );

 if ( !ok )
 {

  Node::DumpOutput( job, memOut.Get(), memOutSize );
  Node::DumpOutput( job, memErr.Get(), memErrSize );
  goto failed;
 }

 if ( !FileIO::FileExists( m_Name.Get() ) )
 {
  do { FLog::Error( "Object missing despite success for '%s'", GetName().Get() ); } while ( false ); ;
  return NODE_RESULT_FAILED;
 }


 m_Stamp = FileIO::GetFileLastWriteTime( m_Name );

 return NODE_RESULT_OK;

failed:
 do { FLog::Error( "Failed to build Object (error %i) '%s'", result, GetName().Get() ); } while ( false ); ;

 return NODE_RESULT_FAILED;
}



           Node * CSNode::Load( IOStream & stream )
{
 AStackString<> name; if ( stream.Read( name ) == false ) { return (0); };
 Dependencies staticDeps( 2, true ); if ( staticDeps.Load( stream ) == false ) { return (0); };
 AStackString<> compilerPath; if ( stream.Read( compilerPath ) == false ) { return (0); };
 AStackString<> compilerArgs; if ( stream.Read( compilerArgs ) == false ) { return (0); };
 Dependencies extraRefs( 0, true ); if ( extraRefs.Load( stream ) == false ) { return (0); };

 do { if ( !( staticDeps.GetSize() >= 1 ) ) { if ( AssertHandler::Failure( "staticDeps.GetSize() >= 1", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/CSNode.cpp", 193 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;

 NodeGraph & ng = FBuild::Get().GetDependencyGraph();
 Node * on = ng.CreateCSNode( name, staticDeps, compilerPath, compilerArgs, extraRefs );
 CSNode * csNode = on->CastTo< CSNode >();
 return csNode;
}



            void CSNode::Save( IOStream & stream ) const
{
 stream.Write( m_Name );;


 size_t numBaseDeps = m_StaticDependencies.GetSize() - m_ExtraRefs.GetSize();
 Dependencies staticDeps( numBaseDeps, false );
 for ( size_t i=0; i<numBaseDeps; ++i )
 {
  staticDeps.Append( Dependency( m_StaticDependencies[ i ].GetNode() ) );
 }
 staticDeps.Save( stream );;

 stream.Write( m_CompilerPath );;
 stream.Write( m_CompilerArgs );;
 m_ExtraRefs.Save( stream );;
}



void CSNode::EmitCompilationMessage( const AString & fullArgs ) const
{



 AStackString<> output;
 output += "C#: ";
 output += GetName();
 output += '\n';
 if ( FLog::ShowInfo() || FBuild::Get().GetOptions().m_ShowCommandLines )
 {
  output += m_CompilerPath;
  output += ' ';
  output += fullArgs;
  output += '\n';
 }
 do { FLog::Build( "%s", output.Get() ); } while ( false ); ;
}



void CSNode::GetFullArgs( AString & fullArgs ) const
{

 Array< AString > tokens( 1024, true );
 m_CompilerArgs.Tokenize( tokens );

 AStackString<> quote( "\"" );

 const AString * const end = tokens.End();
 for ( const AString * it = tokens.Begin(); it!=end; ++it )
 {
  const AString & token = *it;
  if ( token.EndsWith( "%1" ) )
  {

   AStackString<> pre;
   if ( token.GetLength() > 2 )
   {
    pre.Assign( token.Get(), token.GetEnd() - 2 );
   }


   GetInputFiles( fullArgs, pre, AString::GetEmpty() );
  }
  else if ( token.EndsWith( "\"%1\"" ) )
  {

   AStackString<> pre( token.Get(), token.GetEnd() - 3 );


   GetInputFiles( fullArgs, pre, quote );
  }
  else if ( token.EndsWith( "%2" ) )
  {

   if ( token.GetLength() > 2 )
   {
    fullArgs += AStackString<>( token.Get(), token.GetEnd() - 2 );
   }
   fullArgs += m_Name;
  }
  else if ( token.EndsWith( "\"%2\"" ) )
  {

   AStackString<> pre( token.Get(), token.GetEnd() - 3 );
   fullArgs += pre;
   fullArgs += m_Name;
   fullArgs += '"';
  }
  else if ( token.EndsWith( "%3" ) )
  {

   AStackString<> pre( token.Get(), token.GetEnd() - 2 );
   fullArgs += pre;


   GetExtraRefs( fullArgs, AString::GetEmpty(), AString::GetEmpty() );
  }
  else if ( token.EndsWith( "\"%3\"" ) )
  {

   AStackString<> pre( token.Get(), token.GetEnd() - 4 );
   fullArgs += pre;


   GetExtraRefs( fullArgs, quote, quote );
  }
  else
  {
   fullArgs += token;
  }

  fullArgs += ' ';
 }
}



void CSNode::GetInputFiles( AString & fullArgs, const AString & pre, const AString & post ) const
{
 bool first = true;
 const Dependency * const end = m_DynamicDependencies.End();
 for ( const Dependency * it = m_DynamicDependencies.Begin();
    it != end;
    ++it )
 {
  if ( !first )
  {
   fullArgs += ' ';
  }
  fullArgs += pre;
  fullArgs += it->GetNode()->GetName();
  fullArgs += post;
  first = false;
 }
}



void CSNode::GetExtraRefs( AString & fullArgs, const AString & pre, const AString & post ) const
{
 bool first = true;
 const Dependency * const end = m_ExtraRefs.End();
 for ( const Dependency * it = m_ExtraRefs.Begin(); it!=end; ++it )
 {
  if ( !first )
  {
   fullArgs += ',';
  }
  fullArgs += pre;
  fullArgs += it->GetNode()->GetName();
  fullArgs += post;
  first = false;
 }
}
# 176 "/home/ffulin/p4/tmp/Unity/Tools/FBuild/FBuildCore/Unity1.cpp" 2


# 1 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/AliasNode.cpp" 1





# 1 "./Tools/FBuild/FBuildCore/PrecompiledHeader.h" 1
# 7 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/AliasNode.cpp" 2
# 18 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/AliasNode.cpp"
AliasNode::AliasNode( const AString & groupName,
       const Dependencies & targets )
: Node( groupName, Node::ALIAS_NODE, Node::FLAG_TRIVIAL_BUILD )
{
 m_LastBuildTimeMs = 1;
 m_StaticDependencies = targets;
}



AliasNode::~AliasNode()
{
}



            bool AliasNode::DetermineNeedToBuild( bool forceClean ) const
{
 (void)forceClean;
 return true;
}



            Node::BuildResult AliasNode::DoBuild( Job * )
{
 const Dependencies::Iter end = m_StaticDependencies.End();
 for ( Dependencies::Iter it = m_StaticDependencies.Begin();
    it != end;
    ++it )
 {

  const Node * n = it->GetNode();
  if ( n->GetType() == Node::FILE_NODE )
  {

   if ( n->GetStamp() == 0 )
   {

    do { FLog::Error( "Alias: %s\nFailed due to missing file: %s\n", GetName().Get(), n->GetName().Get() ); } while ( false ); ;
    return Node::NODE_RESULT_FAILED;
   }
  }
 }
 return NODE_RESULT_OK;
}



           Node * AliasNode::Load( IOStream & stream )
{
 AStackString<> name; if ( stream.Read( name ) == false ) { return (0); };
 Dependencies targets( 0, true ); if ( targets.Load( stream ) == false ) { return (0); };

 NodeGraph & ng = FBuild::Get().GetDependencyGraph();
 return ng.CreateAliasNode( name, targets );
}



            void AliasNode::Save( IOStream & stream ) const
{
 stream.Write( m_Name );;
 m_StaticDependencies.Save( stream );;
}
# 179 "/home/ffulin/p4/tmp/Unity/Tools/FBuild/FBuildCore/Unity1.cpp" 2


# 1 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/ObjectNode.cpp" 1





# 1 "./Tools/FBuild/FBuildCore/PrecompiledHeader.h" 1
# 7 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/ObjectNode.cpp" 2
# 40 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/ObjectNode.cpp"
# 1 "/usr/include/x86_64-linux-gnu/sys/time.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/sys/time.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/time.h" 1 3 4
# 28 "/usr/include/x86_64-linux-gnu/sys/time.h" 2 3 4
# 37 "/usr/include/x86_64-linux-gnu/sys/time.h" 3 4
extern "C" {
# 55 "/usr/include/x86_64-linux-gnu/sys/time.h" 3 4
struct timezone
  {
    int tz_minuteswest;
    int tz_dsttime;
  };

typedef struct timezone *__restrict __timezone_ptr_t;
# 71 "/usr/include/x86_64-linux-gnu/sys/time.h" 3 4
extern int gettimeofday (struct timeval *__restrict __tv,
    __timezone_ptr_t __tz) throw () __attribute__ ((__nonnull__ (1)));




extern int settimeofday (const struct timeval *__tv,
    const struct timezone *__tz)
     throw ();





extern int adjtime (const struct timeval *__delta,
      struct timeval *__olddelta) throw ();




enum __itimer_which
  {

    ITIMER_REAL = 0,


    ITIMER_VIRTUAL = 1,



    ITIMER_PROF = 2

  };



struct itimerval
  {

    struct timeval it_interval;

    struct timeval it_value;
  };






typedef int __itimer_which_t;




extern int getitimer (__itimer_which_t __which,
        struct itimerval *__value) throw ();




extern int setitimer (__itimer_which_t __which,
        const struct itimerval *__restrict __new,
        struct itimerval *__restrict __old) throw ();




extern int utimes (const char *__file, const struct timeval __tvp[2])
     throw () __attribute__ ((__nonnull__ (1)));



extern int lutimes (const char *__file, const struct timeval __tvp[2])
     throw () __attribute__ ((__nonnull__ (1)));


extern int futimes (int __fd, const struct timeval __tvp[2]) throw ();






extern int futimesat (int __fd, const char *__file,
        const struct timeval __tvp[2]) throw ();
# 189 "/usr/include/x86_64-linux-gnu/sys/time.h" 3 4
}
# 41 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/ObjectNode.cpp" 2




ObjectNode::ObjectNode( const AString & objectName,
         Node * inputNode,
         Node * compilerNode,
      const AString & compilerArgs,
      const AString & compilerArgsDeoptimized,
      Node * precompiledHeader,
      uint32_t flags,
      const Dependencies & compilerForceUsing,
      bool deoptimizeWritableFiles,
      bool deoptimizeWritableFilesWithToken )
: FileNode( objectName, Node::FLAG_NONE )
, m_Includes( 0, true )
, m_Flags( flags )
, m_CompilerArgs( compilerArgs )
, m_CompilerArgsDeoptimized( compilerArgsDeoptimized )
, m_CompilerForceUsing( compilerForceUsing )
, m_DeoptimizeWritableFiles( deoptimizeWritableFiles )
, m_DeoptimizeWritableFilesWithToken( deoptimizeWritableFilesWithToken )
, m_Remote( false )
{
 m_StaticDependencies.SetCapacity( 3 );

 do { if ( !( compilerNode ) ) { if ( AssertHandler::Failure( "compilerNode", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/ObjectNode.cpp", 67 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;
 m_StaticDependencies.Append( Dependency( compilerNode ) );

 do { if ( !( inputNode ) ) { if ( AssertHandler::Failure( "inputNode", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/ObjectNode.cpp", 70 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;
 m_StaticDependencies.Append( Dependency( inputNode ) );

 if ( precompiledHeader )
 {
  m_StaticDependencies.Append( Dependency( precompiledHeader ) );
 }

 m_StaticDependencies.Append( compilerForceUsing );

 m_Type = OBJECT_NODE;
 m_LastBuildTimeMs = 5000;
}



ObjectNode::ObjectNode( const AString & objectName,
      NodeProxy * srcFile,
      const AString & compilerArgs,
      uint32_t flags )
: FileNode( objectName, Node::FLAG_NONE )
, m_Includes( 0, true )
, m_Flags( flags )
, m_CompilerArgs( compilerArgs )
, m_DeoptimizeWritableFiles( false )
, m_DeoptimizeWritableFilesWithToken( false )
, m_Remote( true )
{
 m_Type = OBJECT_NODE;
 m_LastBuildTimeMs = 5000;

 m_StaticDependencies.SetCapacity( 2 );
 m_StaticDependencies.Append( Dependency( (0) ) );
 m_StaticDependencies.Append( Dependency( srcFile ) );
}



ObjectNode::~ObjectNode()
{

 if ( m_Remote )
 {
  Node * srcFile = GetSourceFile();
  do { if ( !( srcFile->GetType() == Node::PROXY_NODE ) ) { if ( AssertHandler::Failure( "srcFile->GetType() == Node::PROXY_NODE", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/ObjectNode.cpp", 114 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;
  delete srcFile;
 }
}



            Node::BuildResult ObjectNode::DoBuild( Job * job )
{

 if ( FileIO::FileExists( GetName().Get() ) )
 {
  if ( FileIO::FileDelete( GetName().Get() ) == false )
  {
   do { FLog::Error( "Failed to delete file before build '%s'", GetName().Get() ); } while ( false ); ;
   return NODE_RESULT_FAILED;
  }
 }
 if ( GetFlag( FLAG_MSVC ) && GetFlag( FLAG_CREATING_PCH ) )
 {
  AStackString<> pchObj( GetName() );
  pchObj += GetObjExtension();
  if ( FileIO::FileExists( pchObj.Get() ) )
  {
   if ( FileIO::FileDelete( pchObj.Get() ) == false )
   {
    do { FLog::Error( "Failed to delete file before build '%s'", GetName().Get() ); } while ( false ); ;
    return NODE_RESULT_FAILED;
   }
  }
 }


 bool useDeoptimization = ShouldUseDeoptimization();

 bool useCache = ShouldUseCache();
 bool useDist = GetFlag( FLAG_CAN_BE_DISTRIBUTED ) && FBuild::Get().GetOptions().m_AllowDistributed;
 bool usePreProcessor = ( useCache || useDist || GetFlag( FLAG_GCC ) || GetFlag( FLAG_SNC ) || GetFlag( FLAG_CLANG ) || GetFlag( CODEWARRIOR_WII ) || GetFlag( GREENHILLS_WIIU ) );

 if ( usePreProcessor )
 {
  return DoBuildWithPreProcessor( job, useDeoptimization, useCache );
 }

 if ( GetFlag( FLAG_MSVC ) )
 {
  return DoBuildMSCL_NoCache( job, useDeoptimization );
 }

 return DoBuildOther( job, useDeoptimization );
}



            Node::BuildResult ObjectNode::DoBuild2( Job * job, bool racingRemoteJob = false )
{


 bool useDeoptimization = job->IsLocal() && ShouldUseDeoptimization();
 bool stealingRemoteJob = job->IsLocal();
 return DoBuildWithPreProcessor2( job, useDeoptimization, stealingRemoteJob, racingRemoteJob );
}



            bool ObjectNode::Finalize()
{
 do { if ( !( Thread::IsMainThread() ) ) { if ( AssertHandler::Failure( "Thread::IsMainThread()", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/ObjectNode.cpp", 181 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;

 NodeGraph & ng = FBuild::Get().GetDependencyGraph();


 m_DynamicDependencies.Clear();
 m_DynamicDependencies.SetCapacity( m_Includes.GetSize() );
 for ( Array< AString >::ConstIter it = m_Includes.Begin();
   it != m_Includes.End();
   it++ )
 {
  Node * fn = FBuild::Get().GetDependencyGraph().FindNode( *it );
  if ( fn == (0) )
  {
   fn = ng.CreateFileNode( *it );
  }
  else if ( fn->IsAFile() == false )
  {
   do { FLog::Error( "'%s' is not a FileNode (type: %s)", fn->GetName().Get(), fn->GetTypeName() ); } while ( false ); ;
   return false;
  }
  m_DynamicDependencies.Append( Dependency( fn ) );
 }

 return true;
}



            Node::BuildResult ObjectNode::DoBuildMSCL_NoCache( Job * job, bool useDeoptimization )
{

 AStackString< 8 * (1024) > fullArgs;
 BuildFullArgs( job, fullArgs, PASS_COMPILE, useDeoptimization );
 fullArgs += " /showIncludes";

 EmitCompilationMessage( fullArgs, useDeoptimization );


 CompileHelper ch;
 if ( !ch.SpawnCompiler( job, GetName(), GetCompiler()->GetName(), fullArgs, true ) )
 {
  return NODE_RESULT_FAILED;
 }


 if ( ProcessIncludesMSCL( ch.GetOut().Get(), ch.GetOutSize() ) == false )
 {
  return NODE_RESULT_FAILED;
 }


 m_Stamp = FileIO::GetFileLastWriteTime( m_Name );

 return NODE_RESULT_OK;
}



Node::BuildResult ObjectNode::DoBuildWithPreProcessor( Job * job, bool useDeoptimization, bool useCache )
{
 AStackString< 8 * (1024) > fullArgs;
 BuildFullArgs( job, fullArgs, PASS_PREPROCESSOR_ONLY, useDeoptimization );

 if ( BuildPreprocessedOutput( fullArgs, job, useDeoptimization ) == false )
 {
  return NODE_RESULT_FAILED;
 }


 if ( ProcessIncludesWithPreProcessor( job ) == false )
 {
  return NODE_RESULT_FAILED;
 }


 if ( useCache )
 {

  if ( RetrieveFromCache( job ) )
  {
   return NODE_RESULT_OK_CACHE;
  }
 }


 if ( GetFlag( FLAG_CAN_BE_DISTRIBUTED ) &&
   FBuild::Get().GetOptions().m_AllowDistributed &&
   JobQueue::Get().GetDistributableJobsMemUsage() < ( 512 * (1024 * 1024) ) )
 {

  Compressor c;
  c.Compress( job->GetData(), job->GetDataSize() );
  size_t compressedSize = c.GetResultSize();
  job->OwnData( c.ReleaseResult(), compressedSize, true );


  return NODE_RESULT_NEED_SECOND_BUILD_PASS;
 }


 bool stealingRemoteJob = false;
 bool racingRemoteJob = false;
 Node::BuildResult result = DoBuildWithPreProcessor2( job, useDeoptimization, stealingRemoteJob, racingRemoteJob );
 if ( result != Node::NODE_RESULT_OK )
 {
  return result;
 }

 return Node::NODE_RESULT_OK;
}



Node::BuildResult ObjectNode::DoBuildWithPreProcessor2( Job * job, bool useDeoptimization, bool stealingRemoteJob, bool racingRemoteJob )
{

 do { if ( !( GetFlag( FLAG_USING_CLR ) == false ) ) { if ( AssertHandler::Failure( "GetFlag( FLAG_USING_CLR ) == false", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/ObjectNode.cpp", 298 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;

 bool usePreProcessedOutput = true;
 if ( job->IsLocal() )
 {
  if ( GetFlag( FLAG_CLANG | FLAG_GCC | FLAG_SNC ) )
  {


   if ( GetFlag( FLAG_USING_PCH ) )
   {
    usePreProcessedOutput = false;
   }



   if ( GetFlag( FLAG_CREATING_PCH ) )
   {
    usePreProcessedOutput = false;
   }
  }

  if ( GetFlag( FLAG_MSVC ) )
  {



   if ( GetFlag( FLAG_USING_PCH ) &&
     ( FBuild::Get().GetOptions().m_UseCacheWrite == false ) )
   {
    usePreProcessedOutput = false;
   }
  }


  if ( GetFlag( FLAG_CUDA_NVCC ) )
  {
   usePreProcessedOutput = false;
  }
 }

 AStackString< 8 * (1024) > fullArgs;
 AStackString<> tmpFileName;
 if ( usePreProcessedOutput )
 {
  if ( WriteTmpFile( job, tmpFileName ) == false )
  {
   return NODE_RESULT_FAILED;
  }

  BuildFullArgs( job, fullArgs, PASS_COMPILE_PREPROCESSED, useDeoptimization );


  Node * sourceFile = GetSourceFile();
  fullArgs.Replace( sourceFile->GetName().Get(), tmpFileName.Get() );
 }
 else
 {
  BuildFullArgs( job, fullArgs, PASS_COMPILE, useDeoptimization );
 }

 if ( stealingRemoteJob || racingRemoteJob )
 {

  EmitCompilationMessage( fullArgs, useDeoptimization, stealingRemoteJob, racingRemoteJob );
 }

 bool result = BuildFinalOutput( job, fullArgs );


 if ( tmpFileName.IsEmpty() == false )
 {
  FileIO::FileDelete( tmpFileName.Get() );
 }

 if ( result == false )
 {
  return NODE_RESULT_FAILED;
 }


 if ( job->IsLocal() )
 {
  m_Stamp = FileIO::GetFileLastWriteTime( m_Name );

  const bool useCache = ShouldUseCache();
  if ( m_Stamp && useCache )
  {
   WriteToCache( job );
  }
 }

 return NODE_RESULT_OK;
}



            Node::BuildResult ObjectNode::DoBuildOther( Job * job, bool useDeoptimization )
{

 AStackString< 8 * (1024) > fullArgs;
 BuildFullArgs( job, fullArgs, PASS_COMPILE, useDeoptimization );

 EmitCompilationMessage( fullArgs, useDeoptimization );


 CompileHelper ch;
 if ( !ch.SpawnCompiler( job, GetName(), GetCompiler()->GetName(), fullArgs, false ) )
 {
  return NODE_RESULT_FAILED;
 }


 m_Stamp = FileIO::GetFileLastWriteTime( m_Name );

 return NODE_RESULT_OK;
}



bool ObjectNode::ProcessIncludesMSCL( const char * output, uint32_t outputSize )
{
 Timer t;

 {
  do { if ( !( output && outputSize ) ) { if ( AssertHandler::Failure( "output && outputSize", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/ObjectNode.cpp", 423 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;

  CIncludeParser parser;
  bool result = parser.ParseMSCL_Output( output, outputSize );
  if ( result == false )
  {
   do { FLog::Error( "Failed to process includes for '%s'", GetName().Get() ); } while ( false ); ;
   return false;
  }




  m_Includes.Clear();
  parser.SwapIncludes( m_Includes );
 }

 do { if ( FLog::ShowInfo() ) { FLog::Info( "Process Includes:\n - File: %s\n - Time: %u ms\n - Num : %u", m_Name.Get(), uint32_t( t.GetElapsedMS() ), uint32_t( m_Includes.GetSize() ) ); } } while ( false ); ;

 return true;
}



bool ObjectNode::ProcessIncludesWithPreProcessor( Job * job )
{
 Timer t;

 {
  const char * output = (char *)job->GetData();
  const size_t outputSize = job->GetDataSize();

  do { if ( !( output && outputSize ) ) { if ( AssertHandler::Failure( "output && outputSize", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/ObjectNode.cpp", 455 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;

  CIncludeParser parser;
  bool msvcStyle = GetFlag( FLAG_MSVC ) || GetFlag( FLAG_CUDA_NVCC );
  bool result = msvcStyle ? parser.ParseMSCL_Preprocessed( output, outputSize )
        : parser.ParseGCC_Preprocessed( output, outputSize );
  if ( result == false )
  {
   do { FLog::Error( "Failed to process includes for '%s'", GetName().Get() ); } while ( false ); ;
   return false;
  }




  m_Includes.Clear();
  parser.SwapIncludes( m_Includes );
 }

 do { if ( FLog::ShowInfo() ) { FLog::Info( "Process Includes:\n - File: %s\n - Time: %u ms\n - Num : %u", m_Name.Get(), uint32_t( t.GetElapsedMS() ), uint32_t( m_Includes.GetSize() ) ); } } while ( false ); ;

 return true;
}



           Node * ObjectNode::Load( IOStream & stream )
{
 AStackString<> name; if ( stream.Read( name ) == false ) { return (0); };
 Dependencies staticDeps( 3, true ); if ( staticDeps.Load( stream ) == false ) { return (0); };
 Dependencies dynamicDeps( 0, true ); if ( dynamicDeps.Load( stream ) == false ) { return (0); };
 uint32_t flags; if ( stream.Read( flags ) == false ) { return (0); };
 AStackString<> compilerArgs; if ( stream.Read( compilerArgs ) == false ) { return (0); };
 AStackString<> compilerArgsDeoptimized; if ( stream.Read( compilerArgsDeoptimized ) == false ) { return (0); }
 AStackString<> objExtensionOverride; if ( stream.Read( objExtensionOverride ) == false ) { return (0); };
 Dependencies compilerForceUsing( 0, true ); if ( compilerForceUsing.Load( stream ) == false ) { return (0); };
 bool deoptimizeWritableFiles; if ( stream.Read( deoptimizeWritableFiles ) == false ) { return (0); };
 bool deoptimizeWritableFilesWithToken; if ( stream.Read( deoptimizeWritableFilesWithToken ) == false ) { return (0); };



 size_t numStaticDepsExcludingForceUsing = staticDeps.GetSize() - compilerForceUsing.GetSize();
 do { if ( !( ( numStaticDepsExcludingForceUsing == 2 ) || ( numStaticDepsExcludingForceUsing == 3 ) ) ) { if ( AssertHandler::Failure( "( numStaticDepsExcludingForceUsing == 2 ) || ( numStaticDepsExcludingForceUsing == 3 )",
 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/ObjectNode.cpp"
# 497 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/ObjectNode.cpp"
 ,
 498
# 497 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/ObjectNode.cpp"
 ) ) { __asm__ __volatile__("int $3"); } } } while ( false );
                                               ;

 do { if ( !( staticDeps.GetSize() >= 2 ) ) { if ( AssertHandler::Failure( "staticDeps.GetSize() >= 2", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/ObjectNode.cpp", 500 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;
 Node * compiler = staticDeps[ 0 ].GetNode();
 Node * staticDepNode = staticDeps[ 1 ].GetNode();

 Node * precompiledHeader = (0);
 if ( numStaticDepsExcludingForceUsing == 3 )
 {
  precompiledHeader = staticDeps[ 2 ].GetNode();
 }

 NodeGraph & ng = FBuild::Get().GetDependencyGraph();
 Node * on = ng.CreateObjectNode( name, staticDepNode, compiler, compilerArgs, compilerArgsDeoptimized, precompiledHeader, flags, compilerForceUsing, deoptimizeWritableFiles, deoptimizeWritableFilesWithToken );

 ObjectNode * objNode = on->CastTo< ObjectNode >();
 objNode->m_DynamicDependencies.Swap( dynamicDeps );
 objNode->m_ObjExtensionOverride = objExtensionOverride;

 return objNode;
}



           Node * ObjectNode::LoadRemote( IOStream & stream )
{
 AStackString<> name; if ( stream.Read( name ) == false ) { return (0); };
 AStackString<> sourceFile; if ( stream.Read( sourceFile ) == false ) { return (0); };
 uint32_t flags; if ( stream.Read( flags ) == false ) { return (0); };
 AStackString<> compilerArgs; if ( stream.Read( compilerArgs ) == false ) { return (0); };

 NodeProxy * srcFile = new ( "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/ObjectNode.cpp", 529 ) NodeProxy( sourceFile );

 return new ( "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/ObjectNode.cpp", 531 ) ObjectNode( name, srcFile, compilerArgs, flags );
}



           uint32_t ObjectNode::DetermineFlags( const Node * compilerNode, const AString & args )
{
 uint32_t flags = 0;

 const AString & compiler = compilerNode->GetName();
 const bool isDistributableCompiler = ( compilerNode->GetType() == Node::COMPILER_NODE ) &&
           ( compilerNode->CastTo< CompilerNode >()->CanBeDistributed() );


 if ( compiler.EndsWithI( "\\cl.exe" ) ||
   compiler.EndsWithI( "\\cl" ) )
 {
  flags |= ObjectNode::FLAG_MSVC;
 }
 else if ( compiler.EndsWithI( "clang++.exe" ) ||
     compiler.EndsWithI( "clang++" ) ||
     compiler.EndsWithI( "clang.exe" ) ||
     compiler.EndsWithI( "clang" ) ||
     compiler.EndsWithI( "clang-cl.exe" ) ||
     compiler.EndsWithI( "clang-cl" ) )
 {
  flags |= ObjectNode::FLAG_CLANG;
 }
 else if ( compiler.EndsWithI( "gcc.exe" ) ||
     compiler.EndsWithI( "gcc" ) ||
     compiler.EndsWithI( "g++.exe" ) ||
     compiler.EndsWithI( "g++" ) )
 {
  flags |= ObjectNode::FLAG_GCC;
 }
 else if ( compiler.EndsWithI( "\\ps3ppusnc.exe" ) ||
     compiler.EndsWithI( "\\ps3ppusnc" ) )
 {
  flags |= ObjectNode::FLAG_SNC;
 }
 else if ( compiler.EndsWithI( "\\mwcceppc.exe" ) ||
     compiler.EndsWithI( "\\mwcceppc" ) )
 {
  flags |= ObjectNode::CODEWARRIOR_WII;
 }
 else if ( compiler.EndsWithI( "\\cxppc.exe" ) ||
     compiler.EndsWithI( "\\cxppc" ) ||
     compiler.EndsWithI( "\\ccppc.exe" ) ||
     compiler.EndsWithI( "\\ccppc" ) )
 {
  flags |= ObjectNode::GREENHILLS_WIIU;
 }
 else if ( compiler.EndsWithI( "\\nvcc.exe" ) ||
     compiler.EndsWithI( "\\nvcc" ) )
 {
  flags |= ObjectNode::FLAG_CUDA_NVCC;
 }


 if ( flags & ObjectNode::FLAG_MSVC )
 {
  bool usingCLR = false;
  bool usingWinRT = false;

  Array< AString > tokens;
  args.Tokenize( tokens );
  const AString * const end = tokens.End();
  for ( const AString * it = tokens.Begin(); it != end; ++it )
  {
   const AString & token = *it;

   if ( ( token == "/Zi" ) || ( token == "/ZI" ) )
   {
    flags |= ObjectNode::FLAG_USING_PDB;
   }
   else if ( token == "/clr" )
   {
    usingCLR = true;
    flags |= ObjectNode::FLAG_USING_CLR;
   }
   else if ( token == "/ZW" )
   {
    usingWinRT = true;
   }
   else if ( token.BeginsWith( "/Yu" ) )
   {
    flags |= ObjectNode::FLAG_USING_PCH;
   }
   else if ( token.BeginsWith( "/Yc" ) )
   {
    flags |= ObjectNode::FLAG_CREATING_PCH;
   }
  }





  if ( !usingWinRT && !usingCLR && !( flags & ObjectNode::FLAG_CREATING_PCH ) )
  {
   if ( isDistributableCompiler )
   {
    flags |= ObjectNode::FLAG_CAN_BE_DISTRIBUTED;
   }


   if ( ( flags & ObjectNode::FLAG_USING_PDB ) == 0 )
   {
    flags |= ObjectNode::FLAG_CAN_BE_CACHED;
   }
  }
 }


 if ( flags & ObjectNode::FLAG_CLANG )
 {
  Array< AString > tokens;
  args.Tokenize( tokens );
  const AString * const end = tokens.End();
  for ( const AString * it = tokens.Begin(); it != end; ++it )
  {
   const AString & token = *it;
   if ( token == "-emit-pch" )
   {
    flags |= ObjectNode::FLAG_CREATING_PCH;
   }
   if ( token == "-x" )
   {
    ++it;
    if ( it != tokens.End() )
    {
     if ( ( *it == "c++-header" ) || ( *it == "c-header" ) )
     {
      flags |= ObjectNode::FLAG_CREATING_PCH;
     }
    }
   }
   else if ( token == "-include-pch" )
   {
    flags |= ObjectNode::FLAG_USING_PCH;
   }
  }
 }


 if ( flags & ( ObjectNode::FLAG_CLANG | ObjectNode::FLAG_GCC | ObjectNode::FLAG_SNC | ObjectNode::CODEWARRIOR_WII | ObjectNode::GREENHILLS_WIIU ) )
 {

  if ( !( flags & ObjectNode::FLAG_CREATING_PCH ) )
  {
   if ( isDistributableCompiler )
   {
    flags |= ObjectNode::FLAG_CAN_BE_DISTRIBUTED;
   }
  }


  flags |= ObjectNode::FLAG_CAN_BE_CACHED;
 }


 if ( flags & ObjectNode::FLAG_CUDA_NVCC )
 {

  flags |= ObjectNode::FLAG_CAN_BE_CACHED;
 }

 return flags;
}



            void ObjectNode::Save( IOStream & stream ) const
{
 stream.Write( m_Name );;
 m_StaticDependencies.Save( stream );;
 m_DynamicDependencies.Save( stream );;
 stream.Write( m_Flags );;
 stream.Write( m_CompilerArgs );;
 stream.Write( m_CompilerArgsDeoptimized );;
 stream.Write( m_ObjExtensionOverride );;
 m_CompilerForceUsing.Save( stream );;
 stream.Write( m_DeoptimizeWritableFiles );;
 stream.Write( m_DeoptimizeWritableFilesWithToken );;
}



            void ObjectNode::SaveRemote( IOStream & stream ) const
{

 do { if ( !( m_CompilerForceUsing.IsEmpty() ) ) { if ( AssertHandler::Failure( "m_CompilerForceUsing.IsEmpty()", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/ObjectNode.cpp", 722 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;


 stream.Write( m_Name );;
 stream.Write( GetSourceFile()->GetName() );;
 stream.Write( m_Flags );;



 const bool useDeoptimization = ShouldUseDeoptimization();
 if ( useDeoptimization )
 {
  stream.Write( m_CompilerArgsDeoptimized );;
 }
 else
 {
  stream.Write( m_CompilerArgs );;
 }
}



void ObjectNode::GetPDBName( AString & pdbName ) const
{
 do { if ( !( IsUsingPDB() ) ) { if ( AssertHandler::Failure( "IsUsingPDB()", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/ObjectNode.cpp", 746 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;
 pdbName = m_Name;
 pdbName += ".pdb";
}



            Node::Priority ObjectNode::GetPriority() const
{
 return IsCreatingPCH() ? Node::PRIORITY_HIGH : Node::PRIORITY_NORMAL;
}



const char * ObjectNode::GetObjExtension() const
{
 if ( m_ObjExtensionOverride.IsEmpty() )
 {
  return ".obj";
 }
 return m_ObjExtensionOverride.Get();
}



           void ObjectNode::DumpOutput( Job * job, const char * data, uint32_t dataSize, const AString & name )
{
 if ( ( data != (0) ) && ( dataSize > 0 ) )
 {
  Array< AString > exclusions( 2, false );
  exclusions.Append( AString( "Note: including file:" ) );
  exclusions.Append( AString( "#line" ) );

  AStackString<> msg;
  msg.Format( "PROBLEM: %s\n", name.Get() );

  AutoPtr< char > mem( (char *)Alloc( dataSize + msg.GetLength() ) );
  memcpy( mem.Get(), msg.Get(), msg.GetLength() );
  memcpy( mem.Get() + msg.GetLength(), data, dataSize );

  Node::DumpOutput( job, mem.Get(), dataSize + msg.GetLength(), &exclusions );
 }
}



const AString & ObjectNode::GetCacheName( Job * job ) const
{

 if ( job->GetCacheName().IsEmpty() == false )
 {
  return job->GetCacheName();
 }

 Timer t;


 do { if ( !( job->GetData() ) ) { if ( AssertHandler::Failure( "job->GetData()", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/ObjectNode.cpp", 803 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;
 uint64_t a1, a2;
 a1 = Murmur3::Calc128( job->GetData(), job->GetDataSize(), a2 );
 uint64_t a = a1 ^ a2;



 uint32_t b = Murmur3::Calc32( m_CompilerArgs.Get(), m_CompilerArgs.GetLength() );


 uint64_t c = GetCompiler()->CastTo< CompilerNode >()->GetManifest().GetToolId();

 AStackString<> cacheName;
 FBuild::Get().GetCacheFileName( a, b, c, cacheName );
 job->SetCacheName(cacheName);

 do { if ( FLog::ShowInfo() ) { FLog::Info( "Cache hash: %u ms - %u kb '%s'\n", uint32_t( t.GetElapsedMS() ), uint32_t( job->GetDataSize() / (1024) ), cacheName.Get() ); } } while ( false );


                     ;
 return job->GetCacheName();
}



bool ObjectNode::RetrieveFromCache( Job * job )
{
 if ( FBuild::Get().GetOptions().m_UseCacheRead == false )
 {
  return false;
 }

 const AString & cacheFileName = GetCacheName(job);

 Timer t;

 ICache * cache = FBuild::Get().GetCache();
 do { if ( !( cache ) ) { if ( AssertHandler::Failure( "cache", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/ObjectNode.cpp", 840 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;
 if ( cache )
 {
  void * cacheData( (0) );
  size_t cacheDataSize( 0 );
  if ( cache->Retrieve( cacheFileName, cacheData, cacheDataSize ) )
  {

   Compressor c;
   if ( c.IsValidData( cacheData, cacheDataSize ) == false )
   {
    do { FLog::Warning( "Cache returned invalid data for '%s'", m_Name.Get() ); } while ( false ); ;
    return false;
   }
   c.Decompress( cacheData );
   const void * data = c.GetResult();
   const size_t dataSize = c.GetResultSize();

   FileStream objFile;
   if ( !objFile.Open( m_Name.Get(), FileStream::WRITE_ONLY ) )
   {
    cache->FreeMemory( cacheData, cacheDataSize );
    do { FLog::Error( "Failed to open local file during cache retrieval '%s'", m_Name.Get() ); } while ( false ); ;
    return false;
   }

   if ( objFile.Write( data, dataSize ) != dataSize )
   {
    cache->FreeMemory( cacheData, cacheDataSize );
    do { FLog::Error( "Failed to write to local file during cache retrieval '%s'", m_Name.Get() ); } while ( false ); ;
    return false;
   }

   cache->FreeMemory( cacheData, cacheDataSize );
# 888 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/ObjectNode.cpp"
                const bool timeSetOK = ( utimes( m_Name.Get(), (0) ) == 0 );



            if ( timeSetOK == false )
   {
    do { FLog::Error( "Failed to set timestamp on file after cache hit '%s' (%u)", m_Name.Get(), Env::GetLastErr() ); } while ( false ); ;
    return false;
   }

   objFile.Close();

   FileIO::WorkAroundForWindowsFilePermissionProblem( m_Name );



   m_Stamp = FileIO::GetFileLastWriteTime( m_Name );

   do { if ( FLog::ShowInfo() ) { FLog::Info( "Cache hit: %u ms '%s'\n", uint32_t( t.GetElapsedMS() ), cacheFileName.Get() ); } } while ( false ); ;
   do { FLog::Build( "Obj: %s <CACHE>\n", GetName().Get() ); } while ( false ); ;
   SetStatFlag( Node::STATS_CACHE_HIT );
   return true;
  }
 }

 do { if ( FLog::ShowInfo() ) { FLog::Info( "Cache miss: %u ms '%s'\n", uint32_t( t.GetElapsedMS() ), cacheFileName.Get() ); } } while ( false ); ;
 SetStatFlag( Node::STATS_CACHE_MISS );
 return false;
}



void ObjectNode::WriteToCache( Job * job )
{
 if (FBuild::Get().GetOptions().m_UseCacheWrite == false)
 {
  return;
 }

 const AString & cacheFileName = GetCacheName(job);
 do { if ( !( !cacheFileName.IsEmpty() ) ) { if ( AssertHandler::Failure( "!cacheFileName.IsEmpty()", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/ObjectNode.cpp", 928 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;

 Timer t;

 ICache * cache = FBuild::Get().GetCache();
 do { if ( !( cache ) ) { if ( AssertHandler::Failure( "cache", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/ObjectNode.cpp", 933 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;
 if ( cache )
 {

  FileStream objFile;
  if ( objFile.Open( m_Name.Get(), FileStream::READ_ONLY ) )
  {

   const size_t objFileSize = (size_t)objFile.GetFileSize();
   AutoPtr< char > mem( (char *)::AllocFileLine( objFileSize, "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/ObjectNode.cpp", 942 ) );
   if ( objFile.Read( mem.Get(), objFileSize ) == objFileSize )
   {

    Compressor c;
    c.Compress( mem.Get(), objFileSize );
    const void * data = c.GetResult();
    const size_t dataSize = c.GetResultSize();

    if ( cache->Publish( cacheFileName, data, dataSize ) )
    {

     do { if ( FLog::ShowInfo() ) { FLog::Info( "Cache store: %u ms '%s'\n", uint32_t( t.GetElapsedMS() ), cacheFileName.Get() ); } } while ( false ); ;
     SetStatFlag( Node::STATS_CACHE_STORE );
     return;
    }
   }
  }
 }

 do { if ( FLog::ShowInfo() ) { FLog::Info( "Cache store fail: %u ms '%s'\n", uint32_t( t.GetElapsedMS() ), cacheFileName.Get() ); } } while ( false ); ;
}



void ObjectNode::EmitCompilationMessage( const AString & fullArgs, bool useDeoptimization, bool stealingRemoteJob, bool racingRemoteJob ) const
{



 AStackString<> output;
 output += "Obj: ";
 if ( useDeoptimization )
 {
  output += "**Deoptimized** ";
 }
 output += GetName();
 if ( racingRemoteJob )
 {
  output += " <LOCAL RACE>";
 }
 else if ( stealingRemoteJob )
 {
  output += " <LOCAL>";
 }
 output += '\n';
 if ( FLog::ShowInfo() || FBuild::Get().GetOptions().m_ShowCommandLines )
 {
  output += GetCompiler()->GetName();
  output += ' ';
  output += fullArgs;
  output += '\n';
 }
 do { FLog::Build( "%s", output.Get() ); } while ( false ); ;
}



           bool ObjectNode::StripTokenWithArg( const char * tokenToCheckFor, const AString & token, size_t & index )
{
 if ( token.BeginsWith( tokenToCheckFor ) )
 {
  if ( token == tokenToCheckFor )
  {
   ++index;
  }
  return true;
 }
 return false;
}



           bool ObjectNode::StripToken( const char * tokenToCheckFor, const AString & token, bool allowStartsWith )
{
 if ( allowStartsWith )
 {
  return token.BeginsWith( tokenToCheckFor );
 }
 else
 {
  return ( token == tokenToCheckFor );
 }
}



void ObjectNode::BuildFullArgs( const Job * job, AString & fullArgs, Pass pass, bool useDeoptimization ) const
{
 Array< AString > tokens( 1024, true );
 if ( useDeoptimization )
 {
  do { if ( !( !m_CompilerArgsDeoptimized.IsEmpty() ) ) { if ( AssertHandler::Failure( "!m_CompilerArgsDeoptimized.IsEmpty()", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/ObjectNode.cpp", 1034 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;
  m_CompilerArgsDeoptimized.Tokenize( tokens );
 }
 else
 {
  m_CompilerArgs.Tokenize( tokens );
 }
 fullArgs.Clear();

 const size_t numTokens = tokens.GetSize();
 for ( size_t i = 0; i < numTokens; ++i )
 {

  const AString & token = tokens[ i ];


  if ( pass == PASS_PREPROCESSOR_ONLY )
  {
   if ( GetFlag( FLAG_GCC ) || GetFlag( FLAG_SNC ) || GetFlag( FLAG_CLANG ) || GetFlag( CODEWARRIOR_WII ) || GetFlag( GREENHILLS_WIIU ) || GetFlag( FLAG_CUDA_NVCC ) )
   {
    if ( StripTokenWithArg( "-o", token, i ) )
    {
     continue;
    }

    if ( StripToken( "-c", token ) )
    {
     continue;
    }
   }
  }

  if ( GetFlag( FLAG_CLANG ) )
  {



   if ( pass != PASS_COMPILE )
   {
    if ( StripTokenWithArg( "-include-pch", token, i ) )
    {
     continue;
    }
   }
  }

  if ( GetFlag( FLAG_MSVC ) )
  {
   if ( pass == PASS_COMPILE_PREPROCESSED )
   {


    if ( StripTokenWithArg( "/Yu", token, i ) )
    {
     continue;
    }
    if ( StripTokenWithArg( "/Fp", token, i ) )
    {
     continue;
    }


    if ( job->IsLocal() == false )
    {
     if ( StripTokenWithArg( "/Fd", token, i ) )
     {
      continue;
     }
    }
   }
  }

  if ( GetFlag( FLAG_MSVC ) )
  {

   if ( StripToken( "/MP", token, true ) )
   {
    continue;
   }
  }


  if ( pass == PASS_COMPILE_PREPROCESSED )
  {
   if ( GetFlag( FLAG_CLANG ) )
   {


    if ( StripTokenWithArg( "-I", token, i ) )
    {
     continue;
    }
   }
   if ( GetFlag( FLAG_MSVC ) )
   {




    if ( StripTokenWithArg( "/FI", token, i ) )
    {
     continue;
    }
   }
  }


  const char * found = token.Find( "%1" );
  if ( found )
  {
   fullArgs += AStackString<>( token.Get(), found );
   fullArgs += GetSourceFile()->GetName();
   fullArgs += AStackString<>( found + 2, token.GetEnd() );
   fullArgs += ' ';
   continue;
  }


  found = token.Find( "%2" );
  if ( found )
  {
   fullArgs += AStackString<>( token.Get(), found );
   fullArgs += m_Name;
   fullArgs += AStackString<>( found + 2, token.GetEnd() );
   fullArgs += ' ';
   continue;
  }


  if ( GetFlag( FLAG_MSVC ) )
  {
   found = token.Find( "%3" );
   if ( found )
   {

    fullArgs += AStackString<>( token.Get(), found );
    fullArgs += m_Name;
    fullArgs += GetObjExtension();
    fullArgs += AStackString<>( found + 2, token.GetEnd() );
    fullArgs += ' ';
    continue;
   }
  }


  if ( GetFlag( FLAG_MSVC ) )
  {
   found = token.Find( "%4" );
   if ( found )
   {
    AStackString<> pre( token.Get(), found );
    AStackString<> post( found + 2, token.GetEnd() );
    ExpandTokenList( m_CompilerForceUsing, fullArgs, pre, post );
    fullArgs += ' ';
    continue;
   }
  }


  fullArgs += token;
  fullArgs += ' ';
 }

 if ( pass == PASS_PREPROCESSOR_ONLY )
 {
  if ( GetFlag( FLAG_MSVC ) )
  {
   fullArgs += "/E";
  }
  else
  {
   do { if ( !( GetFlag( FLAG_GCC ) || GetFlag( FLAG_SNC ) || GetFlag( FLAG_CLANG ) || GetFlag( CODEWARRIOR_WII ) || GetFlag( GREENHILLS_WIIU ) || GetFlag( FLAG_CUDA_NVCC ) ) ) { if ( AssertHandler::Failure( "GetFlag( FLAG_GCC ) || GetFlag( FLAG_SNC ) || GetFlag( FLAG_CLANG ) || GetFlag( CODEWARRIOR_WII ) || GetFlag( GREENHILLS_WIIU ) || GetFlag( FLAG_CUDA_NVCC )", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/ObjectNode.cpp", 1205 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;
   fullArgs += "-E";
  }
 }


 if ( ( job->IsLocal() == false ) &&
   ( job->GetNode()->CastTo< ObjectNode >()->IsUsingPDB() ) )
 {
  AStackString<> pdbName, tmp;
  GetPDBName( pdbName );
  tmp.Format( " /Fd\"%s\"", pdbName.Get() );
  fullArgs += tmp;
 }
}



void ObjectNode::ExpandTokenList( const Dependencies & nodes, AString & fullArgs, const AString & pre, const AString & post ) const
{
 const Dependency * const end = nodes.End();
 for ( const Dependency * it = nodes.Begin(); it != end; ++it )
 {
  Node * n = it->GetNode();

  fullArgs += pre;
  fullArgs += n->GetName();
  fullArgs += post;
  fullArgs += ' ';
 }
}



bool ObjectNode::BuildPreprocessedOutput( const AString & fullArgs, Job * job, bool useDeoptimization ) const
{
 EmitCompilationMessage( fullArgs, useDeoptimization );


 CompileHelper ch( false );



        const bool useResponseFile = false;

 if ( !ch.SpawnCompiler( job, GetName(), GetCompiler()->GetName(), fullArgs, useResponseFile ) )
 {



  if ( ch.GetResult() != 0 )
  {
   DumpOutput( job, ch.GetErr().Get(), ch.GetErrSize(), GetName() );
  }

  return false;
 }


 char * memCopy = (char *)::AllocFileLine( ch.GetOutSize() + 1, "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/ObjectNode.cpp", 1264 );
 memcpy( memCopy, ch.GetOut().Get(), ch.GetOutSize() );
 memCopy[ ch.GetOutSize() ] = 0;

 job->OwnData( memCopy, ch.GetOutSize() );

 return true;
}



bool ObjectNode::WriteTmpFile( Job * job, AString & tmpFileName ) const
{
 do { if ( !( job->GetData() && job->GetDataSize() ) ) { if ( AssertHandler::Failure( "job->GetData() && job->GetDataSize()", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/ObjectNode.cpp", 1277 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;

 Node * sourceFile = GetSourceFile();

 FileStream tmpFile;
 AStackString<> fileName( sourceFile->GetName().FindLast( ( '/' ) ) + 1 );




 if ( GetFlag( FLAG_GCC ) || GetFlag( CODEWARRIOR_WII ) || GetFlag( GREENHILLS_WIIU ) )
 {




  const char * tmpFileExt = fileName.FindLast( '.' );
  tmpFileExt = tmpFileExt ? ( tmpFileExt + 1 ) : fileName.Get();
  tmpFileExt = ( strcmp( tmpFileExt, "c" ) == 0 ) ? "i" : "ii";
 }

 void const * dataToWrite = job->GetData();
 size_t dataToWriteSize = job->GetDataSize();


 Compressor c;
 if ( job->IsDataCompressed() )
 {
  c.Decompress( dataToWrite );
  dataToWrite = c.GetResult();
  dataToWriteSize = c.GetResultSize();
 }

 WorkerThread::CreateTempFilePath( fileName.Get(), tmpFileName );
 if ( WorkerThread::CreateTempFile( tmpFileName, tmpFile ) == false )
 {
  job->Error( "Failed to create temp file '%s' to build '%s' (error %u)", tmpFileName.Get(), GetName().Get(), Env::GetLastErr );
  job->OnSystemError();
  return NODE_RESULT_FAILED;
 }
 if ( tmpFile.Write( dataToWrite, dataToWriteSize ) != dataToWriteSize )
 {
  job->Error( "Failed to write to temp file '%s' to build '%s' (error %u)", tmpFileName.Get(), GetName().Get(), Env::GetLastErr );
  job->OnSystemError();
  return NODE_RESULT_FAILED;
 }
 tmpFile.Close();

 FileIO::WorkAroundForWindowsFilePermissionProblem( tmpFileName );

 return true;
}



bool ObjectNode::BuildFinalOutput( Job * job, const AString & fullArgs ) const
{

 AStackString<> compiler;
 AStackString<> workingDir;
 if ( job->IsLocal() )
 {
  compiler = GetCompiler()->GetName();
 }
 else
 {
  do { if ( !( job->GetToolManifest() ) ) { if ( AssertHandler::Failure( "job->GetToolManifest()", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/ObjectNode.cpp", 1343 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;
  job->GetToolManifest()->GetRemoteFilePath( 0, compiler );
  job->GetToolManifest()->GetRemotePath( workingDir );
 }


 CompileHelper ch;



        const bool useResponseFile = false;

 if ( !ch.SpawnCompiler( job, GetName(), compiler, fullArgs, useResponseFile, workingDir.IsEmpty() ? (0) : workingDir.Get() ) )
 {

  if ( ch.GetResult() != 0 )
  {



   if ( job->IsLocal() == false )
   {
    AutoPtr< char > mem( (char *)::AllocFileLine( ch.GetOutSize() + ch.GetErrSize(), "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/ObjectNode.cpp", 1365 ) );
    memcpy( mem.Get(), ch.GetOut().Get(), ch.GetOutSize() );
    memcpy( mem.Get() + ch.GetOutSize(), ch.GetErr().Get(), ch.GetErrSize() );
    job->OwnData( mem.Release(), ( ch.GetOutSize() + ch.GetErrSize() ) );
   }
  }

  return false;
 }

 return true;
}



ObjectNode::CompileHelper::CompileHelper( bool handleOutput )
 : m_HandleOutput( handleOutput )
 , m_OutSize( 0 )
 , m_ErrSize( 0 )
 , m_Result( 0 )
{
}



ObjectNode::CompileHelper::~CompileHelper()
{
}



bool ObjectNode::CompileHelper::SpawnCompiler( Job * job,
              const AString & name,
              const AString & compiler,
              const AString & fullArgs,
              bool useResponseFile,
              const char * workingDir )
{

 ResponseFile rf;
 AStackString<> responseFileArgs;
 if ( useResponseFile )
 {

  if ( !rf.Create( fullArgs ) )
  {
   return false;
  }


  responseFileArgs.Format( "@\"%s\"", rf.GetResponseFilePath().Get() );
 }

 const char * environmentString = ( FBuild::IsValid() ? FBuild::Get().GetEnvironmentString() : (0) );
 if ( ( job->IsLocal() == false ) && ( job->GetToolManifest() ) )
 {
  environmentString = job->GetToolManifest()->GetRemoteEnvironmentString();
 }


 if ( false == m_Process.Spawn( compiler.Get(),
           useResponseFile ? responseFileArgs.Get() : fullArgs.Get(),
           workingDir,
           environmentString ) )
 {
  job->Error( "Failed to spawn process (error 0x%x) to build '%s'\n", Env::GetLastErr(), name.Get() );
  job->OnSystemError();
  return false;
 }


 m_Process.ReadAllData( m_Out, &m_OutSize, m_Err, &m_ErrSize );


 do { if ( !( !m_Process.IsRunning() ) ) { if ( AssertHandler::Failure( "!m_Process.IsRunning()", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/ObjectNode.cpp", 1439 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;
 m_Result = m_Process.WaitForExit();


 HandleSystemFailures( job, m_Result, m_Out.Get(), m_Err.Get() );


 if ( m_HandleOutput && m_Err.Get() )
 {
  DumpOutput( job, m_Err.Get(), m_ErrSize, name );
 }


 if ( m_Result != 0 )
 {

  if ( m_HandleOutput )
  {
   DumpOutput( job, m_Out.Get(), m_OutSize, name );
  }

  job->Error( "Failed to build Object (error 0x%x) '%s'\n", m_Result, name.Get() );

  return false;
 }

 return true;
}



           void ObjectNode::HandleSystemFailures( Job * job, int result, const char * stdOut, const char * stdErr )
{

 if ( job->IsLocal() )
 {
  return;
 }


 if ( result == 0 )
 {
  return;
 }
# 1562 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/ObjectNode.cpp"
  (void)stdOut;
  (void)stdErr;

}



bool ObjectNode::ShouldUseDeoptimization() const
{
 if ( GetFlag( FLAG_UNITY ) )
 {
  return false;
 }

 if ( ( m_DeoptimizeWritableFilesWithToken == false ) &&
   ( m_DeoptimizeWritableFiles == false ) )
 {
  return false;
 }

 if ( FileIO::GetReadOnly( GetSourceFile()->GetName() ) )
 {
  return false;
 }

 if ( m_DeoptimizeWritableFiles )
 {
  return true;
 }


 FileStream fs;
 if ( fs.Open( GetSourceFile()->GetName().Get(), FileStream::READ_ONLY ) )
 {
  const size_t bytesToRead = Math::Min< size_t >( 1024, (size_t)fs.GetFileSize() );
  char buffer[ 1025 ];
  if ( fs.Read( buffer, bytesToRead ) == bytesToRead )
  {
   buffer[ bytesToRead ] = 0;
   if ( strstr( buffer, "FASTBUILD_DEOPTIMIZE_OBJECT" ) )
   {
    return true;
   }
   return false;
  }
 }


 return false;
}



bool ObjectNode::ShouldUseCache() const
{
 bool useCache = GetFlag( FLAG_CAN_BE_CACHED ) &&
     ( FBuild::Get().GetOptions().m_UseCacheRead ||
      FBuild::Get().GetOptions().m_UseCacheWrite );
 if ( GetFlag( FLAG_ISOLATED_FROM_UNITY ) )
 {

  useCache = false;
 }
 return useCache;
}
# 182 "/home/ffulin/p4/tmp/Unity/Tools/FBuild/FBuildCore/Unity1.cpp" 2


# 1 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/LibraryNode.cpp" 1





# 1 "./Tools/FBuild/FBuildCore/PrecompiledHeader.h" 1
# 7 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/LibraryNode.cpp" 2
# 29 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/LibraryNode.cpp"
LibraryNode::LibraryNode( const AString & libraryName,
        const Dependencies & inputNodes,
        CompilerNode * compiler,
        const AString & compilerArgs,
        const AString & compilerArgsDeoptimized,
        const AString & compilerOutputPath,
        const AString & librarian,
        const AString & librarianArgs,
        uint32_t flags,
        ObjectNode * precompiledHeader,
        const Dependencies & compilerForceUsing,
        const Dependencies & preBuildDependencies,
        const Dependencies & additionalInputs,
        bool deoptimizeWritableFiles,
        bool deoptimizeWritableFilesWithToken )
: FileNode( libraryName, Node::FLAG_NONE )
, m_CompilerForceUsing( compilerForceUsing )
, m_AdditionalInputs( additionalInputs )
, m_DeoptimizeWritableFiles( deoptimizeWritableFiles )
, m_DeoptimizeWritableFilesWithToken( deoptimizeWritableFilesWithToken )
{
 m_Type = LIBRARY_NODE;
 m_LastBuildTimeMs = 1000;


 m_StaticDependencies = inputNodes;


 m_PrecompiledHeader = precompiledHeader;


 m_Compiler = compiler;
 m_CompilerArgs = compilerArgs;
 m_CompilerArgsDeoptimized = compilerArgsDeoptimized;
 m_CompilerOutputPath = compilerOutputPath;
 m_LibrarianPath = librarian;
 m_LibrarianArgs = librarianArgs;
 m_Flags = flags;

 m_PreBuildDependencies = preBuildDependencies;
}



LibraryNode::~LibraryNode()
{
}



            bool LibraryNode::DoDynamicDependencies( bool forceClean )
{
 (void)forceClean;


 m_DynamicDependencies.Clear();



 Node * pchCPP = (0);
 if ( m_PrecompiledHeader )
 {
  do { if ( !( m_PrecompiledHeader->GetType() == Node::OBJECT_NODE ) ) { if ( AssertHandler::Failure( "m_PrecompiledHeader->GetType() == Node::OBJECT_NODE", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/LibraryNode.cpp", 91 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;
  pchCPP = m_PrecompiledHeader->GetPrecompiledHeaderCPPFile();
 }

 NodeGraph & ng = FBuild::Get().GetDependencyGraph();


 for ( Dependencies::Iter i = m_StaticDependencies.Begin();
    i != m_StaticDependencies.End();
    i++ )
 {

  if ( i->GetNode()->GetType() == Node::DIRECTORY_LIST_NODE )
  {

   DirectoryListNode * dln = i->GetNode()->CastTo< DirectoryListNode >();
   const Array< FileIO::FileInfo > & files = dln->GetFiles();
   m_DynamicDependencies.SetCapacity( m_DynamicDependencies.GetSize() + files.GetSize() );
   for ( Array< FileIO::FileInfo >::Iter fIt = files.Begin();
     fIt != files.End();
     fIt++ )
   {

    Node * n = ng.FindNode( fIt->m_Name );
    if ( n == (0) )
    {
     n = ng.CreateFileNode( fIt->m_Name );
    }
    else if ( n->IsAFile() == false )
    {
     do { FLog::Error( "Library() .CompilerInputFile '%s' is not a FileNode (type: %s)", n->GetName().Get(), n->GetTypeName() ); } while ( false ); ;
     return false;
    }



    if ( pchCPP && ( n == pchCPP ) )
    {
     continue;
    }


    if ( CreateDynamicObjectNode( n ) == false )
    {
     return false;
    }
   }
  }
  else if ( i->GetNode()->GetType() == Node::FILE_NODE )
  {

   if ( CreateDynamicObjectNode( i->GetNode() ) == false )
   {
    return false;
   }
  }
  else if ( i->GetNode()->GetType() == Node::UNITY_NODE )
  {

   UnityNode * un = i->GetNode()->CastTo< UnityNode >();


   const Array< AString > & unityFiles = un->GetUnityFileNames();
   for ( Array< AString >::Iter it = unityFiles.Begin();
      it != unityFiles.End();
      it++ )
   {
    Node * n = ng.FindNode( *it );
    if ( n == (0) )
    {
     n = ng.CreateFileNode( *it );
    }
    else if ( n->IsAFile() == false )
    {
     do { FLog::Error( "Library() .CompilerInputUnity '%s' is not a FileNode (type: %s)", n->GetName().Get(), n->GetTypeName() ); } while ( false ); ;
     return false;
    }


    if ( CreateDynamicObjectNode( n, true ) == false )
    {
     return false;
    }
   }


   const Array< AString > & isolatedFiles = un->GetIsolatedFileNames();
   for ( Array< AString >::Iter it = isolatedFiles.Begin();
      it != isolatedFiles.End();
      it++ )
   {
    Node * n = ng.FindNode( *it );
    if ( n == (0) )
    {
     n = ng.CreateFileNode( *it );
    }
    else if ( n->IsAFile() == false )
    {
     do { FLog::Error( "Library() Isolated '%s' is not a FileNode (type: %s)", n->GetName().Get(), n->GetTypeName() ); } while ( false ); ;
     return false;
    }


    if ( CreateDynamicObjectNode( n, false, true ) == false )
    {
     return false;
    }
   }
  }
  else
  {
   do { if ( !( false ) ) { if ( AssertHandler::Failure( "false", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/LibraryNode.cpp", 202 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;
  }
 }
# 213 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/LibraryNode.cpp"
 if ( m_PrecompiledHeader )
 {
  m_DynamicDependencies.Append( Dependency( m_PrecompiledHeader ) );
 }


 m_DynamicDependencies.Append( m_AdditionalInputs );



 if ( m_DynamicDependencies.GetSize() == 0 )
 {
  do { FLog::Error( "No files found to build '%s'", GetName().Get() ); } while ( false ); ;
  return false;
 }

 return true;
}



            Node::BuildResult LibraryNode::DoBuild( Job * )
{

 if ( FileIO::FileExists( GetName().Get() ) )
 {
  FileIO::FileDelete( GetName().Get() );
 }


 AStackString< 4 * (1024) > fullArgs;
 GetFullArgs( fullArgs );


 const char * workingDir = (0);

 const char * environment = FBuild::Get().GetEnvironmentString();

 EmitCompilationMessage( fullArgs );


 ResponseFile rf;
 AStackString<> responseFileArgs;

        const bool useResponseFile = false;



 if ( useResponseFile )
 {

  if ( GetFlag( LIB_FLAG_ORBIS_AR ) )
  {
   rf.SetEscapeSlashes();
  }


  if ( !rf.Create( fullArgs ) )
  {
   return NODE_RESULT_FAILED;
  }


  responseFileArgs.Format( "@\"%s\"", rf.GetResponseFilePath().Get() );
 }


 Process p;
 bool spawnOK = p.Spawn( m_LibrarianPath.Get(),
       useResponseFile ? responseFileArgs.Get() : fullArgs.Get(),
       workingDir,
       environment );

 if ( !spawnOK )
 {
  do { FLog::Error( "Failed to spawn process for Library creation for '%s'", GetName().Get() ); } while ( false ); ;
  return NODE_RESULT_FAILED;
 }


 AutoPtr< char > memOut;
 AutoPtr< char > memErr;
 uint32_t memOutSize = 0;
 uint32_t memErrSize = 0;
 p.ReadAllData( memOut, &memOutSize, memErr, &memErrSize );

 do { if ( !( !p.IsRunning() ) ) { if ( AssertHandler::Failure( "!p.IsRunning()", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/LibraryNode.cpp", 299 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;

 int result = p.WaitForExit();

 if ( result != 0 )
 {
  if ( memOut.Get() ) { do { FLog::ErrorDirect( memOut.Get() ); } while ( false ); ; }
  if ( memErr.Get() ) { do { FLog::ErrorDirect( memErr.Get() ); } while ( false ); ; }
 }


 if ( result != 0 )
 {
  do { FLog::Error( "Failed to build Library (error %i) '%s'", result, GetName().Get() ); } while ( false ); ;
  return NODE_RESULT_FAILED;
 }


 m_Stamp = FileIO::GetFileLastWriteTime( m_Name );
 do { if ( !( m_Stamp ) ) { if ( AssertHandler::Failure( "m_Stamp", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/LibraryNode.cpp", 318 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;

 return NODE_RESULT_OK;
}



void LibraryNode::GetFullArgs( AString & fullArgs ) const
{
 Array< AString > tokens( 1024, true );
 m_LibrarianArgs.Tokenize( tokens );

 const AString * const end = tokens.End();
 for ( const AString * it = tokens.Begin(); it!=end; ++it )
 {
  const AString & token = *it;
  if ( token.EndsWith( "%1" ) )
  {

   AStackString<> pre;
   if ( token.GetLength() > 2 )
   {
    pre.Assign( token.Get(), token.GetEnd() - 2 );
   }


   GetInputFiles( fullArgs, pre, AString::GetEmpty() );
  }
  else if ( token.EndsWith( "\"%1\"" ) )
  {

   AStackString<> pre( token.Get(), token.GetEnd() - 3 );
   AStackString<> post( "\"" );


   GetInputFiles( fullArgs, pre, post );
  }
  else if ( token.EndsWith( "%2" ) )
  {

   if ( token.GetLength() > 2 )
   {
    fullArgs += AStackString<>( token.Get(), token.GetEnd() - 2 );
   }
   fullArgs += m_Name;
  }
  else if ( token.EndsWith( "\"%2\"" ) )
  {

   AStackString<> pre( token.Get(), token.GetEnd() - 3 );
   fullArgs += pre;
   fullArgs += m_Name;
   fullArgs += '"';
  }
  else
  {
   fullArgs += token;
  }

  fullArgs += ' ';
 }
}



void LibraryNode::GetInputFiles( AString & fullArgs, const AString & pre, const AString & post ) const
{
 for ( Dependencies::Iter i = m_DynamicDependencies.Begin();
    i != m_DynamicDependencies.End();
    i++ )
 {
  const Node * n = i->GetNode();


  if ( n->GetType() == Node::OBJECT_NODE )
  {

   const ObjectNode * on = n->CastTo< ObjectNode >();
   if ( on->IsCreatingPCH() )
   {
    if ( on->IsMSVC() )
    {
     fullArgs += pre;
     fullArgs += on->GetName();
     fullArgs += on->GetObjExtension();
     fullArgs += post;
     fullArgs += ' ';
     continue;
    }
    else
    {

     continue;
    }
   }
  }


  if ( n->GetType() == Node::OBJECT_LIST_NODE )
  {

   ObjectListNode * oln = n->CastTo< ObjectListNode >();
   oln->GetInputFiles( fullArgs, pre, post );
   continue;
  }


  fullArgs += pre;
  fullArgs += n->GetName();
  fullArgs += post;
  fullArgs += ' ';
 }
}



           uint32_t LibraryNode::DetermineFlags( const AString & librarianName )
{
 uint32_t flags = 0;
 if ( librarianName.EndsWithI("lib.exe") ||
   librarianName.EndsWithI("lib") )
 {
  flags |= LIB_FLAG_LIB;
 }
 else if ( librarianName.EndsWithI("ar.exe") ||
   librarianName.EndsWithI("ar") )
 {
  if ( librarianName.FindI( "orbis-ar" ) )
  {
   flags |= LIB_FLAG_ORBIS_AR;
  }
  else
  {
   flags |= LIB_FLAG_AR;
  }
 }
 else if ( librarianName.EndsWithI( "\\ax.exe" ) ||
     librarianName.EndsWithI( "\\ax" ) )
 {
  flags |= LIB_FLAG_GREENHILLS_AX;
 }
 return flags;
}



bool LibraryNode::CreateDynamicObjectNode( Node * inputFile, bool isUnityNode, bool isIsolatedFromUnityNode )
{
 const AString & fileName = inputFile->GetName();



 const char * lastSlash = fileName.FindLast( ( '/' ) );
 lastSlash = lastSlash ? ( lastSlash + 1 ) : fileName.Get();
 const char * lastDot = fileName.FindLast( '.' );
 lastDot = lastDot && ( lastDot > lastSlash ) ? lastDot : fileName.GetEnd();
 AStackString<> fileNameOnly( lastSlash, lastDot );
 AStackString<> objFile( m_CompilerOutputPath );
 objFile += fileNameOnly;
 objFile += GetObjExtension();



 NodeGraph & ng = FBuild::Get().GetDependencyGraph();
 Node * on = ng.FindNode( objFile );
 if ( on == (0) )
 {
  uint32_t flags = ObjectNode::DetermineFlags( m_Compiler, m_CompilerArgs );
  if ( isUnityNode )
  {
   flags |= ObjectNode::FLAG_UNITY;
  }
  if ( isIsolatedFromUnityNode )
  {
   flags |= ObjectNode::FLAG_ISOLATED_FROM_UNITY;
  }

  on = ng.CreateObjectNode( objFile, inputFile, m_Compiler, m_CompilerArgs, m_CompilerArgsDeoptimized, m_PrecompiledHeader, flags, m_CompilerForceUsing, m_DeoptimizeWritableFiles, m_DeoptimizeWritableFilesWithToken );
 }
 else if ( on->GetType() != Node::OBJECT_NODE )
 {
  do { FLog::Error( "Node '%s' is not an ObjectNode (type: %s)", on->GetName().Get(), on->GetTypeName() ); } while ( false ); ;
  return false;
 }
 else
 {
  ObjectNode * other = on->CastTo< ObjectNode >();
  if ( inputFile != other->GetSourceFile() )
  {
   do { FLog::Error( "Conflicting objects found:\n" " File A: %s\n" " File B: %s\n" " Both compile to: %s\n", inputFile->GetName().Get(), other->GetSourceFile()->GetName().Get(), objFile.Get() ); } while ( false );





                     ;
   return false;
  }
 }
 m_DynamicDependencies.Append( Dependency( on ) );
 return true;
}



void LibraryNode::EmitCompilationMessage( const AString & fullArgs ) const
{
 AStackString<> output;
 output += "Lib: ";
 output += GetName();
 output += '\n';
 if ( FLog::ShowInfo() || FBuild::Get().GetOptions().m_ShowCommandLines )
 {
  output += m_LibrarianPath;
  output += ' ';
  output += fullArgs;
  output += '\n';
 }
 do { FLog::Build( "%s", output.Get() ); } while ( false ); ;
}



           Node * LibraryNode::Load( IOStream & stream )
{
 AStackString<> name; if ( stream.Read( name ) == false ) { return (0); };
 CompilerNode * compilerNode = (0); if ( Node::LoadNode( stream, compilerNode ) == false ) { return (0); };
 AStackString<> compilerArgs; if ( stream.Read( compilerArgs ) == false ) { return (0); };
 AStackString<> compilerArgsDeoptimized; if ( stream.Read( compilerArgsDeoptimized ) == false ) { return (0); };
 AStackString<> compilerOutputPath; if ( stream.Read( compilerOutputPath ) == false ) { return (0); };
 AStackString<> librarianPath; if ( stream.Read( librarianPath ) == false ) { return (0); };
 AStackString<> librarianArgs; if ( stream.Read( librarianArgs ) == false ) { return (0); };
 uint32_t flags; if ( stream.Read( flags ) == false ) { return (0); };
 Dependencies staticDeps( 16, true ); if ( staticDeps.Load( stream ) == false ) { return (0); };
 Node * precompiledHeader = (0); if ( Node::LoadNode( stream, precompiledHeader ) == false ) { return (0); };
 AStackString<> objExtensionOverride; if ( stream.Read( objExtensionOverride ) == false ) { return (0); };
 Dependencies compilerForceUsing( 0, true ); if ( compilerForceUsing.Load( stream ) == false ) { return (0); };
 Dependencies preBuildDependencies( 0, true ); if ( preBuildDependencies.Load( stream ) == false ) { return (0); };
 Dependencies additionalInputs( 0, true ); if ( additionalInputs.Load( stream ) == false ) { return (0); };
 bool deoptimizeWritableFiles; if ( stream.Read( deoptimizeWritableFiles ) == false ) { return (0); };
 bool deoptimizeWritableFilesWithToken; if ( stream.Read( deoptimizeWritableFilesWithToken ) == false ) { return (0); };

 NodeGraph & ng = FBuild::Get().GetDependencyGraph();
 LibraryNode * n = ng.CreateLibraryNode( name,
         staticDeps,
         compilerNode,
         compilerArgs,
         compilerArgsDeoptimized,
         compilerOutputPath,
         librarianPath,
         librarianArgs,
         flags,
         precompiledHeader ? precompiledHeader->CastTo< ObjectNode >() : (0),
         compilerForceUsing,
         preBuildDependencies,
         additionalInputs,
         deoptimizeWritableFiles,
         deoptimizeWritableFilesWithToken );
 n->m_ObjExtensionOverride = objExtensionOverride;
# 586 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/LibraryNode.cpp"
 return n;
}



            void LibraryNode::Save( IOStream & stream ) const
{
 stream.Write( m_Name );;
 Node::SaveNode( stream, m_Compiler );;
 stream.Write( m_CompilerArgs );;
 stream.Write( m_CompilerArgsDeoptimized );;
 stream.Write( m_CompilerOutputPath );;
 stream.Write( m_LibrarianPath );;
 stream.Write( m_LibrarianArgs );;
 stream.Write( m_Flags );;
 m_StaticDependencies.Save( stream );;
 Node::SaveNode( stream, m_PrecompiledHeader );;
 stream.Write( m_ObjExtensionOverride );;
 m_CompilerForceUsing.Save( stream );;
 m_PreBuildDependencies.Save( stream );;
 m_AdditionalInputs.Save( stream );;
 stream.Write( m_DeoptimizeWritableFiles );;
 stream.Write( m_DeoptimizeWritableFilesWithToken );;






}



const char * LibraryNode::GetObjExtension() const
{
 if ( m_ObjExtensionOverride.IsEmpty() )
 {
  return ".obj";
 }
 return m_ObjExtensionOverride.Get();
}
# 185 "/home/ffulin/p4/tmp/Unity/Tools/FBuild/FBuildCore/Unity1.cpp" 2


# 1 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/ExecNode.cpp" 1





# 1 "./Tools/FBuild/FBuildCore/PrecompiledHeader.h" 1
# 7 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/ExecNode.cpp" 2
# 22 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/ExecNode.cpp"
ExecNode::ExecNode( const AString & dstFileName,
         FileNode * sourceFile,
      FileNode * executable,
      const AString & arguments,
      const AString & workingDir,
      int32_t expectedReturnCode,
      const Dependencies & preBuildDependencies )
: FileNode( dstFileName, Node::FLAG_NONE )
, m_SourceFile( sourceFile )
, m_Executable( executable )
, m_Arguments( arguments )
, m_WorkingDir( workingDir )
, m_ExpectedReturnCode( expectedReturnCode )
{
 do { if ( !( sourceFile ) ) { if ( AssertHandler::Failure( "sourceFile", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/ExecNode.cpp", 36 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;
 do { if ( !( executable ) ) { if ( AssertHandler::Failure( "executable", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/ExecNode.cpp", 37 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;
 m_StaticDependencies.SetCapacity( 2 );
 m_StaticDependencies.Append( Dependency( sourceFile ) );
 m_StaticDependencies.Append( Dependency( executable ) );
 m_Type = EXEC_NODE;

 m_PreBuildDependencies = preBuildDependencies;
}



ExecNode::~ExecNode()
{
}



            Node::BuildResult ExecNode::DoBuild( Job * job )
{

 const char * workingDir = m_WorkingDir.IsEmpty() ? (0) : m_WorkingDir.Get();

 AStackString<> fullArgs( m_Arguments );
 fullArgs.Replace( "%1", m_SourceFile->GetName().Get() );
 fullArgs.Replace( "%2", GetName().Get() );

 EmitCompilationMessage( fullArgs );


 Process p;
 bool spawnOK = p.Spawn( m_Executable->GetName().Get(),
       fullArgs.Get(),
       workingDir,
       FBuild::Get().GetEnvironmentString() );

 if ( !spawnOK )
 {
  do { FLog::Error( "Failed to spawn process for '%s'", GetName().Get() ); } while ( false ); ;
  return NODE_RESULT_FAILED;
 }


 AutoPtr< char > memOut;
 AutoPtr< char > memErr;
 uint32_t memOutSize = 0;
 uint32_t memErrSize = 0;
 p.ReadAllData( memOut, &memOutSize, memErr, &memErrSize );

 do { if ( !( !p.IsRunning() ) ) { if ( AssertHandler::Failure( "!p.IsRunning()", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/ExecNode.cpp", 85 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;

 int result = p.WaitForExit();


 if ( result != m_ExpectedReturnCode )
 {

  Node::DumpOutput( job, memOut.Get(), memOutSize );
  Node::DumpOutput( job, memErr.Get(), memErrSize );

  do { FLog::Error( "Execution failed (error %i) '%s'", result, GetName().Get() ); } while ( false ); ;
  return NODE_RESULT_FAILED;
 }


 m_Stamp = FileIO::GetFileLastWriteTime( m_Name );
 return NODE_RESULT_OK;
}



           Node * ExecNode::Load( IOStream & stream )
{
 AStackString<> fileName; if ( stream.Read( fileName ) == false ) { return (0); };
 AStackString<> sourceFile; if ( stream.Read( sourceFile ) == false ) { return (0); };
 AStackString<> executable; if ( stream.Read( executable ) == false ) { return (0); };
 AStackString<> arguments; if ( stream.Read( arguments ) == false ) { return (0); };
 AStackString<> workingDir; if ( stream.Read( workingDir ) == false ) { return (0); };
 int32_t expectedReturnCode; if ( stream.Read( expectedReturnCode ) == false ) { return (0); };
 Dependencies preBuildDependencies( 0, true ); if ( preBuildDependencies.Load( stream ) == false ) { return (0); };

 NodeGraph & ng = FBuild::Get().GetDependencyGraph();
 Node * srcNode = ng.FindNode( sourceFile );
 do { if ( !( srcNode ) ) { if ( AssertHandler::Failure( "srcNode", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/ExecNode.cpp", 119 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;
 do { if ( !( srcNode->IsAFile() ) ) { if ( AssertHandler::Failure( "srcNode->IsAFile()", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/ExecNode.cpp", 120 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;
 Node * execNode = ng.FindNode( executable );
 do { if ( !( execNode ) ) { if ( AssertHandler::Failure( "execNode", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/ExecNode.cpp", 122 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;
 do { if ( !( execNode->IsAFile() ) ) { if ( AssertHandler::Failure( "execNode->IsAFile()", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/ExecNode.cpp", 123 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;
 ExecNode * n = ng.CreateExecNode( fileName,
          (FileNode *)srcNode,
          (FileNode *)execNode,
          arguments,
          workingDir,
          expectedReturnCode,
          preBuildDependencies );
 do { if ( !( n ) ) { if ( AssertHandler::Failure( "n", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/ExecNode.cpp", 131 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;

 return n;
}



            void ExecNode::Save( IOStream & stream ) const
{
 stream.Write( m_Name );;
 stream.Write( m_SourceFile->GetName() );;
 stream.Write( m_Executable->GetName() );;
 stream.Write( m_Arguments );;
 stream.Write( m_WorkingDir );;
 stream.Write( m_ExpectedReturnCode );;
 m_PreBuildDependencies.Save( stream );;
}



void ExecNode::EmitCompilationMessage( const AString & args ) const
{

 AStackString< 2048 > output;
 output += "Run: ";
 output += GetName();
 output += '\n';


 if ( FLog::ShowInfo() || FBuild::Get().GetOptions().m_ShowCommandLines )
 {
  AStackString< 1024 > verboseOutput;
  verboseOutput.Format( "%s %s\nWorkingDir: %s\nExpectedReturnCode: %i\n",
         m_Executable->GetName().Get(),
         args.Get(),
         m_WorkingDir.Get(),
         m_ExpectedReturnCode );
  output += verboseOutput;
 }


 do { FLog::Build( "%s", output.Get() ); } while ( false ); ;
}
# 188 "/home/ffulin/p4/tmp/Unity/Tools/FBuild/FBuildCore/Unity1.cpp" 2


# 1 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/DirectoryListNode.cpp" 1





# 1 "./Tools/FBuild/FBuildCore/PrecompiledHeader.h" 1
# 7 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/DirectoryListNode.cpp" 2
# 22 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/DirectoryListNode.cpp"
DirectoryListNode::DirectoryListNode( const AString & name,
           const AString & path,
           const AString & wildcard,
              bool recursive,
           const Array< AString > & excludePaths )
: Node( name, Node::DIRECTORY_LIST_NODE, Node::FLAG_NONE )
 , m_Path( path )
 , m_WildCard( wildcard )
 , m_ExcludePaths( excludePaths )
 , m_Recursive( recursive )
 , m_Files( 4096, true )
{


 do { if ( !( name.BeginsWith( path ) ) ) { if ( AssertHandler::Failure( "name.BeginsWith( path )", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/DirectoryListNode.cpp", 36 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;
 do { if ( !( name[ path.GetLength() ] == '|' ) ) { if ( AssertHandler::Failure( "name[ path.GetLength() ] == '|'", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/DirectoryListNode.cpp", 37 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;
 do { if ( !( name.Find( wildcard.Get() ) == name.Get() + path.GetLength() + 1 ) ) { if ( AssertHandler::Failure( "name.Find( wildcard.Get() ) == name.Get() + path.GetLength() + 1", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/DirectoryListNode.cpp", 38 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;
 do { if ( !( ( recursive && name.Find( "|true|" ) ) || ( !recursive && name.Find( "|false|" ) ) ) ) { if ( AssertHandler::Failure( "( recursive && name.Find( \"|true|\" ) ) || ( !recursive && name.Find( \"|false|\" ) )",
 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/DirectoryListNode.cpp"
# 39 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/DirectoryListNode.cpp"
 ,
 40
# 39 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/DirectoryListNode.cpp"
 ) ) { __asm__ __volatile__("int $3"); } } } while ( false );
                                             ;


 do { if ( !( path.EndsWith( ( '/' ) ) ) ) { if ( AssertHandler::Failure( "path.EndsWith( NATIVE_SLASH )", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/DirectoryListNode.cpp", 43 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;



  const AString * const end = excludePaths.End();
  for ( const AString * it=excludePaths.Begin(); it != end; ++it )
  {
   do { if ( !( ( *it ).EndsWith( ( '/' ) ) ) ) { if ( AssertHandler::Failure( "( *it ).EndsWith( NATIVE_SLASH )", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/DirectoryListNode.cpp", 50 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;
  }

}



DirectoryListNode::~DirectoryListNode()
{
}



           void DirectoryListNode::FormatName( const AString & path,
              const AString & pattern,
              bool recursive,
              const Array< AString > & excludePaths,
              AString & result )
{
 do { if ( !( path.EndsWith( ( '/' ) ) ) ) { if ( AssertHandler::Failure( "path.EndsWith( NATIVE_SLASH )", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/DirectoryListNode.cpp", 69 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;
 do { if ( !( pattern.IsEmpty() == false ) ) { if ( AssertHandler::Failure( "pattern.IsEmpty() == false", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/DirectoryListNode.cpp", 70 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;

 result.Format( "%s|%s|%s|", path.Get(),
          pattern.Get(),
          recursive ? "true" : "false" );

 const AString * const end = excludePaths.End();
 for ( const AString * it = excludePaths.Begin(); it!=end; ++it )
 {
  const AString & excludePath = *it;
  do { if ( !( excludePath.EndsWith( ( '/' ) ) ) ) { if ( AssertHandler::Failure( "excludePath.EndsWith( NATIVE_SLASH )", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/DirectoryListNode.cpp", 80 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;
  result += excludePath;
  result += '<';
 }
}



            Node::BuildResult DirectoryListNode::DoBuild( Job * )
{



 Array< FileIO::FileInfo > files( 4096, true );
 FileIO::GetFilesEx( m_Path, m_WildCard, m_Recursive, &files );

 m_Files.SetCapacity( files.GetSize() );


 const FileIO::FileInfo * const end = files.End();
 for ( const FileIO::FileInfo * it = files.Begin(); it != end; it++ )
 {
  bool excluded = false;
  const AString * const eEnd = m_ExcludePaths.End();
  for ( const AString * eIt=m_ExcludePaths.Begin(); eIt != eEnd; ++eIt )
  {
   if ( it->m_Name.BeginsWithI( *eIt ) )
   {
    excluded = true;
    break;
   }
  }
  if ( !excluded )
  {
   m_Files.Append( *it );
  }
 }

 if ( FLog::ShowInfo() )
 {
  const size_t numFiles = m_Files.GetSize();
  do { if ( FLog::ShowInfo() ) { FLog::Info( "Dir: '%s' (found %u files)\n", m_Name.Get(), (uint32_t)numFiles ); } } while ( false );

                          ;
  for ( size_t i=0; i<numFiles; ++i )
  {
   do { if ( FLog::ShowInfo() ) { FLog::Info( " - %s\n", m_Files[ i ].m_Name.Get() ); } } while ( false ); ;
  }
 }

 return NODE_RESULT_OK;
}



           Node * DirectoryListNode::Load( IOStream & stream )
{
 AStackString<> name; if ( stream.Read( name ) == false ) { return (0); };
 AStackString<> path; if ( stream.Read( path ) == false ) { return (0); };
 AStackString<> wildCard; if ( stream.Read( wildCard ) == false ) { return (0); };
 Array< AString > excludePaths; if ( stream.Read( excludePaths ) == false ) { return (0); };
 bool recursive; if ( stream.Read( recursive ) == false ) { return (0); };

 NodeGraph & ng = FBuild::Get().GetDependencyGraph();
 Node * n = ng.CreateDirectoryListNode( name, path, wildCard, recursive, excludePaths );
 do { if ( !( n ) ) { if ( AssertHandler::Failure( "n", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/DirectoryListNode.cpp", 145 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;
 return n;
}



            void DirectoryListNode::Save( IOStream & stream ) const
{
 stream.Write( m_Name );;
 stream.Write( m_Path );;
 stream.Write( m_WildCard );;
 stream.Write( m_ExcludePaths );;
 stream.Write( m_Recursive );;
}
# 191 "/home/ffulin/p4/tmp/Unity/Tools/FBuild/FBuildCore/Unity1.cpp" 2


# 1 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/CopyNode.cpp" 1





# 1 "./Tools/FBuild/FBuildCore/PrecompiledHeader.h" 1
# 7 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/CopyNode.cpp" 2
# 21 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/CopyNode.cpp"
CopyNode::CopyNode( const AString & dstFileName,
     FileNode * sourceFile,
     const Dependencies & preBuildDependencies )
: FileNode( dstFileName, Node::FLAG_NONE )
, m_SourceFile( sourceFile )
{
 do { if ( !( sourceFile ) ) { if ( AssertHandler::Failure( "sourceFile", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/CopyNode.cpp", 27 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;
 do { if ( !( sourceFile->IsAFile() ) ) { if ( AssertHandler::Failure( "sourceFile->IsAFile()", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/CopyNode.cpp", 28 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;
 m_StaticDependencies.Append( Dependency( m_SourceFile ) );
 m_Type = Node::COPY_NODE;

 m_PreBuildDependencies = preBuildDependencies;
}



CopyNode::~CopyNode()
{
}



            Node::BuildResult CopyNode::DoBuild( Job * )
{
 EmitCopyMessage();


 if ( FileIO::FileCopy( m_SourceFile->GetName().Get(), m_Name.Get() ) == false )
 {
  do { FLog::Error( "Copy failed (error %i) '%s'", Env::GetLastErr(), GetName().Get() ); } while ( false ); ;
  return NODE_RESULT_FAILED;
 }

 if ( FileIO::SetReadOnly( m_Name.Get(), false ) == false )
 {
  do { FLog::Error( "Copy read-only flag set failed (error %i) '%s'", Env::GetLastErr(), GetName().Get() ); } while ( false ); ;
  return NODE_RESULT_FAILED;
 }






 m_Stamp = FileIO::GetFileLastWriteTime( m_SourceFile->GetName() );
 do { if ( !( m_Stamp ) ) { if ( AssertHandler::Failure( "m_Stamp", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/CopyNode.cpp", 66 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;
 if ( FileIO::SetFileLastWriteTime( m_Name, m_Stamp ) == false )
 {
  do { FLog::Error( "Copy set last write time failed (error %i) '%s'", Env::GetLastErr(), GetName().Get() ); } while ( false ); ;
  m_Stamp = 0;
  return NODE_RESULT_FAILED;
 }

 return NODE_RESULT_OK;
}



           Node * CopyNode::Load( IOStream & stream )
{
 AStackString<> fileName; if ( stream.Read( fileName ) == false ) { return (0); };
 AStackString<> sourceFile; if ( stream.Read( sourceFile ) == false ) { return (0); };
 Dependencies preBuildDependencies( 0, true ); if ( preBuildDependencies.Load( stream ) == false ) { return (0); };

 NodeGraph & ng = FBuild::Get().GetDependencyGraph();
 Node * srcNode = ng.FindNode( sourceFile );
 do { if ( !( srcNode ) ) { if ( AssertHandler::Failure( "srcNode", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/CopyNode.cpp", 87 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;
 do { if ( !( srcNode->IsAFile() ) ) { if ( AssertHandler::Failure( "srcNode->IsAFile()", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/CopyNode.cpp", 88 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;
 CopyNode * n = ng.CreateCopyNode( fileName, (FileNode *)srcNode, preBuildDependencies );
 do { if ( !( n ) ) { if ( AssertHandler::Failure( "n", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Graph/CopyNode.cpp", 90 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;
 return n;
}



            void CopyNode::Save( IOStream & stream ) const
{
 stream.Write( m_Name );;
 stream.Write( m_SourceFile->GetName() );;
 m_PreBuildDependencies.Save( stream );;
}



void CopyNode::EmitCopyMessage() const
{


 AStackString<> output;
 output += "Copy: ";
 output += m_StaticDependencies[ 0 ].GetNode()->GetName();
 output += " -> ";
 output += GetName();
 output += '\n';
 do { FLog::Build( "%s", output.Get() ); } while ( false ); ;
}
# 194 "/home/ffulin/p4/tmp/Unity/Tools/FBuild/FBuildCore/Unity1.cpp" 2


# 1 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/PrecompiledHeader.cpp" 1
# 1 "./Tools/FBuild/FBuildCore/PrecompiledHeader.h" 1
# 1 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/PrecompiledHeader.cpp" 2
# 197 "/home/ffulin/p4/tmp/Unity/Tools/FBuild/FBuildCore/Unity1.cpp" 2


# 1 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Cache/Cache.cpp" 1





# 1 "./Tools/FBuild/FBuildCore/PrecompiledHeader.h" 1
# 7 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Cache/Cache.cpp" 2
# 23 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Cache/Cache.cpp"
             Cache::Cache()
{
}



            Cache::~Cache()
{
}



            bool Cache::Init( const AString & cachePath )
{
 m_CachePath = cachePath;
 PathUtils::EnsureTrailingSlash( m_CachePath );
 if ( FileIO::EnsurePathExists( m_CachePath ) )
 {
  return true;
 }

 do { FLog::Warning( "Cache inaccessible - Caching disabled (Path '%s')", m_CachePath.Get() ); } while ( false ); ;
 return false;
}



            void Cache::Shutdown()
{

}



            bool Cache::Publish( const AString & cacheId, const void * data, size_t dataSize )
{
 AStackString<> cacheFileName;
 GetCacheFileName( cacheId, cacheFileName );


 char * lastSlash = cacheFileName.FindLast( ( '/' ) );
 *lastSlash = 0;
 if ( !FileIO::EnsurePathExists( cacheFileName ) )
 {
  return false;
 }
 *lastSlash = ( '/' );


 AStackString<> cacheFileTmpName( cacheFileName );
 cacheFileTmpName += ".tmp";
 FileStream cacheTmpFile;
 if( !cacheTmpFile.Open( cacheFileTmpName.Get(), FileStream::WRITE_ONLY ) )
 {
  return false;
 }


 bool cacheTmpWriteOk = ( cacheTmpFile.Write( data, dataSize ) == dataSize );
 cacheTmpFile.Close();

 if ( !cacheTmpWriteOk )
 {

  FileIO::FileDelete( cacheFileTmpName.Get() );
  return false;
 }


 if ( FileIO::FileMove( cacheFileTmpName, cacheFileName ) == false )
 {

  FileIO::FileDelete( cacheFileName.Get() );


  if ( FileIO::FileMove( cacheFileTmpName, cacheFileName ) == false )
  {

   FileIO::FileDelete( cacheFileTmpName.Get() );
   return false;
  }
 }

 return true;
}



            bool Cache::Retrieve( const AString & cacheId, void * & data, size_t & dataSize )
{
 data = (0);
 dataSize = 0;

 AStackString<> cacheFileName;
 GetCacheFileName( cacheId, cacheFileName );

 FileStream cacheFile;
 if ( cacheFile.Open( cacheFileName.Get(), FileStream::READ_ONLY ) )
 {
  const size_t cacheFileSize = (size_t)cacheFile.GetFileSize();
  AutoPtr< char > mem( (char *)::AllocFileLine( cacheFileSize, "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Cache/Cache.cpp", 123 ) );
  if ( cacheFile.Read( mem.Get(), cacheFileSize ) == cacheFileSize )
  {
   dataSize = cacheFileSize;
   data = mem.Release();
   return true;
  }
 }

 return false;
}



            void Cache::FreeMemory( void * data, size_t )
{
 ::Free( data );
}



void Cache::GetCacheFileName( const AString & cacheId, AString & path ) const
{

 path.Format( "%s%c%c\\%c%c\\%s", m_CachePath.Get(),
            cacheId[ 0 ],
            cacheId[ 1 ],
            cacheId[ 2 ],
            cacheId[ 3 ],
            cacheId.Get() );
}
# 200 "/home/ffulin/p4/tmp/Unity/Tools/FBuild/FBuildCore/Unity1.cpp" 2


# 1 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Cache/CachePlugin.cpp" 1





# 1 "./Tools/FBuild/FBuildCore/PrecompiledHeader.h" 1
# 7 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Cache/CachePlugin.cpp" 2
# 27 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Cache/CachePlugin.cpp"
             CachePlugin::CachePlugin( const AString & dllName ) :



  m_InitFunc( (0) ),
  m_ShutdownFunc( (0) ),
  m_PublishFunc( (0) ),
  m_RetrieveFunc( (0) ),
  m_FreeMemoryFunc( (0) )
{
# 53 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Cache/CachePlugin.cpp"
        do { if ( !( false ) ) { if ( AssertHandler::Failure( "false", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Cache/CachePlugin.cpp", 53 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;



}



            CachePlugin::~CachePlugin()
{
}



void * CachePlugin::GetFunction( const char * friendlyName, const char * mangledName ) const
{
# 80 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Cache/CachePlugin.cpp"
        return (0);



}



            void CachePlugin::Shutdown()
{
    if ( m_ShutdownFunc )
    {
        (*m_ShutdownFunc)();
    }
# 107 "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Cache/CachePlugin.cpp"
}



            bool CachePlugin::Init( const AString & cachePath )
{

 if ( m_InitFunc && m_ShutdownFunc && m_PublishFunc && m_RetrieveFunc && m_FreeMemoryFunc )
 {

  return (*m_InitFunc)( cachePath.Get() );
 }

 return false;
}



            bool CachePlugin::Publish( const AString & cacheId, const void * data, size_t dataSize )
{
 if ( m_PublishFunc )
 {
  return (*m_PublishFunc)( cacheId.Get(), data, dataSize );
 }
 return false;
}



            bool CachePlugin::Retrieve( const AString & cacheId, void * & data, size_t & dataSize )
{
 if ( m_RetrieveFunc )
 {
  unsigned long long size;
  bool ok = (*m_RetrieveFunc)( cacheId.Get(), data, size );
  dataSize = (size_t)size;
  return ok;
 }
 return false;
}



            void CachePlugin::FreeMemory( void * data, size_t dataSize )
{
 do { if ( !( m_FreeMemoryFunc ) ) { if ( AssertHandler::Failure( "m_FreeMemoryFunc", "/home/ffulin/p4/Code/Tools/FBuild/FBuildCore/Cache/CachePlugin.cpp", 152 ) ) { __asm__ __volatile__("int $3"); } } } while ( false ); ;
 if ( m_FreeMemoryFunc )
 {
  return (*m_FreeMemoryFunc)( data, dataSize );
 }
}
# 203 "/home/ffulin/p4/tmp/Unity/Tools/FBuild/FBuildCore/Unity1.cpp" 2
